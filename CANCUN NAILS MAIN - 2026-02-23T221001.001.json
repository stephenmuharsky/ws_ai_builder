{
  "name": "CANCUN NAILS MAIN",
  "nodes": [
    {
      "parameters": {
        "operation": "set",
        "key": "=processing_lock:{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ $('Set Initial Data').first().json.currentExecutionId }}",
        "keyType": "string"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -3776,
        736
      ],
      "id": "1ba03289-d5ee-48a8-bb11-047de93273d0",
      "name": "Set Processing Lock",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "amount": 6
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -3568,
        736
      ],
      "id": "e4b05eca-e1d2-4e3d-b926-d059b960915c",
      "name": "Wait",
      "webhookId": "e2a32e31-6349-4d3e-810b-6e7356ba4732"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "currentLockId",
        "key": "=processing_lock:{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -3360,
        736
      ],
      "id": "22754c37-310d-4e78-a70d-6f0dcbecc59d",
      "name": "Get Current Processing Lock",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "22fe0f83-5756-4438-87f4-0705ad13b862",
              "leftValue": "={{ $('Get Current Processing Lock').item.json.currentLockId }}",
              "rightValue": "={{ $('Set Initial Data').item.json.currentExecutionId }}",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3152,
        736
      ],
      "id": "506c22a4-d974-44c6-bdbe-a47eb35675fe",
      "name": "Am I the Processor?"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "batchedMessages",
        "key": "=messages:{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -2928,
        720
      ],
      "id": "65fe10d9-b2cf-4db3-abc7-3197f9587504",
      "name": "Pop All Batched Messages",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=messages:{{ $('Set Initial Data').first().json.userPhoneNumber }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -2736,
        720
      ],
      "id": "a942bd8d-65f7-4be5-a1ba-29be3b6bcdd5",
      "name": "Delete Message List",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=processing_lock:{{ $('Set Initial Data').first().json.userPhoneNumber }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -2576,
        720
      ],
      "id": "aa40f7a1-a834-428f-b284-63130ba44736",
      "name": "Delete Processing Lock",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "push",
        "list": "=messages:{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "messageData": "={{ $('Set Initial Data').first().json.messageBody }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -3968,
        736
      ],
      "id": "b20debae-c70a-4386-813f-b86a0fadd602",
      "name": "Push",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst inputData = items[0].json;\n\n// Get sender phone number - it's always available from Set Initial Data\nconst senderPhoneNumber = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Determine the message content\nlet messageContent = '';\n\n// Check if we have batched messages (from Redis for text messages)\nif (inputData.batchedMessages && Array.isArray(inputData.batchedMessages) && inputData.batchedMessages.length > 0) {\n  // Text messages that were batched\n  messageContent = inputData.batchedMessages.reverse().join(' ');\n} else if (inputData.messageBody) {\n  // Single message (including audio placeholder)\n  messageContent = inputData.messageBody;\n} else {\n  // Fallback - should not happen but prevents empty return\n  messageContent = '[Message received]';\n}\n\n// ALWAYS return output - never return empty array\nconst outputItem = {\n  json: {\n    messages: [\n      {\n        from: senderPhoneNumber,\n        id: \"batched-\" + new Date().getTime(),\n        timestamp: String(Math.floor(Date.now() / 1000)),\n        text: {\n          body: messageContent\n        },\n        type: \"text\"\n      }\n    ],\n    phoneNumber: senderPhoneNumber,\n    name: $('Set Initial Data').first().json.name\n  }\n};\n\nreturn [outputItem];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2400,
        720
      ],
      "id": "a51dd7a9-2416-49c0-8e95-9896ee214264",
      "name": "Combine Messages"
    },
    {
      "parameters": {
        "sendTo": "you_email",
        "subject": "=ðŸš¨ Rate Limit: {{ $('Set Initial Data').first().json.userPhoneNumber }}\n",
        "message": "=Hello Boss,\n\n<p>The user <strong>{{ $('Set Initial Data').item.json.name }}</strong> ({{ $('Set Initial Data').first().json.userPhoneNumber }}) has reached the limit of 30 messages per hour. ðŸš¨</p>\n\n<p><strong>Details:</strong></p>\n<ul>\n    <li><strong>Customer:{{ $('Set Initial Data').item.json.name }}</strong> </li>\n    <li><strong>Number:</strong> {{ $('Set Initial Data').first().json.userPhoneNumber }}</li>\n    <li><strong>Time:</strong> {{ $now.toFormat('yyyy-MM-dd HH:mm:ss') }}</li>\n    <li><strong>Messages sent:</strong> {{ $('Check Limit').first().json.hourlyCount }}</li>\n</ul>\n\n<p>The bot has already blocked further messages from this number for this hour.</p>\n\n<p>Possible spam or very active user. ðŸ‘€</p>",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -3504,
        496
      ],
      "id": "fb9aac96-4e51-4fef-9006-007a586c8945",
      "name": "Send Rate Limit Email",
      "webhookId": "7398a438-5f04-49db-b40d-fd28f48d54d1",
      "credentials": {
        "gmailOAuth2": {
          "id": "dnECY8GMehNvK0Ok",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "=agent_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "sessionTTL": 1800,
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryRedisChat",
      "typeVersion": 1.5,
      "position": [
        11072,
        -288
      ],
      "id": "1ac8415e-c5d3-4e4e-af39-75c8069e3a0b",
      "name": "Redis Chat Memory",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "content": "How to obtain Whatsapp API?\n\n\n### âœ… Prerequisites\nBefore you begin, make sure you have:\n- A **Meta Business Account**\n- A **Facebook Developer Account**\n- A **Verified Business**\n- A **Phone Number** to link to WhatsApp\n- Access to **Meta's Graph API Explorer** or **Meta for Developers portal**\n\n---\n\n### ðŸªœ STEP 1: Create a Meta App\n\n1. Go to [https://developers.facebook.com/apps](https://developers.facebook.com/apps)\n2. Click **â€œCreate Appâ€**\n3. Choose **\"Business\"** as the app type, then click **Next**\n4. Give your app a name and enter a contact email\n5. Choose your Business Account (or create one)\n6. Click **Create App**\n\n---\n\n### ðŸªœ STEP 2: Add WhatsApp Product\n\n1. In your app dashboard, scroll down to **\"Add a Product\"**\n2. Find **\"WhatsApp\"** and click **â€œSet Upâ€**\n3. Link your **Business Manager Account**\n\n---\n\n### ðŸªœ STEP 3: Create a WhatsApp Business Account (if needed)\n\n1. If you havenâ€™t already, go to [https://business.facebook.com/](https://business.facebook.com/)\n2. Click **â€œCreate Accountâ€**, and complete your business information\n3. Go to **Business Settings > Accounts > WhatsApp Accounts**\n4. Add a **Phone Number** (you'll receive a verification code)\n\n---\n\n### ðŸªœ STEP 4: Generate a Temporary Access Token (for development)\n\n1. In the **App Dashboard**, go to **WhatsApp > Getting Started**\n2. Choose your test phone number\n3. Copy the **temporary access token** (valid for 24 hours)\n4. Copy the **Phone Number ID** and **WhatsApp Business Account ID**\n\nâœ… Save these 3 values:\n- **Access Token**\n- **Phone Number ID**\n- **WABA ID**\n\nðŸ“ Tip: For production, you will later need to create a **permanent token** (see step 7).\n\n---\n\n### ðŸªœ STEP 5: Set Up a Webhook URL (n8n)\n\n1. In n8n, set up a **Webhook node** (or use the `WhatsApp Trigger` node)\n2. Copy the webhook URL\n3. In the Meta Developer Dashboard:\n   - Go to **WhatsApp > Configuration**\n   - Click **â€œEdit Callback URLâ€**\n   - Paste your n8n webhook URL and add a random **verify token**\n4. In n8n, configure your webhook to respond to the verification request\n\n---\n\n### ðŸªœ STEP 6: Subscribe to Webhook Fields\n\n1. Still under **WhatsApp > Configuration**, click **\"Manage Subscriptions\"**\n2. Enable:\n   - `messages`\n   - `message_status`\n   - (Optionally `message_template_status_update`)\n\n---\n\n### ðŸªœ STEP 7: (Optional but recommended) Generate a Permanent Token\n\n1. Go to [https://developers.facebook.com/tools/access_token/](https://developers.facebook.com/tools/access_token/)\n2. Select your app\n3. Click **Get Token > System User Token**\n4. Select the permissions:\n   - `whatsapp_business_management`\n   - `whatsapp_business_messaging`\n   - `business_management`\n5. Click **Generate Token**\n6. Copy and securely store this token\n\n---\n\n### ðŸªœ STEP 8: Configure Credentials in n8n\n\n1. Go to **n8n > Settings > Credentials**\n2. Create new credentials of type **HTTP Header Auth**\n   - **Name:** WhatsApp\n   - **Header Name:** `Authorization`\n   - **Value:** `Bearer <your_access_token>`\n3. Save\n\nThen, in your workflows:\n- Use the HTTP Request node or WhatsApp node\n- Set the `phone_number_id` in the node parameters\n- Connect it to your WhatsApp credential\n\n---\n\n### ðŸ§ª STEP 9: Test the Connection\n\n1. Use a WhatsApp number to send a message to your business phone\n2. Your n8n workflow should be triggered\n3. You can now send and receive messages programmatically ðŸŽ‰\n",
        "height": 2520,
        "width": 580,
        "color": 3
      },
      "id": "086e3b3f-03ae-4440-8204-96ad37f67e27",
      "name": "Sticky Note5",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -7200,
        464
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "content": "WhatsApp Nail Salon Bot Setup Guide\nPrerequisites & Services Required\n\n1. WhatsApp Business Setup\n   - Follow the WhatsApp configuration instructions on the right side\n   - Save your phone number ID and access token\n   - Configure webhook in Meta Developer Console\n\n2. Google Calendar Setup\n   - Create a new calendar named \"Nail Salon\" (or use existing)\n   - Get Calendar ID:\n     â€¢ Go to Calendar Settings â†’ Integrate\n     â€¢ Copy Calendar ID (looks like: abc123...@group.calendar.google.com)\n   - Enable Google Calendar API in Google Cloud Console\n   - Create OAuth2 credentials in n8n\n\n3. Redis Database\n   - Set up Redis instance:\n     â€¢ Redis Cloud (free tier): https://redis.com/try-free/\n   - Get connection details:\n     â€¢ Host\n     â€¢ Port (usually 6379)\n     â€¢ Password (if applicable)\n\n4. OpenAI API\n   - Sign up at https://platform.openai.com\n   - Create API key in Dashboard â†’ API keys\n   - Add billing (required for API usage)\n   - Model used: GPT-4-mini\n\n5. MCP Server Configuration\n   - Open n8n workflows\n   - Find \"Nail Salon: MCP Booking WhatsApp\" workflow\n   - Open the nail-salon-booking-mcp trigger node\n   - Copy the production URL (format: https://your-n8n.com/webhook/xyz/mcp/nail-salon-booking)\n   - Activate this workflow\n\n## IMPORTANT:\nFor additional security, it is advisable to set up authentication for MCP.",
        "height": 896,
        "width": 688,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -8000,
        512
      ],
      "id": "07f4b4e6-7b75-47ba-80d1-8e21a5d8b7bc",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "# 1ï¸âƒ£ MESSAGE INTAKE & NORMALIZATION\n\nEntry point for all incoming WhatsApp messages.\nHandles text, audio, and media â†’ converts to standardized text format.\n\nFLOW:\n- Webhook receives WhatsApp message\n- Checks if text message â†’ routes non-text to notification\n- Sets initial data (phone number, name, execution ID)\n- Rate limiter: 30 msgs/hour per user â†’ alerts owner if exceeded\n- Text messages batched in Redis for 8 seconds (handles split messages)\n- Processing lock ensures only one execution processes per user\n- Messages combined into single standardized payload",
        "height": 1300,
        "width": 3920,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -6224,
        128
      ],
      "id": "b658743c-2f4e-43ee-a4e2-f0231a74fd28",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "### Here we fetch all bookings from the user and check whether the limit has been reached. \n### This result is passed to the booking agent. \n\n### You can change it by opening the Limit Reached? node and modifying the condition:\n### \"limitReached = events.length >= 6;\"",
        "height": 944,
        "width": 784,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -928,
        432
      ],
      "id": "c2ae3271-2505-4799-b693-4ddfb74dba8e",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "content": "### If the user reaches the limit, one message will be sent to the user and another to the owner.",
        "height": 288,
        "width": 672,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4048,
        384
      ],
      "id": "e26fd72b-8af1-4d99-998f-46bd54e9c3c4",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        4208,
        48
      ],
      "id": "539a425a-b847-4ec3-8a8d-aae807cdd3ef",
      "name": "gemini-2.5-flash",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 569810801,
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=569810801"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Booking Type": "={{ $json.userflag.serviceName }}",
            "Booking Time": "={{ DateTime.fromISO($json.userflag.dateTime).setZone('America/Cancun').toFormat('M/d/yyyy H:mm:ss') }}\n",
            "Employee ID": "={{ $json.userflag.employeeID }}",
            "Client Name": "={{ $('Set Initial Data').first().json.name }}",
            "Contact ID": "={{ $('Set Initial Data').first().json.userPhoneNumber }}",
            "Amount": "={{ $json.userflag.servicePrice.split(',').map(p => parseFloat(p.trim())).reduce((sum, price) => sum + price, 0) }}",
            "Booking Confirmed": "No",
            "Nail Technician": "={{ $json.userflag.employeeName }}",
            "Booking  End Time": "={{ DateTime.fromISO($json.userflag.dateTime).plus({ minutes: $json.userflag.serviceDuration.split(',').map(d => parseFloat(d.trim())).reduce((sum, dur) => sum + dur, 0) }).setZone('America/Cancun').toFormat('M/d/yyyy H:mm:ss') }}",
            "Booking ID": "={{ $json.bookingId }}",
            "Booking Date": "={{ DateTime.fromISO($json.userflag.dateTime).setZone('America/Cancun').toFormat('yyyy-MM-dd') }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Booking Type",
              "displayName": "Booking Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Booking Time",
              "displayName": "Booking Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Nail Technician",
              "displayName": "Nail Technician",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Contact ID",
              "displayName": "Contact ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Booking Confirmed",
              "displayName": "Booking Confirmed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Amount",
              "displayName": "Amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Payment Method",
              "displayName": "Payment Method",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Tips",
              "displayName": "Tips",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Extra",
              "displayName": "Extra",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Booking  End Time",
              "displayName": "Booking  End Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Booking Date",
              "displayName": "Booking Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Booking ID",
              "displayName": "Booking ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "id": "b3a55ae8-7304-4553-8eb3-8885804f4246",
      "name": "Save Booking This Week",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2560,
        -4032
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "content": "### Here we fetch whether the user has already been registered to contacts and update accordingly ",
        "height": 640,
        "width": 688,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1616,
        592
      ],
      "id": "1763cbc8-976e-46f4-82e4-abddc2278b79",
      "name": "Sticky Note15"
    },
    {
      "parameters": {
        "operation": "hget",
        "key": "=userflag_{{ $('Set Initial Data').item.json.PhoneNumber }}",
        "field": "canBook",
        "propertyName": "canBook",
        "options": {}
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        -848,
        720
      ],
      "id": "a55deac8-c19c-44a2-b83c-fe2c3f6ffc44",
      "name": "get_userflag_can_book",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {canBook: \"true\", userBookings: $json.userBookings} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -320,
        880
      ],
      "id": "45d63526-04b0-48f8-84fa-5bfe0e45a8d3",
      "name": "Set UserFlag can_book",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "content": "## delete the whole user flag",
        "height": 544,
        "width": 3184
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1888,
        -4128
      ],
      "typeVersion": 1,
      "id": "2e0869ff-04cc-4bc1-8751-0126cb786a0c",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Get list of available nail services and their prices from the Services sheet.",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1786453814,
          "mode": "list",
          "cachedResultName": "Services (admin)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=1786453814"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.5,
      "position": [
        7504,
        560
      ],
      "id": "43539f92-1f9f-48b1-8026-f064f4bcdc91",
      "name": "list_services",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 735229643,
          "mode": "list",
          "cachedResultName": "Contacts",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=735229643"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Contact ID",
              "lookupValue": "={{ $('Set Initial Data').item.json.PhoneNumber }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        -1456,
        976
      ],
      "id": "8928e647-94e4-421b-bcdb-7dfbeee5f726",
      "name": "Fetch Registered Contact",
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $json[\"Contact ID\"] }}",
        "value": "={{ {registeredContact: \"true\"} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -1088,
        960
      ],
      "id": "7bf66616-bcef-4fa3-9f01-895f601cfbdc",
      "name": "set registered_contact",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hget",
        "key": "=userflag_{{ $json.phoneNumber }}",
        "field": "registeredContact",
        "propertyName": "registeredContact",
        "options": {}
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        -1552,
        736
      ],
      "id": "309d3de6-4d0c-4380-b620-1b874138f98f",
      "name": "get userflag_registered_contact",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "56d8aedf-be9c-4e43-bc1f-fcd2d70da7e4",
              "leftValue": "={{ $json.registeredContact }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1312,
        736
      ],
      "id": "9305a6c2-3ba3-414a-b17c-ca2d8aaedad0",
      "name": "If User is Registered cache"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "c21f6110-636c-4e5a-a7e2-572e7a708e16",
              "leftValue": "={{ $json['Contact ID'] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1296,
        976
      ],
      "id": "6535abd6-232f-4144-9d7b-0daa1de610c3",
      "name": "If User is Registered check"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "56d8aedf-be9c-4e43-bc1f-fcd2d70da7e4",
              "leftValue": "={{ $json.canBook }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -560,
        720
      ],
      "id": "e928a704-95e7-451f-a6ec-66672f75e43e",
      "name": "If User Can Book cache"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "c21f6110-636c-4e5a-a7e2-572e7a708e16",
              "leftValue": "={{ $json.canBook }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -496,
        1040
      ],
      "id": "8c0bd1d0-ec86-41fc-989e-5d482b3e08fe",
      "name": "If User Can Book Check"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 569810801,
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=569810801"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Contact ID",
              "lookupValue": "={{ $('Set Initial Data').item.json.PhoneNumber }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        -832,
        1040
      ],
      "id": "feb437d4-cdcb-4b9e-8d11-532a3244f7a4",
      "name": "Fetch User Bookings",
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const bookings = $input.all();\nconst BOOKING_LIMIT = 5;\n\n// Filter out empty rows (Sheets returns {} when no match)\nconst validBookings = bookings.filter(item => {\n  return item.json['Contact ID'] && item.json['Contact ID'] !== '';\n});\n\nconst canBook = validBookings.length < BOOKING_LIMIT;\n\n// Clean the bookings and CALCULATE duration from time fields\nconst cleanBookings = validBookings.map(item => {\n  const booking = item.json;\n  \n  // Calculate duration from Booking Time and Booking End Time\n  let duration = null;\n  if (booking['Booking Time'] && booking['Booking  End Time']) {\n    try {\n      const start = new Date(booking['Booking Time']);\n      const end = new Date(booking['Booking  End Time']);\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\n        duration = Math.round((end - start) / (1000 * 60)); // minutes\n      }\n    } catch (e) {\n      // Keep null\n    }\n  }\n  \n  return {\n    ...booking,\n    duration: duration,\n    servicePrice: booking['Amount'] || 0\n  };\n});\n\nreturn [{ \n  json: { \n    canBook,\n    hasBookings: cleanBookings.length > 0,\n    userBookings: JSON.stringify(cleanBookings)\n  } \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        1040
      ],
      "id": "ba0222c2-7b06-4912-8af2-9fa446950d57",
      "name": "Count Bookings",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -32,
        720
      ],
      "id": "e6b7615c-cf07-4962-98da-447095f2420d",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {canBook: \"false\", userBookings: $json.userBookings} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -320,
        1152
      ],
      "id": "50ccadec-5ed2-4103-83b5-3630cf6088c9",
      "name": "Set UserFlag cannot_book1",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "userflag",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "keyType": "hash",
        "options": {
          "dotNotation": false
        }
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        128,
        720
      ],
      "id": "dadbf551-63e5-41da-884f-c34102ead099",
      "name": "get_userflag_all",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4182e462-0c53-454e-827c-b0d262489915",
              "leftValue": "={{ $('Webhook').item.json.body.MessageType }}",
              "rightValue": "audio",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "29620234-3104-4817-b206-7017883e317f",
              "leftValue": "={{ $('Webhook').item.json.body.MessageType }}",
              "rightValue": "image",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "48a0492e-3453-4d59-a049-c583917ed2de",
              "leftValue": "={{ $('Webhook').item.json.body.MessageType }}",
              "rightValue": "document",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "18c67ec7-dc2b-4862-a09e-bef67c4b19a5",
              "leftValue": "={{ $('Webhook').item.json.body.MessageType }}",
              "rightValue": "video",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5760,
        720
      ],
      "id": "19d73458-d4a6-4b35-b54f-28d3b9ed7804",
      "name": "Is Text Message?"
    },
    {
      "parameters": {
        "content": "### Here are the nodes for the hourly rate limiter. The default is 30, but you can change it in the Rate Limiter node under hourlyLimit: 30",
        "height": 384,
        "width": 976,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -5072,
        544
      ],
      "id": "2a21e0b4-0e88-4269-b11a-12f2883a7d50",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "={{ $('Rate Limiter').first().json.hourlyKey }}",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -4640,
        720
      ],
      "id": "ae6462d8-9d34-40a2-a129-7627db6e5318",
      "name": "Increment Counter Hourly",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "hourlyCount",
        "key": "={{ $json.hourlyKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -4816,
        720
      ],
      "id": "285a40cf-fd40-49b7-a10b-54b49403312b",
      "name": "Redis Hourly",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b201613e-75f9-41b6-aea3-777a9c2ad222",
              "leftValue": "={{ $json.rateLimited }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -4288,
        720
      ],
      "id": "a60388d2-89c5-4883-bef4-07aa6b14ba73",
      "name": "Check Rate Limited"
    },
    {
      "parameters": {
        "jsCode": "const hourlyCount = parseInt($('Redis Hourly').first().json.hourlyCount || '0') + 1; // Old count + 1\nconst rateLimiterData = $('Rate Limiter').first().json;\nconst hourlyLimited = hourlyCount >= rateLimiterData.hourlyLimit;\n// Only send message on the FIRST rate limit hit (message #30)\nconst shouldSendMessage = hourlyLimited && hourlyCount === rateLimiterData.hourlyLimit;\nlet userMessage = null;\nlet ownerMessage = null;\nif (shouldSendMessage) {\n    userMessage = \"Give me a moment to respond ðŸ‘\";\n    \n    // Get client name for owner notification\n    const clientName = $('Set Initial Data').first().json.name;\n    const phoneNumber = $('Set Initial Data').first().json.PhoneNumber;\n    \n    ownerMessage = `ðŸš¨ SPAM ALERT\\n\\n${clientName} (${phoneNumber}) reached the limit of 30 messages/hour.\\n\\nThe bot blocked further messages. Check if you need to take action. ðŸ”`;\n}\nreturn [{\n    json: {\n        rateLimited: hourlyLimited,\n        shouldSendMessage: shouldSendMessage,\n        hourlyCount: hourlyCount,\n        hourlyKey: rateLimiterData.hourlyKey,\n        phoneNumber: rateLimiterData.phoneNumber,\n        userMessage: userMessage,\n        ownerMessage: ownerMessage\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4480,
        720
      ],
      "id": "8ce7af83-c67d-4593-ad80-f800cfd88480",
      "name": "Check Limit"
    },
    {
      "parameters": {
        "jsCode": "const phoneNumber = $('Set Initial Data').first().json.userPhoneNumber;\nconst currentTime = new Date();\nconst currentHour = currentTime.getHours();\n\n// DEBUG - See what time the server thinks it is\nconsole.log('Server time:', currentTime.toISOString());\nconsole.log('Server hour:', currentHour);\nconsole.log('Server timezone offset:', currentTime.getTimezoneOffset());\n\nconst hourKey = `rate_limit:${phoneNumber}:hour:${currentHour}`;\n\nreturn [{\n    json: {\n        phoneNumber: phoneNumber,\n        hourlyKey: hourKey,\n        hourlyLimit: 30,\n        serverTime: currentTime.toISOString(),\n        serverHour: currentHour\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4976,
        720
      ],
      "id": "06787b33-2d31-4570-b09a-3b8dff938de7",
      "name": "Rate Limiter"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "16bdfefd-4c3d-4665-b2ee-5842bc6369b0",
              "name": "currentExecutionId",
              "value": "={{ $execution.id }}",
              "type": "string"
            },
            {
              "id": "0eefb762-7841-4458-8699-3e04dea2ce8a",
              "name": "userPhoneNumber",
              "value": "={{ $json.body.WaId }}",
              "type": "string"
            },
            {
              "id": "df6f9634-fc87-4687-b956-2debcd2bc965",
              "name": "messageBody",
              "value": "={{ $json.body.Body }}",
              "type": "string"
            },
            {
              "id": "823a0a13-1c39-431d-b55a-9440bac7890c",
              "name": "PhoneNumber",
              "value": "={{ $json.body.WaId }}",
              "type": "string"
            },
            {
              "id": "e1d2b04a-57db-4a46-8257-8afb17ded39c",
              "name": "name",
              "value": "={{ $json.body.ProfileName }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -5280,
        720
      ],
      "id": "c6a51ef6-9610-4526-9b06-da965b8406c5",
      "name": "Set Initial Data"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "4a8b54b6-778f-41b8-9069-35ddd53113f8",
              "leftValue": "={{ $json.body.Body }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5536,
        736
      ],
      "id": "e709f9f7-c765-47a5-b848-33ad52bba2e9",
      "name": "If1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "6b09a6a1-80ba-421a-b14c-503b12de6f29",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.readyToBook }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2016,
        -4016
      ],
      "id": "78f0312d-c97d-4f64-bc74-ad0e9c442854",
      "name": "If2"
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// NODE: Calculate Blocked Time Range\n// PURPOSE: Convert booking data to Employee Availability format\n// ================================================================\n\n// Get booking data from previous nodes (via Redis userflags)\nconst userflag = $('get_userflag_all').first().json.userflag;\n\n// Extract required data\nconst dateTime = userflag.dateTime; // UTC ISO format: \"2025-11-25T19:30:00.000Z\"\nconst serviceDuration = userflag.serviceDuration; // \"60\" or \"60,30\" for multiple services\nconst employeeID = userflag.employeeID; // \"EMP001\"\nconst employeeName = userflag.employeeName; // \"Maria\"\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STEP 1: Calculate total service duration (handle comma-separated)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst totalDuration = serviceDuration\n  .split(',')\n  .map(d => parseFloat(d.trim()))\n  .reduce((sum, dur) => sum + dur, 0);\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STEP 2: Convert UTC ISO to EST (America/Cancun)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst startTimeEST = DateTime.fromISO(dateTime, { zone: 'UTC' })\n  .setZone('America/Cancun');\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STEP 3: Calculate end time\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst endTimeEST = startTimeEST.plus({ minutes: totalDuration });\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STEP 4: Format times as \"H:MM AM/PM\"\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nfunction formatTime(luxonDateTime) {\n  const hour = luxonDateTime.hour;\n  const minute = luxonDateTime.minute;\n  const period = hour >= 12 ? 'PM' : 'AM';\n  \n  // Convert to 12-hour format\n  let displayHour = hour > 12 ? hour - 12 : hour;\n  if (displayHour === 0) displayHour = 12;\n  \n  return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;\n}\n\nconst startTimeFormatted = formatTime(startTimeEST);\nconst endTimeFormatted = formatTime(endTimeEST);\nconst blockedTimeRange = `${startTimeFormatted}-${endTimeFormatted}`;\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STEP 5: Extract date as YYYY-MM-DD\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst dateStr = startTimeEST.toFormat('yyyy-MM-dd');\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// OUTPUT\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nreturn [{\n  json: {\n    employeeID: employeeID,\n    employeeName: employeeName,\n    date: dateStr,\n    blockedTimeRange: blockedTimeRange,\n    startTime: startTimeFormatted,\n    endTime: endTimeFormatted,\n    duration: totalDuration,\n    \n    // Debug info (optional, can remove in production)\n    debug: {\n      originalDateTimeUTC: dateTime,\n      convertedDateTimeEST: startTimeEST.toISO(),\n      totalDurationMinutes: totalDuration\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3824,
        -4032
      ],
      "id": "c4d5a434-c115-44fa-97e8-30bb7ba63d0f",
      "name": "Calculate Blocked Time Range"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Match Key",
              "lookupValue": "={{ $('Calculate Blocked Time Range').first().json.date + '_' + $('Calculate Blocked Time Range').first().json.employeeID }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        4016,
        -4032
      ],
      "id": "212577bc-0c86-4a9d-8200-70c77c70f0b6",
      "name": "Read Employee Availability Row",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const bookingData = $('Calculate Blocked Time Range').first().json;\nconst availabilityRow = $('Read Employee Availability Row').first().json;\n\nif (!availabilityRow) {\n  throw new Error(`No availability row found for ${bookingData.employeeID} on ${bookingData.date}`);\n}\n\nconst currentBlockedTimes = availabilityRow['Blocked Times'] || '';\nconst newBlockedRange = bookingData.blockedTimeRange;\n\nconsole.log('Current blocked times:', currentBlockedTimes);\nconsole.log('New range:', newBlockedRange);\n\nconst updatedBlockedTimes = currentBlockedTimes.trim() === '' \n  ? newBlockedRange \n  : `${currentBlockedTimes}, ${newBlockedRange}`;\n\nconsole.log('Updated blocked times:', updatedBlockedTimes);\n\n// CREATE MATCH KEY HERE instead of relying on Node 1\nconst matchKey = `${bookingData.date}_${bookingData.employeeID}`;\n\nreturn [{\n  json: {\n    matchKey: matchKey,  // Changed from bookingData.matchKey\n    updatedBlockedTimes: updatedBlockedTimes\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4240,
        -4032
      ],
      "id": "e9a9b3c3-bf2c-4b90-838a-cbeca5660e4e",
      "name": "Find and Update Blocked Times"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Match Key": "={{ $json.matchKey }}",
            "Blocked Times": "={{ $json.updatedBlockedTimes }}"
          },
          "matchingColumns": [
            "Match Key"
          ],
          "schema": [
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Match Key",
              "displayName": "Match Key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Employee Name",
              "displayName": "Employee Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Working Hours",
              "displayName": "Working Hours",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Blocked Times",
              "displayName": "Blocked Times",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        4448,
        -4032
      ],
      "id": "1b1837e4-9a73-4ab7-90b2-6c5d3fed859e",
      "name": "Append or update row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "10467f19-b882-486d-9f09-9d78b2a30967",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.greeting }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1104,
        736
      ],
      "id": "5921b613-928c-4db1-bb67-88d6e3eaea3c",
      "name": "If3"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {greeting: \"true\"} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1440,
        736
      ],
      "id": "3d519ecd-945c-432d-952d-2e5eac6bb7dc",
      "name": "set_userflag_greeting",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "gpt-5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        7184,
        560
      ],
      "id": "3170c5ed-a701-4eb3-a700-c03b6b1c98fd",
      "name": "gpt-5",
      "credentials": {
        "openAiApi": {
          "id": "zJNQPdRuutiKnfPk",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "This tool is used to check availability for an appointment.",
        "jsCode": "// ============================================\n// GET INPUT FROM AI AGENT TOOL\n// ============================================\nlet inputData;\nif (typeof query !== 'undefined' && query) {\n  inputData = typeof query === 'string' ? JSON.parse(query) : query;\n} else {\n  return JSON.stringify({\n    available: false,\n    reason: \"parsing_error\",\n    error: \"No query parameter found\"\n  });\n}\n\n// Extract and validate parameters\nconst datetime = inputData.datetime;\nconst duration = parseInt(inputData.duration);\nconst workingHours = inputData.workingHours || \"\";\nconst blockedTimes = inputData.blockedTimes || \"\";\nconst employeeID = inputData.employeeID || \"\";\nconst employeeName = inputData.employeeName || \"\";\n\n// DETAILED DEBUGGING\nconsole.log('=== DEBUGGING EXTRACTED VALUES ===');\nconsole.log('datetime:', datetime, '| type:', typeof datetime, '| truthy:', !!datetime);\nconsole.log('duration:', duration, '| type:', typeof duration, '| truthy:', !!duration);\nconsole.log('workingHours:', workingHours, '| type:', typeof workingHours, '| truthy:', !!workingHours);\nconsole.log('blockedTimes:', blockedTimes);\nconsole.log('employeeID:', employeeID);\nconsole.log('employeeName:', employeeName);\n\n// Validate required parameters\nif (!datetime || !duration || !workingHours) {\n  console.log('VALIDATION FAILED!');\n  console.log('datetime check:', !datetime);\n  console.log('duration check:', !duration);\n  console.log('workingHours check:', !workingHours);\n  \n  return JSON.stringify({\n    available: false,\n    reason: \"missing_parameters\",\n    error: \"Missing required parameters: datetime, duration, or workingHours\",\n    debug: {\n      datetime: datetime,\n      duration: duration,\n      workingHours: workingHours\n    }\n  });\n}\n\nconsole.log('VALIDATION PASSED - continuing...');\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\n// Convert UTC ISO to local time (EST/UTC-5)\nfunction utcToLocal(utcDatetime) {\n  const date = new Date(utcDatetime);\n  const localHour = date.getUTCHours() - 5;\n  const localMinute = date.getUTCMinutes();\n  return { hour: localHour, minute: localMinute };\n}\n\n// Parse time string like \"9:00 AM\" to 24-hour\nfunction parseTime(timeStr) {\n  const [time, period] = timeStr.split(' ');\n  let [hour, minute] = time.split(':').map(Number);\n  if (period === 'PM' && hour !== 12) hour += 12;\n  if (period === 'AM' && hour === 12) hour = 0;\n  return { hour, minute };\n}\n\n// Check if time is in range\nfunction isTimeInRange(checkTime, startTime, endTime) {\n  const checkMinutes = checkTime.hour * 60 + checkTime.minute;\n  const startMinutes = startTime.hour * 60 + startTime.minute;\n  const endMinutes = endTime.hour * 60 + endTime.minute;\n  return checkMinutes >= startMinutes && checkMinutes < endMinutes;\n}\n\n// Check if two time ranges overlap\nfunction timeRangesOverlap(start1, end1, start2, end2) {\n  const start1Min = start1.hour * 60 + start1.minute;\n  const end1Min = end1.hour * 60 + end1.minute;\n  const start2Min = start2.hour * 60 + start2.minute;\n  const end2Min = end2.hour * 60 + end2.minute;\n  \n  return start1Min < end2Min && end1Min > start2Min;\n}\n\n// ============================================\n// AVAILABILITY CHECK LOGIC\n// ============================================\n\n// STEP 1: Check if working\nif (workingHours.toUpperCase() === \"OFF\") {\n  return JSON.stringify({\n    available: false,\n    reason: \"not_working\",\n    employeeID: employeeID,\n    employeeName: employeeName\n  });\n}\n\n// STEP 2: Parse working hours - handle both \"9:00 AM - 6:00 PM\" and \"9:00 AM-6:00 PM\"\nconst [startStr, endStr] = workingHours.includes(' - ') \n  ? workingHours.split(' - ')\n  : workingHours.split('-').map(s => s.trim());\n\nconsole.log('startStr:', startStr);\nconsole.log('endStr:', endStr);\n\nconst workStart = parseTime(startStr);\nconst workEnd = parseTime(endStr);\n\n// STEP 3: Get requested time in local\nconst requestedTime = utcToLocal(datetime);\nconst requestedEndTime = {\n  hour: requestedTime.hour,\n  minute: requestedTime.minute + duration\n};\nif (requestedEndTime.minute >= 60) {\n  requestedEndTime.hour += Math.floor(requestedEndTime.minute / 60);\n  requestedEndTime.minute = requestedEndTime.minute % 60;\n}\n\n// STEP 4: Check if requested time is within working hours\nif (!isTimeInRange(requestedTime, workStart, workEnd)) {\n  return JSON.stringify({\n    available: false,\n    reason: \"outside_working_hours\",\n    employeeID: employeeID,\n    employeeName: employeeName\n  });\n}\n\n// STEP 5: Check blocked times (only if blockedTimes is not empty)\nif (blockedTimes && typeof blockedTimes === 'string' && blockedTimes.trim() !== \"\") {\n  const blocks = blockedTimes.split(',').map(b => b.trim());\n  \n  for (const block of blocks) {\n    if (block && block.includes('-')) {\n      const [blockStartStr, blockEndStr] = block.split('-');\n      const blockStart = parseTime(blockStartStr.trim());\n      const blockEnd = parseTime(blockEndStr.trim());\n      \n      if (timeRangesOverlap(requestedTime, requestedEndTime, blockStart, blockEnd)) {\n        return JSON.stringify({\n          available: false,\n          reason: \"time_blocked\",\n          employeeID: employeeID,\n          employeeName: employeeName\n        });\n      }\n    }\n  }\n}\n\n// STEP 6: Available!\nreturn JSON.stringify({\n  available: true,\n  employeeID: employeeID,\n  employeeName: employeeName\n});"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        11136,
        624
      ],
      "id": "f43d57dd-0610-46aa-931b-2109d55b76b4",
      "name": "process_availability_check"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Date",
              "lookupValue": "={{ $fromAI('date', 'Appointment date in YYYY-MM-DD format (e.g., 2025-11-28)', 'string') }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        10976,
        624
      ],
      "id": "a5729829-e325-405a-a14b-d37cee137cbf",
      "name": "get_employee_availability",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "36aca80c-0789-4bb3-b0b3-5eaf9652b333",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "CREATE_BOOKING",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CREATE_BOOKING"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "67c38758-432c-4fc4-bbc3-665931e2b70b",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "CANCEL_BOOKING",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CANCEL_BOOKING"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4cc12377-2289-4de9-ae47-59cd2cbcd72c",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "VIEW_BOOKINGS",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "VIEW_BOOKINGS"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a1a7c14c-8bd4-4e44-b70d-2338aa3edb70",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "=UPDATE_BOOKING",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "UPDATE_BOOKING"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "153f15d6-92c0-4a3c-921c-2fcc64dc6e56",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "OTHER",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "=OTHER"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "07473830-b954-47b6-83d0-339f5bdeb980",
                    "leftValue": "={{ $('Context Switch Identifier').item.json.intent }}",
                    "rightValue": "GENERAL",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "GENERAL"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        2848,
        656
      ],
      "id": "ce7413b2-fe2a-4a2e-966c-ee224a1c980f",
      "name": "Intent Switch"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {activeIntent : $('Context Switch Identifier').item.json.intent} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2672,
        720
      ],
      "id": "de8aa75e-fa2a-4fba-be87-7048a186ed19",
      "name": "set_userflag_active_intent",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User: {{ $('Set Initial Data').first().json.messageBody }}\nToday: {{ $now.setZone('America/Cancun').toFormat('cccc, MMMM d, yyyy') }}\n\nAppointments:\n{{ $('get_userflag_all').first().json.userflag.userBookings }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "## Salon Cancellation Assistant\n**RESPOND IN ENGLISH ONLY.**\n\nCustomer's appointments are provided above as JSON array.\n\n## YOUR JOB\nIdentify which appointment to cancel and output the details as JSON. The system will handle the actual deletion.\n\n## DECISION LOGIC\n\n1. User says generic \"cancel appointment\" / \"cancel my booking\":\n   - 1 appointment total â†’ Output cancel JSON immediately\n   - Multiple appointments â†’ Output clarify JSON with numbered list\n\n2. User specifies criteria (day, date, service, technician):\n   - 1 match â†’ Output cancel JSON immediately\n   - Multiple matches â†’ Output clarify JSON with numbered list of MATCHES only\n   - 0 matches â†’ Output clarify JSON: \"You don't have an appointment [matching criteria]\"\n\n3. User selecting from list (\"first one\", \"1\", \"the manicure\"):\n   - Output cancel JSON for that one\n\n## MATCHING CRITERIA\n- Day: \"Monday\", \"tomorrow\", \"next week\"\n- Service: \"manicure\", \"pedicure\", \"spa\", \"deluxe\", \"express\", \"classic\"\n- Technician: \"with Sarah\", \"David's\", \"Emily\"\n- Time: \"3pm\", \"morning one\", \"11am\"\n\n## OUTPUT FORMAT\n\n**When canceling (1 match found):**\n```json\n{\n  \"action\": \"cancel\",\n  \"row_number\": 2,\n  \"service\": \"Classic Manicure & Pedicure\",\n  \"datetime\": \"1/6/2026 15:00:00\",\n  \"technician\": \"Sarah Johnson\",\n  \"employee_id\": \"EMP001\"\n}\n```\n\n**When clarifying (multiple matches or no match):**\n```json\n{\n  \"action\": \"clarify\",\n  \"message\": \"Which appointment would you like to cancel?\\n\\n1. Classic Manicure - Monday Jan 5, 2:00 PM\\n2. Spa Pedicure - Wednesday Jan 8, 11:00 AM\"\n}\n```\n\n## EXAMPLES\n\nUser: \"Cancel my appointment\"\n(1 appointment exists)\nâ†’ Output cancel JSON with that appointment's details\n\nUser: \"Cancel my appointment\" \n(3 appointments exist)\nâ†’ Output clarify JSON with numbered list of all 3\n\nUser: \"Cancel my Monday appointment\"\n(1 Monday appointment exists)\nâ†’ Output cancel JSON for the Monday one\n\nUser: \"Cancel my Monday appointment\"\n(2 Monday appointments exist)\nâ†’ Output clarify JSON listing only the Monday ones\n\nUser: \"Cancel with David\"\n(1 David appointment exists)\nâ†’ Output cancel JSON for David's appointment\n\nUser: \"Cancel my Friday appointment\"\n(no Friday appointments)\nâ†’ Output clarify JSON: \"You don't have an appointment on Friday. Your appointments are:\\n\\n1. ...\"\n\nUser: \"the first one\" / \"1\" / \"the manicure\"\n(after showing list)\nâ†’ Output cancel JSON for the referenced appointment\n\n## CRITICAL RULES\n- Output valid JSON only - no extra text\n- Use EXACT values from the appointments array (row_number, service name, datetime, etc.)\n- Never fabricate or guess appointment data\n- Include ALL fields in cancel JSON: action, row_number, service, datetime, technician, employee_id\n- For clarify messages, format dates nicely (e.g., \"Monday Jan 5, 2:00 PM\")"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4448,
        3712
      ],
      "id": "745f11bf-0bbb-473f-a5c7-cb21cf05d335",
      "name": "cancel_agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "6a92918c-ee9b-4d20-874f-f192e210a08a",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.canBook }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3744,
        48
      ],
      "id": "3bbdb2cc-e659-482e-8e21-7c6cc7dbfb52",
      "name": "If4"
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "fields": "serviceID, serviceName, serviceDuration, servicePrice, dateTime, dateTimeConfirmed, employeeID, employeeName, availabilityConfirmed, readyToBook"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2304,
        720
      ],
      "id": "9454bbde-67cc-43d6-8c73-91028879578c",
      "name": "Wipe Booking Data - Context Switch",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"intent\": {\n      \"type\": \"string\",\n      \"enum\": [\"CREATE_BOOKING\", \"CANCEL_BOOKING\", \"UPDATE_BOOKING\", \"VIEW_BOOKINGS\", \"OTHER\", \"GENERAL\"]\n    }\n  },\n  \"required\": [\"intent\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1872,
        1024
      ],
      "id": "ca90c11a-c4a1-420a-a160-42b9c706424d",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "jsCode": "// Get AI classification\nconst aiIntent = $input.first().json.output.intent;\n\n// Get user context\nconst userFlags = $('get_userflag_all').first().json.userflag || {};\nconst activeIntent = userFlags?.activeIntent;\n\n// Check if user has CREATE_BOOKING progress\nconst hasCreateBookingProgress = !!(\n  userFlags?.serviceID || \n  userFlags?.dateTime || \n  userFlags?.employeeID || \n  userFlags?.readyToBook === 'true'\n);\n\n// Check if user has UPDATE_BOOKING progress\nconst hasUpdateBookingProgress = !!(\n  userFlags?.bookingModification ||\n  userFlags?.pendingUpdateAlternatives ||\n  userFlags?.readyToSave === 'true'\n);\n\n// Combined check for any active booking progress\nconst hasBookingProgress = hasCreateBookingProgress || hasUpdateBookingProgress;\n\n// Decide final intent\nlet finalIntent = aiIntent;\nlet needsCleanup = false;\nlet needsActiveIntentUpdate = true; // Default: UPDATE activeIntent\n\n// GENERAL - Route to General Agent, keep existing activeIntent\nif (aiIntent === 'GENERAL') {\n  finalIntent = 'GENERAL';\n  needsCleanup = false;\n  needsActiveIntentUpdate = false; // Don't overwrite existing booking intent\n}\n\n// OTHER during active flow â†’ maintain current flow\nelse if (activeIntent && \n         aiIntent === 'OTHER' && \n         (activeIntent === 'CREATE_BOOKING' || \n          activeIntent === 'CANCEL_BOOKING' || \n          activeIntent === 'UPDATE_BOOKING')) {\n  finalIntent = activeIntent;\n  needsActiveIntentUpdate = false; // Keep existing activeIntent\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// KEY FIX: Maintain UPDATE_BOOKING flow when user has update progress\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// When user says \"yes\", \"book it\", \"sure\" during UPDATE flow with pendingUpdateAlternatives,\n// AI might classify as CREATE_BOOKING - we need to keep it as UPDATE_BOOKING\nelse if ((aiIntent === 'CREATE_BOOKING' || aiIntent === 'OTHER') && \n         activeIntent === 'UPDATE_BOOKING' && \n         hasUpdateBookingProgress) {\n  finalIntent = 'UPDATE_BOOKING';\n  needsActiveIntentUpdate = false; // Keep existing activeIntent\n}\n\n// \"change\" during CREATE_BOOKING with progress â†’ stay in CREATE\nelse if (aiIntent === 'UPDATE_BOOKING' && \n         activeIntent === 'CREATE_BOOKING' && \n         hasCreateBookingProgress) {\n  finalIntent = 'CREATE_BOOKING';\n  needsActiveIntentUpdate = false; // Keep existing activeIntent\n}\n\n// Actual intent switch\nelse if (activeIntent && aiIntent !== activeIntent && aiIntent !== 'OTHER') {\n  finalIntent = aiIntent;\n  needsCleanup = hasBookingProgress && \n                 (activeIntent === 'CREATE_BOOKING' || \n                  activeIntent === 'CANCEL_BOOKING' || \n                  activeIntent === 'UPDATE_BOOKING');\n  // needsActiveIntentUpdate stays true - we're switching intents\n}\n\nreturn [{\n  json: {\n    intent: finalIntent,\n    needsCleanup: needsCleanup,\n    needsActiveIntentUpdate: needsActiveIntentUpdate,\n    // Debug info (optional - remove in production)\n    _debug: {\n      aiIntent,\n      activeIntent,\n      hasCreateBookingProgress,\n      hasUpdateBookingProgress,\n      pendingUpdateAlternatives: !!userFlags?.pendingUpdateAlternatives,\n      bookingModification: !!userFlags?.bookingModification\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1936,
        720
      ],
      "id": "60215438-c1aa-4169-a202-66bbed079283",
      "name": "Context Switch Identifier"
    },
    {
      "parameters": {
        "options": {
          "maxOutputTokens": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1584,
        1008
      ],
      "id": "c48c52d7-824a-487f-931a-e27451eea646",
      "name": "gemini-intent-router",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's Message: {{ $('Set Initial Data').first().json.messageBody }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are a STATELESS intent classifier. You have NO MEMORY. You do NOT see previous messages. You ONLY see the current message.\n\nYour ONLY job: Classify THIS SINGLE MESSAGE and return JSON.\n\nIntent types:\nCREATE_BOOKING - \"book appointment\", \"schedule manicure\", \"I want to get my nails done\", etc.\nQuestions about availability WITH a specific time/date â†’ CREATE_BOOKING\nExamples: \"do you have 7pm Thursday?\", \"is 3pm available?\nCANCEL_BOOKING - \"cancel my appointment\", \"remove my booking\", \"delete reservation\", etc.\nUPDATE_BOOKING - \"change my appointment\", \"reschedule\", \"move to different time\", etc.\nVIEW_BOOKINGS - \"show my appointments\", \"view bookings\", \"list my reservations\", etc.\nGENERAL -  Questions asking for information WITHOUT specific times: \"what time do you open?\", \"how much does X cost?\", \"where are you located?\", \"who are your technicians?\", etc.\nQuestions about hours/info WITHOUT a specific time â†’ GENERAL \nExamples: \"what are your hours?\", \"when do you open?\", \"is Sarah working tomorrow?\"\nOTHER - Everything else: \"yes\", \"no\", \"okay\", \"maybe\", \"any technician\", \"tomorrow at 3pm\", \"doesn't matter\"\n\nCRITICAL RULES:\n- Single word responses (yes/no/okay/maybe) â†’ ALWAYS OTHER\n- Preferences without question marks (any technician/next available/doesn't matter) â†’ ALWAYS OTHER\n- Questions with question marks asking for info â†’ GENERAL\n- Statements providing information (tomorrow at 3pm/classic manicure) â†’ OTHER\n\nReturn ONLY: {\"intent\": \"INTENT_TYPE\"}\n\n\n\n",
          "maxIterations": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1632,
        736
      ],
      "id": "feaebafb-9168-4aec-aa58-01788722e7fb",
      "name": "Intent Router Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        7344,
        560
      ],
      "id": "432fb595-bc5f-4ef4-a95d-6ea951ef92c1",
      "name": "employee_list",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "620dae92-eb7a-4812-bef0-463d30844f69",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.pendingAlternatives }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4000,
        -112
      ],
      "id": "18cfd45c-bd80-4022-96b9-abfa72112558",
      "name": "pendingAlternatives?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's Message: {{ $('Set Initial Data').first().json.messageBody }}\nPending Alternatives:{{ $('get_userflag_all').first().json.userflag.pendingAlternatives }}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You classify user responses to a single presented time slot alternative.\n\n## CONTEXT\n- User was shown ONE alternative time slot\n- pendingAlternatives: JSON array with 1 option (datetime, employeeID, employeeName, timeDisplay, dateDisplay)\n- User saw options: \"yes\" to book, \"other technician\" to try different tech, or provide different time\n\n## OUTPUT FORMAT\n{\"action\": \"selected\" | \"other_technician\" | \"reroute\" | \"unclear\", \"index\": 0}\n\nInclude \"index\": 0 only when action is \"selected\"\n\n---\n\n## 1. SELECTED (accepting the alternative)\n\nUser is ACCEPTING the shown slot.\n\nTriggers:\n- Affirmatives: \"yes\", \"yeah\", \"yep\", \"ok\", \"okay\", \"sure\", \"sounds good\", \"perfect\", \"book it\", \"let's do it\", \"that works\", \"1\", \"first\", \"the first one\"\n- Time confirmation: \"I'll take it\", \"I'll take the 3:30 slot\", \"book the 3:30\", \"that one\"\n\nExamples:\n- \"yes\" â†’ {\"action\": \"selected\", \"index\": 0}\n- \"Yeah that works\" â†’ {\"action\": \"selected\", \"index\": 0}\n- \"Book it\" â†’ {\"action\": \"selected\", \"index\": 0}\n- \"1\" â†’ {\"action\": \"selected\", \"index\": 0}\n- \"Sure\" â†’ {\"action\": \"selected\", \"index\": 0}\n\n---\n\n## 2. OTHER_TECHNICIAN (try original time with different tech)\n\nUser wants to check ORIGINAL requested time with ANY other technician.\n\nTriggers:\n- Generic tech phrases: \"other technician\", \"another technician\", \"different technician\", \"someone else\", \"anybody else\", \"whoever else\", \"try another tech\", \"check other technicians\"\n- NOT specific names (those â†’ reroute)\n\nExamples:\n- \"other technician\" â†’ {\"action\": \"other_technician\"}\n- \"try another technician\" â†’ {\"action\": \"other_technician\"}\n- \"check with someone else\" â†’ {\"action\": \"other_technician\"}\n- \"is anyone else available?\" â†’ {\"action\": \"other_technician\"}\n- \"another tech\" â†’ {\"action\": \"other_technician\"}\n\n---\n\n## 3. REROUTE (wants something different)\n\nUser wants a DIFFERENT time, names a specific technician, rejects the slot, or wants to cancel.\n\nTriggers:\n- Rejection: \"no\", \"nope\", \"that doesn't work\", \"can't do that time\"\n- New time/date: any day, time, \"earlier\", \"later\", \"tomorrow\", \"next week\", \"Thursday\", \"3 PM\"\n- Specific technician NAME: \"Sarah\", \"David\", \"Emily\", \"what about with Maria instead?\"\n- Exploring options: \"what else do you have\", \"any other times\"\n- Cancellation: \"never mind\", \"forget it\", \"cancel\", \"start over\"\n\nExamples:\n- \"No, do you have Thursday at 3 PM?\" â†’ {\"action\": \"reroute\"}\n- \"That doesn't work for me\" â†’ {\"action\": \"reroute\"}\n- \"What about later in the day?\" â†’ {\"action\": \"reroute\"}\n- \"I need something earlier\" â†’ {\"action\": \"reroute\"}\n- \"Can I try with David instead?\" â†’ {\"action\": \"reroute\"}\n- \"never mind\" â†’ {\"action\": \"reroute\"}\n- \"yes but with Sarah\" â†’ {\"action\": \"reroute\"} (name overrides affirmative)\n\n---\n\n## 4. UNCLEAR (can't determine intent)\n\nUser response is ambiguous, off-topic, or confusing.\n\nTriggers:\n- Confusion: \"what?\", \"huh?\", \"I don't understand\"\n- Ambiguous: \"maybe\", \"I don't know\", \"hmm\"\n- Off-topic questions: \"how much?\", \"where are you located?\", \"what services do you have?\"\n- Gibberish, emojis only, random text\n\nExamples:\n- \"What?\" â†’ {\"action\": \"unclear\"}\n- \"???\" â†’ {\"action\": \"unclear\"}\n- \"How much does it cost?\" â†’ {\"action\": \"unclear\"}\n- \"maybe\" â†’ {\"action\": \"unclear\"}\n\n---\n\n## PRIORITY ORDER\nIf message contains multiple signals, use this priority:\n1. Specific technician name â†’ reroute (always wins)\n2. New time/date mentioned â†’ reroute\n3. Rejection words (no, can't, doesn't work) â†’ reroute\n4. \"other technician\" / \"someone else\" â†’ other_technician\n5. Affirmative (yes, ok, sure) â†’ selected\n6. Otherwise â†’ unclear\n\n---\n\n## CRITICAL RULES\n- Output ONLY valid JSON, no explanations\n- \"yes\", \"ok\", \"sure\", affirmatives â†’ selected with index: 0\n- \"other technician\", \"someone else\", \"another tech\" â†’ other_technician\n- New times/dates OR rejection OR specific names â†’ reroute\n- Specific names ALWAYS override affirmatives (\"yes but Sarah\" â†’ reroute)\n- \"cancel\" / \"never mind\" / \"forget it\" â†’ reroute\n- When uncertain â†’ unclear\n- Never mention: flags, Redis, UTC, ISO, phone numbers\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4272,
        -128
      ],
      "id": "632e1704-7003-4641-9886-9b57c8fa0602",
      "name": "Alternative Selection Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\"selected\", \"other_technician\", \"reroute\", \"unclear\"]\n    },\n    \"index\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 0\n    }\n  },\n  \"required\": [\"action\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        4480,
        32
      ],
      "id": "6c0ec3a6-1984-41a7-a47f-78a558f127e8",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "selected",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "2ff3c3ae-25af-415f-98d5-5fff433ebdfc"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "selected_alternative"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "397da50e-22da-430b-b248-e8d804bc2a0f",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "reroute",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "to_booking_agent"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7d744067-bfef-4c3a-b5bc-2ef3978cbf61",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "unclear",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "unclear"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "0d0a725c-323a-433c-b115-09bf548e5d92",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "other_technician",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "other_technician"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        5520,
        -176
      ],
      "id": "59fa24da-fd47-42bb-b408-70631f4596fc",
      "name": "Switch"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {\n  dateTime: $json.dateTime,\n  employeeID: $json.employeeID,\n  employeeName: $json.employeeName,\n  availabilityConfirmed: \"true\"\n} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        6032,
        -400
      ],
      "id": "ea600841-1890-4617-9ab2-126c5888702f",
      "name": "set_alternative",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "pendingAlternatives"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        6240,
        -400
      ],
      "id": "61b8a3e6-b5fd-4cc3-8079-077f28acb944",
      "name": "delete pendingAlternatives",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "pendingAlternatives,  availabilityConfirmed"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5840,
        -208
      ],
      "id": "7feae6b7-9ca5-43c8-9006-32149b724312",
      "name": "delete pendingAlternatives2",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get userflags\nconst userflag = $('get_userflag_all').first().json.userflag;\n\n// Parse alternatives from Redis\nconst alternatives = JSON.parse(userflag.pendingAlternatives);\n\n// Get the original requested datetime for \"other technician\" option\nconst originalDateTime = userflag.dateTime;\nlet originalTimeDisplay = '';\nif (originalDateTime) {\n  const dt = new Date(originalDateTime);\n  originalTimeDisplay = dt.toLocaleTimeString('en-US', { \n    hour: 'numeric', \n    minute: '2-digit', \n    hour12: true, \n    timeZone: 'America/Cancun' \n  });\n}\n\n// Build repetition message for single alternative\nlet message = `Would you like to book *${alternatives[0].dateDisplay} at ${alternatives[0].timeDisplay}* with ${alternatives[0].employeeName}?\\n\\n`;\nmessage += `Reply *\"yes\"* to book this slot\\n`;\n\n// Only show \"other technician\" option if they originally requested a specific tech\nif (userflag.employeeID && userflag.employeeID !== 'NEXT_AVAILABLE' && originalTimeDisplay) {\n  message += `Reply *\"other technician\"* to check ${originalTimeDisplay} with someone else\\n`;\n}\n\nmessage += `Or tell me a different date & time!`;\n\nreturn [{\n  json: {\n    message: message\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5840,
        -32
      ],
      "id": "8352d065-bcc6-4044-9208-1cce6e2f6f5d",
      "name": "Build Repetition Message"
    },
    {
      "parameters": {
        "jsCode": "const agentOutput = $input.first().json;\nconst index = 0; // Always 0 since we only have one alternative\n\n// Get userflags\nconst userflag = $('get_userflag_all').first().json.userflag;\n\n// Parse alternatives from Redis\nconst alternativesString = userflag.pendingAlternatives;\nconst alternativesArray = JSON.parse(alternativesString);\nconst selected = alternativesArray[index];\n\n// Get phone number for Redis operations\nconst phoneNumber = $('Set Initial Data').first().json.PhoneNumber;\n\n// Extract service info from userflags\nconst serviceName = userflag.serviceName || 'Service';\nconst serviceDuration = userflag.serviceDuration || '0';\n\n// Build confirmation message\nconst message = `Perfect! Here's your booking:\\n\\nðŸ“… ${selected.dateDisplay} at ${selected.timeDisplay}\\nðŸ’… ${serviceName} (${serviceDuration} min)\\nâœ¨ ${selected.employeeName}\\nðŸ“ Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\\n\\nReply 'confirm' to complete.`;\n\nreturn [{\n  json: {\n    phoneNumber: phoneNumber,\n    message: message,\n    // Data for Redis updates\n    dateTime: selected.datetime,\n    employeeID: selected.employeeID,\n    employeeName: selected.employeeName\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5840,
        -400
      ],
      "id": "1f7c7f63-647c-425a-b1a8-4dee7682b1ff",
      "name": "Extract Selection Data"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"success\": {\n      \"type\": \"boolean\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"available\": {\n          \"type\": \"boolean\"\n        },\n        \"reason\": {\n          \"type\": \"string\",\n          \"enum\": [\"specific_employee_unavailable\", \"no_employees_available\"]\n        },\n        \"employeeID\": {\n          \"type\": \"string\"\n        },\n        \"employeeName\": {\n          \"type\": \"string\"\n        },\n        \"alternatives\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"datetime\": {\n                \"type\": \"string\"\n              },\n              \"employeeID\": {\n                \"type\": \"string\"\n              },\n              \"employeeName\": {\n                \"type\": \"string\"\n              },\n              \"timeDisplay\": {\n                \"type\": \"string\"\n              },\n              \"dateDisplay\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\"datetime\", \"employeeID\", \"employeeName\", \"timeDisplay\", \"dateDisplay\"]\n          }\n        },\n        \"assigned\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"required\": [\"available\"]\n    }\n  },\n  \"required\": [\"success\", \"result\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        11280,
        624
      ],
      "id": "ee65ff51-b927-402f-b545-a9d5265341dc",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        4656,
        -4032
      ],
      "id": "8e4ec834-d09c-4f8c-93ba-bfb924ba9cf3",
      "name": "Redis",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get userflags from the earlier get_userflag_all node\nconst userflag = $('get_userflag_all').first().json.userflag;\n\n// Extract booking data\nconst serviceName = userflag.serviceName || 'Service';\nconst serviceDuration = userflag.serviceDuration || '0';\nconst employeeName = userflag.employeeName || 'Next Available';\nconst dateTimeUTC = userflag.dateTime;\n\n// Parse UTC datetime and convert to Cancun timezone using native JS\nconst utcDate = new Date(dateTimeUTC);\n\n// Format for Cancun timezone\nconst dateFormatted = utcDate.toLocaleDateString('en-US', {\n  weekday: 'long',\n  month: 'long', \n  day: 'numeric',\n  timeZone: 'America/Cancun'\n});\n\nconst timeFormatted = utcDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\n// Handle multiple durations - sum them\nconst totalDuration = serviceDuration.split(',')\n  .map(d => parseInt(d.trim()))\n  .reduce((sum, d) => sum + d, 0);\n\n\n// Calculate end time\nconst endDate = new Date(utcDate.getTime() + (totalDuration * 60 * 1000));\nconst endTimeFormatted = endDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\n// Build the summary message\nconst message = `Perfect! Here's your booking summary:\n\nðŸ“… Date: ${dateFormatted}\nâ° Time: ${timeFormatted} - ${endTimeFormatted} (${totalDuration} min)\nðŸ’… Service: ${serviceName}\nâœ¨ Technician: ${employeeName}\nðŸ“ Location: Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\n\nReply 'confirm' to complete your booking, or let me know if you'd like to change anything!`;\n\nreturn [{\n  json: {\n    message: message\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3088,
        -1456
      ],
      "id": "5aeeda87-178e-4c13-8955-bb0206af8676",
      "name": "Build Birthday Summary"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\"birthday_provided\", \"declined\", \"unclear\", \"modification_request\"]\n    },\n    \"birthday\": {\n      \"type\": \"string\",\n      \"pattern\": \"^[0-1][0-9]-[0-3][0-9]$\",\n      \"description\": \"Birthday in MM-DD format\"\n    }\n  },\n  \"required\": [\"action\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1584,
        -1104
      ],
      "id": "9122624a-8b66-4ac5-874d-1e81bdc66389",
      "name": "Structured Output Parser3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "11092663-5a67-4586-9961-859c0d43c56c",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag?.pendingBirthday }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        288,
        720
      ],
      "id": "83af8ca3-191b-4e3a-9719-994c09bed721",
      "name": "pendingBirthday?"
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "pendingBirthday"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2640,
        -1456
      ],
      "id": "e3d281aa-1843-421b-9c30-d8ca9d77e630",
      "name": "delete_pendingBirthday",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "value": "={{ {readyToBook: \"true\"} }}",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2864,
        -1456
      ],
      "id": "f6b30302-9205-450e-810c-b35996b403b2",
      "name": "set_userflag_readyToBook_birthday",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {readyToBook: \"true\"} }}",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        6688,
        -512
      ],
      "id": "8e818a40-e2ef-414f-8fab-f48ac8de31ea",
      "name": "set_readyToBook_alt",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {pendingBirthday: \"true\"} }}",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        6688,
        -304
      ],
      "id": "83d63f50-5ed7-433d-a816-8318db402667",
      "name": "set_pendingBirthday_alternative",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's Message: {{ $('Set Initial Data').first().json.messageBody }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You classify user responses to a birthday request and output structured JSON.\n\nContext: User was asked \"What's your birthday? Reply 'skip' if you'd prefer not to share.\"\n\nOutput format (JSON only):\n{\n  \"action\": \"birthday_provided\" | \"declined\" | \"unclear\" | \"modification_request\",\n  \"birthday\": \"MM-DD\"\n}\n\nInclude \"birthday\" field ONLY when action is \"birthday_provided\".\n\n---\n\n## 1. BIRTHDAY PROVIDED (action: \"birthday_provided\")\n\nUser shares their birthday. Convert to MM-DD format (two-digit month, hyphen, two-digit day).\n\nRecognize any format: numeric (10/17, 3-5), month names (October 17, Oct 17), reversed (17th of Oct), casual (my bday is jan 1), with year (ignore it).\n\nExamples:\n- \"October 17\" â†’ {\"action\": \"birthday_provided\", \"birthday\": \"10-17\"}\n- \"3/5\" â†’ {\"action\": \"birthday_provided\", \"birthday\": \"03-05\"}\n- \"the 4th of july\" â†’ {\"action\": \"birthday_provided\", \"birthday\": \"07-04\"}\n\nCRITICAL: Always pad with leading zeros. \"3-5\" â†’ \"03-05\"\n\n---\n\n## 2. DECLINED (action: \"declined\")\n\nUser refuses: \"no\", \"skip\", \"pass\", \"no thanks\", \"prefer not\", \"rather not\", \"nah\", \"nope\"\n\n---\n\n## 3. UNCLEAR (action: \"unclear\")\n\nAmbiguous: \"yes\", \"ok\", \"sure\", \"what?\", gibberish, emoji-only, short non-date text\n\n---\n\n## 4. MODIFICATION REQUEST (action: \"modification_request\")\n\nUser wants to change booking: \"change\", \"different\", \"instead\", \"actually\", \"can we do\", \"3pm instead\", \"sarah instead\"\n\n---\n\n## RULES\n- Output ONLY valid JSON\n- Any recognizable date â†’ \"birthday_provided\" with MM-DD format\n- Change/modification intent â†’ \"modification_request\"\n- \"yes\"/\"ok\" without date â†’ \"unclear\"\n- When uncertain â†’ prefer \"unclear\""
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1376,
        -1312
      ],
      "id": "969154a3-d91d-4d8b-9198-20ed06c78758",
      "name": "Birthday Response Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "birthday_provided",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "4f91a5e7-5ded-459d-b766-855381597951"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "birthday_provided"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "752881d4-1126-4f06-86e2-4730a550c0ec",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "declined",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "declined"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "dddb6ac3-658f-4d12-85ea-909f2ff42657",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "=unclear",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "unclear"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e5c52d1d-4d96-4c97-957c-7b7d60280628",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "modification_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "modification_request"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1808,
        -1360
      ],
      "id": "0eb6ce09-a3ba-4143-9c79-7acaee363e7c",
      "name": "Birthday Response Switch"
    },
    {
      "parameters": {
        "jsCode": "// This node prepares data for registration\n// The actual registration happens via the registration_agent tool\n\nconst birthday = $input.first().json.output.birthday;\nconst phoneNumber =  $('Webhook').first().json.body.WaId;\nconst customerName = $('Set Initial Data').first().json.name;\n\n// Pass to registration_agent\nreturn [{\n  json: {\n    action: 'register_customer',\n    phoneNumber: phoneNumber,\n    name: customerName,\n    birthday: birthday\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        -1552
      ],
      "id": "971ed55d-7489-411b-b0d4-b40e4775fd3e",
      "name": "Call Registration Agent"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 735229643,
          "mode": "list",
          "cachedResultName": "Contacts",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=735229643"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Registration Date": "={{ $now.toFormat('yyyy-MM-dd') }}",
            "Contact ID": "={{ $json.phoneNumber }}",
            "Name": "={{ $json.name }}",
            "Birthday": "={{ $json.birthday }}"
          },
          "matchingColumns": [
            "Contact ID"
          ],
          "schema": [
            {
              "id": "Contact ID",
              "displayName": "Contact ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Name",
              "displayName": "Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Birthday",
              "displayName": "Birthday",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Registration Date",
              "displayName": "Registration Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Total Visits",
              "displayName": "Total Visits",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Last Visit",
              "displayName": "Last Visit",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2208,
        -1552
      ],
      "id": "0608ed00-ac1c-4809-ad68-92772a4bbc28",
      "name": "add_contact_direct1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {registeredContact: \"true\"} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2400,
        -1552
      ],
      "id": "0fc255a8-469a-4461-840d-42b41225c7cf",
      "name": "set_registeredContact_direct",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "eacd71f8-071a-4f41-913e-3a33a7249b95",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag?.registeredContact }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6448,
        -400
      ],
      "id": "6741f111-9f63-41ac-b518-841380a88f16",
      "name": "Is User Registered?"
    },
    {
      "parameters": {
        "options": {
          "maxOutputTokens": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1312,
        -1104
      ],
      "id": "78c59908-e1c4-47ec-9f79-1921dfba229e",
      "name": "gemini-intent-router1",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Extract data from ALL messages regardless of profanity, insults, or tone. You are parsing text, not conversing.\n\nUser's Message: {{ $json.enhancedMessage || $('Set Initial Data').first().json.messageBody }}\n\nCurrent date/time: {{ $now.setZone('America/Cancun').toFormat('cccc, MMMM d, yyyy h:mm a') }}",
        "hasOutputParser": true,
        "needsFallback": true,
        "options": {
          "systemMessage": "=## â›” MANDATORY OUTPUT FORMAT - READ FIRST\nYou MUST output ONLY a raw JSON object. Nothing else.\nCORRECT FORMAT:\n{\"service\": {...}, \"datetime\": {...}, \"technician\": {...}}\nFORBIDDEN (will crash the system):\nâŒ {\"action\": \"parse\", \"text\": [...]}\nâŒ {\"action\": \"tool_call\", ...}  \nâŒ ```json ... ```\nâŒ Any text before or after the JSON\nAfter you finish calling tools, immediately output the JSON object.\n---\nData Extractor Agent\nYou are a data extractor agent. \nExtract and validate booking data. Call tools to save valid data. Output JSON of what you extracted THIS TURN only. DO NOT generate user-facing messages .\n## CRITICAL RULES \nScan for ALL THREE fields in every message (service, datetime, technician)\nExtract and validate everything found in one pass\nBuild ONE comprehensive response covering all findings\nValidate before saving any data\nWhen user mentions a date without a year:\n - If the date has ALREADY PASSED this year â†’ use NEXT year \n - If the date is still upcoming this year â†’ use THIS year\nONLY CALL EACH TOOL ONCE PER TURN\nNEVER output Python code, function calls, or print statements. \nNEVER use syntax like: print(...) or default_api.something(...) or any programming constructs.\n Output ONLY the raw JSON object directly with no wrapper.\nProcess ALL messages regardless of profanity, insults, or tone. You are parsing text, not conversing.\n\nBUSINESS RULES\nHours: Monday-Saturday, 9 AM-8 PM EST. NO SUNDAYS.\nTimezone: America/Cancun (EST, UTC-5, no DST)\nToday: {{ $now.toFormat('yyyy-MM-dd') }}\nTomorrow: {{ $now.plus({ days: 1 }).toFormat('yyyy-MM-dd') }}\nCurrent Year: {{ $now.toFormat('yyyy') }} \nNext Year: {{ $now.plus({ years: 1 }).toFormat('yyyy') }}\n\n1. EXTRACTION PROCESS \n1A. SERVICE EXTRACTION\nTrigger: Message mentions service (manicure, pedicure, nails, spa, mani pedi, classic, express, etc)\nSteps:\nCALL list_services\nMatch user input \n(fuzzy matching OK, typos OK, case-insensitive, Common variations: \"mani pedi\" â†’ \"Classic Manicure & Pedicure\")\nSINGLE service match:\nExtract from list_services response: \n serviceID = \"Service ID\" column\n serviceName = \"Service Name\" column  \nserviceDuration = \"Duration (min)\" column\nservicePrice = \"Service Price\" column\nallowedEmployees = \"Allowed Employees\" column values joined with | (pipe) separator. Example: \"ALL|EMP005\")\nOutput: \n```json \"service\": { \"validated\": true, \"values\": { \"serviceID\": \"...\", \"serviceName\": \"...\", \"serviceDuration\": \"...\", \"servicePrice\": \"...\", \"allowedEmployees\": \"...\"}} ```\nMULTIPLE services:\nUser is looking to book multiple services\nExtract ALL from list_services (comma-separated, DO NOT sum):\nserviceID = \"Service ID\" column values joined\nserviceName = \"Service Name\" column values joined\nserviceDuration = \"Duration (min)\" column values joined\nservicePrice = \"Service Price\" column values joined\nallowedEmployees = \"Allowed Employees\"\nOutput:\n```json\n\"service\": { \"validated\": true, \"multiple\": true, \"values\": { \"serviceID\": \"SVC001,SVC002\", \"serviceName\": \"...\", \"serviceDuration\": \"...\", \"servicePrice\": \"...\", \"allowedEmployees\": \"...\" } }\n```\nAMBIGUOUS match (single user input matches multiple services - e.g., \"manicure\" appears in all service names ):\nDo NOT auto-select one\nOutput: ```json \"service\": { \"validated\": false, \"error\": \"ambiguous\", \"rawInput\": \"what user typed\", \"possibleMatches\": [\"Full Service Name 1 ($price)\", \"Full Service Name 2 ($price)\"] } ```\nâš ï¸ If user mentions MULTIPLE services and only SOME are ambiguous: - Set validated: true (because we have at least one valid service) \nPut the valid service(s) in values \nAdd ambiguousService field with the unclear input \nAdd possibleMatches array with the matching service names \nExample: \nUser says \"manicure clasico y dermapen\" \n \"dermapen\" matches exactly â†’ put in values \n\"manicure clasico\" matches 2 services â†’ ambiguous \nOutput: ```json \"service\": { \"validated\": true, \"values\": { \"serviceID\": \"53\", \"serviceName\": \"Dermapen\", \"serviceDuration\": \"35\", \"servicePrice\": \"1300\", \"allowedEmployees\": \"ALL|EMP005\" }, \"ambiguousService\": \"manicure clasico\", \"possibleMatches\": [\"Manicure clasico con gel ($440)\", \"Manicure clasico con esmalte ($340)\"] } ```\nNO match:\nOutput:\n```json\n\"service\": { \"validated\": false, \"error\": \"no_match\", \"rawInput\": \"what user typed\" }\n```\n\n\n1B. DATETIME EXTRACTION\nTRIGGER: Message mentions date/time (\"tomorrow\", \"2pm\", \"Monday at 3\", etc.)\nRELATIVE DATE RESOLUTION\nIf input contains relative terms, resolve to actual date FIRST.\nToday: {{ $now.toFormat('yyyy-MM-dd') }} ({{ $now.toFormat('EEEE') }})\n\nRelative terms:\n- \"tomorrow\" â†’ today + 1 day\n- \"after tomorrow\" / \"day after tomorrow\" â†’ today + 2 days\n- \"in X days\" â†’ today + X days\n- \"in X weeks\" â†’ today + (X * 7) days\n\nWeek-based terms (week = Monday through Sunday):\n- \"this [weekday]\" â†’ that weekday within the CURRENT week (Mon-Sun)\n- \"next [weekday]\" â†’ that weekday in the FOLLOWING week (Mon-Sun)\n- \"[weekday]\" alone (no qualifier) â†’ the nearest UPCOMING occurrence\n**DATE RESOLUTION RULE (applies to ALL paths below):**\nAlways resolve to the NEXT occurrence FIRST, then validate:\n1. Relative terms â†’ calculate actual date\n2. Month/day without year (e.g., \"January 5th\") â†’ if passed this year, use next year\n3. Today: {{ $now.toFormat('yyyy-MM-dd') }}\n\nâš ï¸ ALL validation (including Sunday check) applies ONLY to the resolved date.\nNever check day-of-week against past dates.\n\nExample: \"January 5th\" on Dec 28, 2025:\n- Jan 5, 2025 already passed â†’ resolve to 2026-01-05\n- Is 2026-01-05 a Sunday? No, it's Monday â†’ valid âœ…\nâš¡ ROUTE SELECTION â€” First match wins, ignore the rest.\nPATH 1B.1 -  COMPLETE DATE & TIME\n**When:** BOTH date AND time present (\"tomorrow at 2pm\", \"Monday 10am\") \nVALIDATE:\nDate: Mon-Sat, \nTime: 9 AM - 8 PM \nIf VALID:\nConvert to UTC ISO (CancÃºn = UTC-5)\nOutput:\n```json \"datetime\": { \"validated\": true, \"type\": \"complete\", \"savedDatetime\": \"2025-01-15T19:00:00Z\" } \n```\nIf INVALID (Non-working day/ Outside Hours):\nOutput:\n```json\n\"datetime\": { \"validated\": false, \"error\": \"sunday\" | \"outside_hours\", \"rawInput\": \"...\" }\n```\n\nPATH 1B.2 - ONLY DATE\n**When:** Date only (\"tomorrow\", \"Monday\", \"December 20th\")\nVALIDATE:\nDate: Monday-Saturday\nIf VALID:\nResolve to YYYY-MM-DD format (CancÃºn timezone)\nOutput: \n```json \"datetime\": { \"validated\": true, \"type\": \"partial_date\", \"partialDate\": \"2025-01-15\" } \n```\nIf INVALID (Sunday):\nOutput: \n```json \n\"datetime\": { \"validated\": false, \"error\": \"sunday\", \"rawInput\": \"Sunday\" } \n```\n\nPATH 1B.3 - ONLY TIME\n**When:** Time only (\"2pm\", \"10:30 AM\") \nVALIDATE:\nTime: 9 AM - 8 PM\nIf VALID:\nExtract and normalize time\nOutput: \n```json \"datetime\": { \"validated\": true, \"type\": \"partial_time\", \"partialTime\": \"14:00\" } \n```\nIf INVALID (Outside hours):\nOutput: ```json \"datetime\": { \"validated\": false, \"error\": \"outside_hours\", \"rawInput\": \"11pm\" } ```\n\n1C. TECHNICIAN EXTRACTION\nTrigger: Message mentions name OR \"no preference\"/\"anyone\"/\"next available\", etc\n**CASE 1: SPECIFIC NAME MENTIONED** \nExecute these steps IN ORDER - DO NOT SKIP ANY STEP: \nCALL employee_list â† MANDATORY\nLook at the employee_list response for a match to the user's requested name \nMatch strategies: exact match, first name only, last name only, partial (case-insensitive) \nIf Match found: \nOutput: \n```json \"technician\": { \"validated\": true, \"type\": \"specific\", \"values\": { \"employeeID\": \"EMP001\", \"employeeName\": \"Sarah Johnson\" } } \n```\nIf Match not found: \nOutput: \n```json \"technician\": { \"validated\": false, \"error\": \"not_found\", \"rawInput\": \"Bob\" } \n```\nIf AMBIGUOUS (input could match multiple employees - e.g., \"Sarah\" when you have \"Sarah Johnson\" and \"Sarah Smith\")\nDo NOT auto-select one\nOutput: \n```json \n\"technician\": { \"validated\": false, \"error\": \"ambiguous\", \"rawInput\": \"Sarah\" } \n```\n\"No Preference\":\nOutput: \n```json \"technician\": { \"validated\": true, \"type\": \"next_available\", \"values\": { \"employeeID\": \"NEXT_AVAILABLE\", \"employeeName\": \"Next Available\" } } ```\n\n\n2. JSON OUTPUT\n\nOutput ONLY fields you extracted THIS TURN. Omit fields not mentioned in user message.\n\n```json\n{\n  \"service\": {\n    \"validated\": true/false,\n    \"error\": null | \"no_match\" | \"ambiguous\",\n    \"rawInput\": \"user text\",\n    \"multiple\": true/false,\n    \"values\": { \"serviceID\": \"\", \"serviceName\": \"\", \"serviceDuration\": \"\", \"servicePrice\": \"\", \"allowedEmployees\": \"\" }\n  },\n  \"datetime\": {\n    \"validated\": true/false,\n    \"error\": null | \"sunday\" | \"outside_hours\",\n    \"type\": \"complete\" | \"partial_date\" | \"partial_time\",\n    \"rawInput\": \"user text\",\n    \"savedDatetime\": \"UTC ISO\",\n    \"partialDate\": \"YYYY-MM-DD\",\n    \"partialTime\": \"HH:MM\"\n  },\n  \"technician\": {\n    \"validated\": true/false,\n    \"error\": null | \"not_found\" | \"ambiguous\",\n    \"type\": \"specific\" | \"next_available\",\n    \"rawInput\": \"user text\",\n    \"values\": { \"employeeID\": \"\", \"employeeName\": \"\" }\n  }\n}\n```\n\n- Include \"values\" ONLY when validated: true\n- Include \"error\" and \"rawInput\" when validated: false\n\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        7216,
        288
      ],
      "id": "a4284e56-40b3-41d8-97f3-e8b9d929440a",
      "name": "Extractor Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"service\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"error\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"multiple\": { \"type\": \"boolean\" },\n        \"ambiguousService\": { \"type\": \"string\" },\n        \"possibleMatches\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n        \"values\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"serviceID\": { \"type\": \"string\" },\n            \"serviceName\": { \"type\": \"string\" },\n            \"serviceDuration\": { \"type\": \"string\" },\n            \"servicePrice\": { \"type\": \"string\" },\n            \"allowedEmployees\": { \"type\": \"string\" }\n          }\n        }\n      }\n    },\n    \"datetime\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"error\": { \"type\": \"string\" },\n        \"type\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"savedDatetime\": { \"type\": \"string\" },\n        \"partialDate\": { \"type\": \"string\" },\n        \"partialTime\": { \"type\": \"string\" }\n      }\n    },\n    \"technician\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"error\": { \"type\": \"string\" },\n        \"type\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"values\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"employeeID\": { \"type\": \"string\" },\n            \"employeeName\": { \"type\": \"string\" }\n          }\n        }\n      }\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        7664,
        560
      ],
      "id": "9432373a-f3f4-4ecc-892c-7aaf3bd6185d",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "jsCode": "let extraction = {};\ntry {\n  extraction = $('Extractor Agent').first().json.output || {};\n} catch (e) {\n  // Redirect path (e.g., from mixed response) - no extraction needed\n  // All data is already in Redis\n}\n\n\n// Detect mixed choice redirect â€” use corrected service data instead of stale Redis\nlet mixedChoiceRedirect = false;\ntry {\n  const redirectData = $('Redirect After Mixed Choice').first().json;\n  if (redirectData && redirectData.fromMixedChoice) {\n    mixedChoiceRedirect = true;\n  }\n} catch (e) {}\n\n\nlet redis = $('get_userflag_all').first().json.userflag || {};\n\n// If coming from mixed choice redirect, override stale service data\nif (mixedChoiceRedirect) {\n  const rd = $('Redirect After Mixed Choice').first().json;\n  redis.serviceID = rd.serviceID;\n  redis.serviceName = rd.serviceName;\n  redis.serviceDuration = rd.serviceDuration;\n  redis.servicePrice = rd.servicePrice;\n  redis.allowedEmployees = rd.allowedEmployees;\n  redis.employeeID = rd.employeeID;\n  redis.employeeName = rd.employeeName;\n}\n\n\n// Check if we came from reroute path (datetime was cleared)\nlet dateTimeWasCleared = false;\ntry {\n  $('delete pendingAlternatives2').first();\n  dateTimeWasCleared = true;\n} catch (e) {\n  // Node wasn't executed, normal path\n}\n\n// If reroute path cleared datetime, null it out from cached data\nif (dateTimeWasCleared) {\n   redis.availabilityConfirmed = null;\n  // Keep datetime intact - let extraction logic handle partial modifications\n}\n\n// Check if we came from other_technician path (tech changed to NEXT_AVAILABLE)\nlet technicianSetToNextAvailable = false;\ntry {\n  $('Set NEXT_AVAILABLE Tech').first();\n  technicianSetToNextAvailable = true;\n} catch (e) {}\n\nif (technicianSetToNextAvailable) {\n  redis.employeeID = 'NEXT_AVAILABLE';\n  redis.employeeName = 'Next Available';\n}\n\n// Check if we came from full reset path (\"start over\")\nlet fullResetPerformed = false;\ntry {\n  $('delete_for_full_reset').first();\n  fullResetPerformed = true;\n} catch (e) {}\n\nif (fullResetPerformed) {\n  redis.serviceID = null;\n  redis.serviceName = null;\n  redis.serviceDuration = null;\n  redis.servicePrice = null;\n  redis.dateTime = null;\n  redis.partialDate = null;\n  redis.partialTime = null;\n  redis.employeeID = null;\n  redis.employeeName = null;\n}\n\nconst userPhone = $('Set Initial Data').first().json.userPhoneNumber;\n\nconst hasValue = (v) => v && v !== 'NOT SET' && v !== '' && v !== null && v !== undefined;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 1: Did Extractor find anything?\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst extractedService = extraction.service !== undefined;\nconst extractedDatetime = extraction.datetime !== undefined;\nconst extractedTechnician = extraction.technician !== undefined;\nconst extractedSomething = extractedService || extractedDatetime || extractedTechnician;\n\n\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 3: Detect modification mode\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst isModification = redis.readyToBook === 'true' && extractedSomething;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 4: Build Redis updates from validated extractions\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst redisUpdates = {};\n\n// If modification, clear confirmation flags\nif (isModification) {\n  redisUpdates.readyToBook = 'false';\n  redisUpdates.availabilityConfirmed = 'false';\n}\n\n// SERVICE\n// Save service if validated OR if values exist (partial extraction with ambiguous)\nif (extraction.service?.validated === true || extraction.service?.values?.serviceID) {\n  redisUpdates.serviceID = extraction.service.values.serviceID;\n  redisUpdates.serviceName = extraction.service.values.serviceName;\n  redisUpdates.serviceDuration = extraction.service.values.serviceDuration;\n  redisUpdates.servicePrice = extraction.service.values.servicePrice;\n  redisUpdates.allowedEmployees = extraction.service.values.allowedEmployees;\n}\n\n// Save ambiguous service info for next turn clarification\nif (extraction.service?.error === 'ambiguous' && extraction.service?.rawInput) {\n  redisUpdates.ambiguousService = extraction.service.rawInput;\n} else if (extraction.service?.ambiguousService) {\n  // Partial success - valid service + ambiguous one\n  redisUpdates.ambiguousService = extraction.service.ambiguousService;\n} else if (extraction.service?.validated === true && !extraction.service?.ambiguousService) {\n  // Clear ambiguous only if fully resolved\n  redisUpdates.ambiguousService = '';\n}\n\n// TECHNICIAN\nif (extraction.technician?.validated === true) {\n  redisUpdates.employeeID = extraction.technician.values.employeeID;\n  redisUpdates.employeeName = extraction.technician.values.employeeName;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 5: Handle datetime extraction\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nlet finalDateTime = redis.dateTime;\nlet finalPartialDate = redis.partialDate;\nlet finalPartialTime = redis.partialTime;\n\nif (extraction.datetime?.validated === true) {\n  \n  if (extraction.datetime.type === 'complete') {\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // COMPLETE DATETIME: Use directly, clear any partials\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    finalDateTime = extraction.datetime.savedDatetime;\n    finalPartialDate = '';\n    finalPartialTime = '';\n    \n  } else if (extraction.datetime.type === 'partial_time') {\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // PARTIAL TIME: \"3pm\", \"11 am\", etc.\n    // Priority: 1) Modify existing datetime, 2) Combine with partial date, 3) Store as partial\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    const newTime = extraction.datetime.partialTime;\n    \n    if (hasValue(finalDateTime)) {\n      // Have complete datetime â†’ modify time, keep date\n      // Example: \"Monday 4pm\" + \"3pm\" = \"Monday 3pm\"\n      const existingUtc = new Date(finalDateTime);\n      const existingLocal = new Date(existingUtc.getTime() - (5 * 60 * 60 * 1000));\n      const existingDateStr = existingLocal.toISOString().split('T')[0];\n      \n      const localMs = new Date(`${existingDateStr}T${newTime}:00`).getTime();\n      finalDateTime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n      finalPartialDate = '';\n      finalPartialTime = '';\n      \n    } else if (hasValue(finalPartialDate)) {\n      // Have partial date â†’ combine into complete datetime\n      // Example: \"tomorrow\" + \"3pm\" = complete datetime\n      const localMs = new Date(`${finalPartialDate}T${newTime}:00`).getTime();\n      finalDateTime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n      finalPartialDate = '';\n      finalPartialTime = '';\n      \n    } else {\n      // No date info yet â†’ store as partial time\n      finalPartialTime = newTime;\n    }\n    \n  } else if (extraction.datetime.type === 'partial_date') {\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // PARTIAL DATE: \"tomorrow\", \"Monday\", \"Dec 27\", etc.\n    // Priority: 1) Modify existing datetime, 2) Combine with partial time, 3) Store as partial\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    const newDate = extraction.datetime.partialDate;\n    \n    if (hasValue(finalDateTime)) {\n      // Have complete datetime â†’ modify date, keep time\n      // Example: \"Monday 4pm\" + \"Tuesday\" = \"Tuesday 4pm\"\n      const existingUtc = new Date(finalDateTime);\n      const existingLocal = new Date(existingUtc.getTime() - (5 * 60 * 60 * 1000));\n      const existingHour = String(existingLocal.getHours()).padStart(2, '0');\n      const existingMinute = String(existingLocal.getMinutes()).padStart(2, '0');\n      const existingTimeStr = `${existingHour}:${existingMinute}`;\n      \n      const localMs = new Date(`${newDate}T${existingTimeStr}:00`).getTime();\n      finalDateTime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n      finalPartialDate = '';\n      finalPartialTime = '';\n      \n    } else if (hasValue(finalPartialTime)) {\n      // Have partial time â†’ combine into complete datetime\n      // Example: \"3pm\" + \"tomorrow\" = complete datetime\n      const localMs = new Date(`${newDate}T${finalPartialTime}:00`).getTime();\n      finalDateTime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n      finalPartialDate = '';\n      finalPartialTime = '';\n      \n    } else {\n      // No time info yet â†’ store as partial date\n      finalPartialDate = newDate;\n    }\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 6: Safety net - combine any remaining partials\n// (Should rarely trigger after STEP 5 improvements)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nif (hasValue(finalPartialDate) && \n    hasValue(finalPartialTime) && \n    !hasValue(finalDateTime)) {\n  \n  const localMs = new Date(`${finalPartialDate}T${finalPartialTime}:00`).getTime();\n  finalDateTime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n  finalPartialDate = '';\n  finalPartialTime = '';\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 7: Add datetime fields to Redis updates if changed\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nif (finalDateTime !== redis.dateTime && hasValue(finalDateTime)) {\n  redisUpdates.dateTime = finalDateTime;\n}\n\n// Save partialDate if changed\nif (finalPartialDate !== redis.partialDate) {\n  redisUpdates.partialDate = finalPartialDate || '';\n}\n\n// Save partialTime if changed\nif (finalPartialTime !== redis.partialTime) {\n  redisUpdates.partialTime = finalPartialTime || '';\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 8: Build merged state for downstream nodes\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst merged = {\n  serviceID: redisUpdates.serviceID ?? redis.serviceID,\n  serviceName: redisUpdates.serviceName ?? redis.serviceName,\n  serviceDuration: redisUpdates.serviceDuration ?? redis.serviceDuration,\n  servicePrice: redisUpdates.servicePrice ?? redis.servicePrice,\n  allowedEmployees: redisUpdates.allowedEmployees ?? redis.allowedEmployees,\n  dateTime: finalDateTime,\n  partialDate: finalPartialDate,\n  partialTime: finalPartialTime,\n  employeeID: redisUpdates.employeeID ?? redis.employeeID,\n  employeeName: redisUpdates.employeeName ?? redis.employeeName,\n  registeredContact: redis.registeredContact,\n};\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 9: Calculate readiness\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst hasService = hasValue(merged.serviceID);\nconst hasCompleteDatetime = hasValue(merged.dateTime);\nconst hasTechnician = hasValue(merged.employeeName);\nconst isReady = hasService && hasCompleteDatetime && hasTechnician;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 10: Collect validation errors\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst validationErrors = [];\nif (extraction.service?.validated === false) {\n  validationErrors.push({ \n    field: 'service', \n    error: extraction.service.error, \n    rawInput: extraction.service.rawInput,\n    possibleMatches: extraction.service.possibleMatches || []\n  });\n} else if (extraction.service?.ambiguousService) {\n  // Partial success - we have a valid service but also an ambiguous one\n  validationErrors.push({ \n    field: 'service', \n    error: 'ambiguous',\n    rawInput: extraction.service.ambiguousService,\n    possibleMatches: extraction.service.possibleMatches || []\n  });\n}\nif (extraction.datetime?.validated === false) {\n  validationErrors.push({ \n    field: 'datetime', \n    error: extraction.datetime.error, \n    rawInput: extraction.datetime.rawInput \n  });\n}\nif (extraction.technician?.validated === false) {\n  validationErrors.push({ \n    field: 'technician', \n    error: extraction.technician.error, \n    rawInput: extraction.technician.rawInput \n  });\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 11: Calculate missing fields\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst missing = [];\nif (!hasService) missing.push('service');\nif (!hasCompleteDatetime) {\n  if (hasValue(merged.partialDate) && !hasValue(merged.partialTime)) missing.push('time');\n  else if (hasValue(merged.partialTime) && !hasValue(merged.partialDate)) missing.push('date');\n  else missing.push('datetime');\n}\nif (!hasTechnician) missing.push('technician');\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// STEP 12: Determine route\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst route = isReady ? 'READY' : 'NEEDS_MORE_DATA';\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// OUTPUT\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nreturn [{\n  json: {\n    route,\n    isReady,\n    isModification,\n    missing,\n    validationErrors,\n    hasErrors: validationErrors.length > 0,\n    merged,\n    redisUpdates,  // Object ready for Redis HSET\n    have: {\n      service: hasService ? merged.serviceName : null,\n      datetime: hasCompleteDatetime ? merged.dateTime : null,\n      technician: hasTechnician ? merged.employeeName : null,\n      partialDate: hasValue(merged.partialDate) ? merged.partialDate : null,\n      partialTime: hasValue(merged.partialTime) ? merged.partialTime : null,\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8256,
        32
      ],
      "id": "65977dc8-8cb3-46b5-bfe1-1c0247f38caf",
      "name": "State Merger & Router"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ $json.redisUpdates }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        8512,
        32
      ],
      "id": "b7ee58e9-42db-4e5b-9171-0fd3cf5e5cf9",
      "name": "Redis State Update",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$('State Merger & Router').first().json.route }}",
                    "rightValue": "NEEDS_MORE_DATA",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e7ea86e0-d6aa-4c17-9ad9-7dbdae5320cf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NEEDS_MORE_DATA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ebfe910a-c1ec-4b88-a8f1-b0cdf49e901a",
                    "leftValue": "={{$('State Merger & Router').first().json.route }}",
                    "rightValue": "READY",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "READY"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        10320,
        64
      ],
      "id": "3356d0fc-8ab5-4dea-b6a1-f662bfa526b8",
      "name": "Route Switch"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "8fb7b205-fc4d-420b-9f1d-1eaf7ae1ca42",
              "leftValue": "={{ $json.output.result.available }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        11456,
        384
      ],
      "id": "76ff667f-34d3-42f4-880d-79b76871340f",
      "name": "Available?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "45224de3-4745-4eee-a34a-6e67c21910de",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag?.registeredContact }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        12320,
        144
      ],
      "id": "c40ee080-ff35-40e7-8358-124c35c1708f",
      "name": "Registered?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current User: {{ $('Set Initial Data').first().json.name }}\n\nCurrent Booking State:\n- serviceName: {{ $json.merged.serviceName || 'NOT SET' }}\n- serviceDuration: {{ $json.merged.serviceDuration || 'NOT SET' }}\n- servicePrice: {{ $json.merged.servicePrice || 'NOT SET' }}\n- dateTime: {{ $json.merged.dateTime ? new Date($json.merged.dateTime).toLocaleString('en-US', { weekday: 'long', month: 'long', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun' }) : 'NOT SET' }}\n- partialDate: {{ $json.merged.partialDate ? new Date($json.merged.partialDate + 'T12:00:00').toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : 'NOT SET' }}\n- partialTime: {{ $json.merged.partialTime ? new Date('2000-01-01T' + $json.merged.partialTime).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }) : 'NOT SET' }}\n- employeeName: {{ $json.merged.employeeName || 'NOT SET' }}\n\nUser's Message: {{ $('Set Initial Data').first().json.messageBody }}",
        "options": {
          "systemMessage": "=## Response Agent\nYou help users complete their booking by confirming what we have and asking for what's missing.\n\n## INPUT CONTEXT\nMissing fields: {{ $json.stateData.missing }}\nValidation errors: {{ JSON.stringify($json.stateData.validationErrors) }}\nIs modification: {{ $json.stateData.isModification }}\n\n## BUSINESS RULES\nHours: Monday-Saturday, 9 AM-8 PM. NO SUNDAYS.\n\n## RESPONSE STRUCTURE\n\n### PART A: VALIDATION ERRORS (if any)\nAddress errors FIRST, before anything else:\n\n| Error | Response |\n\n| datetime + sunday | \"Estamos cerrados los domingos. Abrimos de lunes a sÃ¡bado, 9 AM a 8 PM.\" |\n| datetime + outside_hours | \"Nuestro horario es de 9 AM a 8 PM.\" |\n| service + no_match | \"No encontrÃ© ese servicio. Tenemos manicure, pedicure, gel, rubber, polygel, uÃ±as esculturales, faciales, depilaciÃ³n y mÃ¡s. Â¿CuÃ¡l te interesa?\" | \n| technician + not_found | \"No encuentro a [rawInput]. Nuestro equipo es: Jenny, Lucero, Ediadne, Pamela. Â¿Con quiÃ©n prefieres?\" |\n| service + ambiguous | Use the possibleMatches array from validationErrors. Say: \"Para '[rawInput]', tenemos: [list each possibleMatch]. Â¿CuÃ¡l prefieres?\" |\n\n\n| technician + ambiguous | \"Tenemos varias personas con ese nombre. Â¿CuÃ¡l preferÃ­as?\" |\n\n\n### PART B: CONFIRM WHAT WE HAVE\nSummarize confirmed booking details naturally. Use the values from \"Current Booking State\" EXACTLY as shown.\n\n**Patterns (vary your phrasing):**\n- \"So far I have you down for [details].\"\n- \"Perfect, [details]!\"\n- \"Great, [details]!\"\n- \"[Service] on [date/time] with [technician] - got it!\"\n\nOnly include fields that are NOT \"NOT SET\". Examples:\n- Have serviceName + dateTime â†’ \"Te tengo agendada para [serviceName] el [dateTime].\"\n- Have dateTime only â†’ \"Perfecto, [dateTime]!\"\n- Have serviceName + partialDate â†’ \"Muy bien, [serviceName] el [partialDate]!\"\n- Have partialTime only â†’ \"Listo, a las [partialTime]!\"\n- Have serviceName + employeeName â†’ \"Te tengo para [serviceName] con [employeeName].\"\n\n\nIf serviceName is NOT SET but we have datetime info, do NOT confirm anything - just address the error and ask for missing info.\n\nâš ï¸ CRITICAL: ONLY mention services that appear in serviceName. If user mentioned a service but it's in validationErrors (ambiguous/no_match), do NOT confirm it - address the error instead.\n\n### PART C: ASK FOR MISSING INFO\nEach missing field = separate sentence with its own question mark.\n| Missing | Ask |\n| service | \"Â¿QuÃ© servicio te gustarÃ­a?\" |\n| datetime | \"Â¿CuÃ¡ndo quieres venir?\" |\n| date | \"Â¿QuÃ© dÃ­a te funciona?\" |\n| time | \"Â¿A quÃ© hora te funciona?\" |\n| technician | \"Â¿Tienes preferencia de tÃ©cnico?\" |\n\n\nExamples:\n- Missing service + datetime + technician â†’ \"Â¿QuÃ© servicio te gustarÃ­a? Â¿CuÃ¡ndo quieres venir? Â¿Tienes preferencia de tÃ©cnico?\"\n\n\n## FORMAT RULES\n- serviceName may contain multiple comma-separated services (this is valid, not an error)\n- Use the booking state values EXACTLY as provided - they are already formatted\n- Times shown as \"3:00 PM\" can be simplified to \"3 PM\" if :00\n- Be concise and friendly\n- NEVER say \"or whoever's available first\"\n- NEVER mention: Redis, flags, UTC, validation, technical terms\n\n## RESPONSE FORMAT\nStructure your response with line breaks:\n\n[Part A - Validation error if any]\n\n[Part B - Confirmation of what we have]\n\n[Part C - Question for missing info]\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        10928,
        -464
      ],
      "id": "6c329abe-1c90-471c-b8aa-7230e06fffb2",
      "name": "Response Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=action: {{ $json.merged.employeeID === 'NEXT_AVAILABLE' ? 'check_any_available' : 'check_specific_employee' }}\nemployeeID: {{ $json.merged.employeeID }}\nemployeeName: {{ $json.merged.employeeName }}\ndatetime: {{ $json.merged.dateTime }}\nduration: {{ $json.merged.serviceDuration }}\ndate: {{ $json.merged.dateTime ? $json.merged.dateTime.substring(0,10) : '' }}\nallowedEmployees: {{ $json.merged.allowedEmployees }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "## Availability Agent\n\nCheck if requested time slot is available.\n\n## INPUT\n- action: \"check_specific_employee\" | \"check_any_available\"\n- employeeID: Employee ID or \"\" \n- employeeName: Employee name or \"\"\n- datetime: UTC ISO (e.g., \"2025-11-24T14:00:00Z\")\n- duration: Minutes (e.g., 30, 45, 90)\n- date: YYYY-MM-DD\n-  allowedEmployees: \"ALL\" or Employee IDs. May be pipe-separated per-service (e.g., \"ALL|EMP005\"). Flatten by splitting on | first, then comma. Remove \"ALL\" entries and duplicates. If all entries are \"ALL\", treat as \"ALL\". Example: \"ALL|EMP005\" â†’ filter to only EMP005.\n\n## TOOLS\n1. get_employee_availability: Gets employee schedule for a date\n2. process_availability_check: Checks if time slot fits working hours and avoids blocked times\n\n## WORKFLOW\n\n### check_specific_employee\n\n1. CALL get_employee_availability(date)\n2. Find row where Employee ID == employeeID\n3. CALL process_availability_check with:\n   - datetime, duration (from input)\n   - workingHours, blockedTimes (from matched row)\n   - employeeID, employeeName (from matched row)\n\n4. IF workingHours == \"OFF\" OR available == false:\n   RETURN: {\"available\": false, \"reason\": \"specific_employee_unavailable\", \"employeeID\": \"[ID]\", \"employeeName\": \"[name]\"}\n\n5. IF available == true:\n   RETURN: {\"available\": true, \"employeeID\": \"[ID]\", \"employeeName\": \"[name]\"}\n\n### check_any_available\n\n1. CALL get_employee_availability(date)\n2. FILTER: If allowedEmployees != \"ALL\", only consider employees whose Employee ID is in the allowedEmployees list\n3. For each FILTERED employee where workingHours != \"OFF\":\n   CALL process_availability_check with employee's data\n   \n   IF available == true:\n     RETURN IMMEDIATELY: {\"available\": true, \"employeeID\": \"[ID]\", \"employeeName\": \"[name]\"}\n\n3. If no employee available:\n   RETURN: {\"available\": false, \"reason\": \"no_employees_available\"}\n\n## RULES - CRITICAL\n1. You MUST call process_availability_check for EVERY employee - this is NON-NEGOTIABLE\n2. You CANNOT determine availability without calling the tool - the tool has logic you don't have\n3. NEVER return \"no_employees_available\" unless you have called process_availability_check for EVERY employee and ALL returned available: false\n4. If you return a result without calling process_availability_check, the system will crash\n\n## FORBIDDEN BEHAVIORS\n- DO NOT calculate availability yourself based on working hours\n- DO NOT assume an employee is unavailable without calling the tool\n- DO NOT skip the tool call for any reason\n\n## WORKFLOW (MANDATORY)\n1. CALL get_employee_availability(date) \n2. For EACH employee row returned:\n   â†’ CALL process_availability_check with that employee's data\n   â†’ If result.available === true â†’ RETURN immediately with that employee\n3. ONLY after checking ALL employees with the tool â†’ return no_employees_available\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        10928,
        400
      ],
      "id": "efba4e10-eb39-4e34-b74d-5f8c7b049f9b",
      "name": "Availability Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        10816,
        624
      ],
      "id": "fbd51b3d-9983-42fc-a333-c1a8b6b830c2",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "50f1b870-c12f-482b-8b90-57f632aca33d",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag?.readyToBook }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4624,
        272
      ],
      "id": "9d683acb-2769-44a0-a1dd-0d58073bf1db",
      "name": "readyToBook?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's Message: {{ $('Set Initial Data').first().json.messageBody }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "## Modification Handler Agent\n\nUser has a pending booking. Determine if they're asking to CHANGE it.\n\n## USER MESSAGE\n{{ $('WhatsApp Trigger').first().json.messages[0].text.body }}\n\n## KEY DISTINCTION\n\nMODIFICATION = User explicitly wants to CHANGE their booking\nNOT MODIFICATION = Questions, confirmations, general chat (even if they mention services/times/names)\n\n## EXAMPLES\n\n**IS a modification (intent to change):**\n- \"change to 3pm\" \n- \"make it Tuesday instead\"\n- \"I want deluxe instead\"\n- \"switch to Sarah\"\n- \"actually, can we do 2pm?\"\n- \"let's change the service\"\n- \"different time please\"\n- \"start over\"\n\n**NOT a modification (just asking/chatting):**\n- \"how much is deluxe?\"\n- \"what time does Sarah work?\"\n- \"is 3pm available?\"\n- \"sounds good\"\n- \"ok\"\n- \"tell me about your services\"\n- \"are you open Tuesday?\"\n- \"where are you located?\"\n\n## CLASSIFY\n\n| Intent | User is... |\n|--------|------------|\n| MODIFY_SERVICE | asking to CHANGE to a different service |\n| MODIFY_DATETIME | asking to CHANGE to a different date/time |\n| MODIFY_TECHNICIAN | asking to CHANGE to a different technician |\n| MODIFY_ALL | asking to CHANGE multiple things OR start over |\n| NOT_MODIFYING | asking questions, confirming, chatting - NOT requesting a change |\n\n**Change indicators:** \"change\", \"instead\", \"actually\", \"make it\", \"switch\", \"different\", \"let's do\", \"can we do\", \"I want X instead\", \"start over\"\n\n## OUTPUT\n```json\n{\"intent\": \"MODIFY_SERVICE\" | \"MODIFY_DATETIME\" | \"MODIFY_TECHNICIAN\" | \"MODIFY_ALL\" | \"NOT_MODIFYING\"}\n```\n\n## RULES\n- Questions about services/times/technicians are NOT_MODIFYING\n- Must have clear INTENT TO CHANGE to be a modification\n- When in doubt, NOT_MODIFYING\n- JSON only"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        5040,
        592
      ],
      "id": "6c5bf0c4-3510-425a-b0cf-2b14b92bfeae",
      "name": "Modification Handler Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {pendingAlternatives: $json.pendingAlternatives} }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        12528,
        512
      ],
      "id": "0724980e-66c3-4d64-826a-70a0f4f6158c",
      "name": "set_userflag_pendingAlternatives",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        5008,
        784
      ],
      "id": "ce8da259-8891-43e3-82da-6ec06e450c2f",
      "name": "Google Gemini Chat Model2",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.intent }}",
                    "rightValue": "MODIFY_SERVICE",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "78657071-831a-4c4f-beba-5c70215b45b0"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MODIFY_SERVICE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "27cf119c-034e-4b99-96b4-39b9dfc510bf",
                    "leftValue": "={{ $json.output.intent }}",
                    "rightValue": "MODIFY_DATETIME",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MODIFY_DATETIME"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "5e8e6554-c6f4-4822-a1e0-2739fd5b8c7a",
                    "leftValue": "={{ $json.output.intent }}",
                    "rightValue": "MODIFY_TECHNICIAN",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MODIFY_TECHNICIAN"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "663fd21f-d43e-44d8-9411-246797ac2a83",
                    "leftValue": "={{ $json.output.intent }}",
                    "rightValue": "MODIFY_ALL",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MODIFY_ALL"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "813a67c9-e708-4ad9-86f9-ca5c465f8bbc",
                    "leftValue": "={{ $json.output.intent }}",
                    "rightValue": "NOT_MODIFYING",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NOT_MODIFYING"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        5504,
        528
      ],
      "id": "534235ab-1975-452b-9576-f6bf06e80f8f",
      "name": "Switch1"
    },
    {
      "parameters": {
        "jsCode": "// Get data from State Merger & Router or fallback sources\nlet stateData;\ntry {\n  stateData = $('State Merger & Router').first().json.merged;\n} catch (e) {\n  try {\n    stateData = $('Prep Availability From Unqualified').first().json.merged;\n  } catch (e2) {\n    // Fallback to userflag from Redis\n    const userflag = $('get_userflag_all').first().json.userflag || {};\n    stateData = {\n      employeeID: userflag.employeeID,\n      employeeName: userflag.employeeName,\n      dateTime: userflag.dateTime,\n      serviceDuration: userflag.serviceDuration,\n      serviceID: userflag.serviceID,\n      serviceName: userflag.serviceName,\n      servicePrice: userflag.servicePrice\n    };\n  }\n}\n\n// Extract booking data\nconst serviceNameRaw = stateData.serviceName || 'Service';\nconst serviceDurationRaw = stateData.serviceDuration || '0';\nconst employeeName = $('Availability Agent').first().json.output.result.employeeName;\nconst dateTimeUTC = stateData.dateTime;\n\n// Handle multiple services - join with \"&\"\nconst serviceNames = serviceNameRaw.split(',').map(s => s.trim()).join(' & ');\n\n// Handle multiple durations - sum them\nconst totalDuration = serviceDurationRaw.split(',')\n  .map(d => parseInt(d.trim()))\n  .reduce((sum, d) => sum + d, 0);\n\n// Parse UTC datetime and format for display\nconst utcDate = new Date(dateTimeUTC);\n\n// Format date as \"23 Feb 2025\"\nconst day = utcDate.toLocaleDateString('en-US', { day: 'numeric', timeZone: 'America/Cancun' });\nconst month = utcDate.toLocaleDateString('en-US', { month: 'short', timeZone: 'America/Cancun' });\nconst year = utcDate.toLocaleDateString('en-US', { year: 'numeric', timeZone: 'America/Cancun' });\nconst dateFormatted = `${day} ${month} ${year}`;\n\n// Format time as \"11:30 AM\"\nconst timeFormatted = utcDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\n// Calculate end time\nconst endDate = new Date(utcDate.getTime() + (totalDuration * 60 * 1000));\nconst endTimeFormatted = endDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\n// Build the summary message\nconst message = `Perfect! Here's your booking summary:\n\nðŸ“… Date: ${dateFormatted}\nâ° Time: ${timeFormatted} - ${endTimeFormatted} (${totalDuration} min)\nðŸ’… Service: ${serviceNames} (${totalDuration} min)\nâœ¨ Technician: ${employeeName}\nðŸ“ Location: Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\n\nReply 'confirm' to complete your booking, or let me know if you'd like to change anything!`;\n\nreturn [{\n  json: {\n    message: message\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12816,
        48
      ],
      "id": "c04cebc1-e801-4d05-89e8-d71519c2e6f8",
      "name": "Build Summary"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {pendingBirthday: \"true\"} }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        12608,
        240
      ],
      "id": "8522c353-ab23-4a73-b153-fca3deec9b4c",
      "name": "set_userflag_pendingBirthday",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {readyToBook: \"true\"} }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        12608,
        48
      ],
      "id": "e2e15bdc-6e3a-4395-b006-490cfd83555b",
      "name": "set_userflag_readyToBook",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        10896,
        -288
      ],
      "id": "67c41dc4-d128-4949-91da-33d549bcb81d",
      "name": "Google Gemini Chat Model3",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"intent\": {\n      \"type\": \"string\",\n      \"enum\": [\"MODIFY_SERVICE\", \"MODIFY_DATETIME\", \"MODIFY_TECHNICIAN\", \"MODIFY_ALL\", \"NOT_MODIFYING\"]\n    }\n  },\n  \"required\": [\"intent\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        5248,
        784
      ],
      "id": "78d96659-91b2-4db3-8799-c603eb708874",
      "name": "Structured Output Parser5"
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "serviceID, serviceDuration, servicePrice, serviceName, availabilityConfirmed, readyToBook, needsAvailabilityCheck"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5856,
        368
      ],
      "id": "a27cd030-56fb-43de-8015-a58b364f8841",
      "name": "delete_for_service_change",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "dateTime, partialDate, partialTime, availabilityConfirmed, readyToBook, needsAvailabilityCheck"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5856,
        544
      ],
      "id": "2d941884-5c75-4c81-8078-613fac5ab399",
      "name": "delete_for_datetime_change",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "serviceID, serviceDuration, servicePrice, serviceName, dateTime, partialDate, partialTime, dateTimeConfirmed, employeeID, employeeName, availabilityConfirmed, readyToBook, pendingBirthday, pendingAlternatives, needsAvailabilityCheck"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5856,
        912
      ],
      "id": "d8100083-4919-42b2-b548-cdd9e079e137",
      "name": "delete_for_full_reset",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "employeeID, employeeName, availabilityConfirmed, readyToBook, needsAvailabilityCheck"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5856,
        736
      ],
      "id": "14c36f67-d602-4a27-8302-233550ceeac2",
      "name": "delete_for_technician_change",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        3744,
        6128
      ],
      "id": "9ab122a0-1460-4c25-b12a-77da97139022",
      "name": "Google Gemini Chat Model4",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's Message: {{ $('Set Initial Data').first().json.messageBody }}\nToday: {{ $now.setZone('America/Cancun').toFormat('yyyy-MM-dd') }}\nTomorrow: {{ $now.plus({days: 1}).setZone('America/Cancun').toFormat('yyyy-MM-dd') }}\n\n- Service: {{ $('get_userflag_all').first().json.userflag?.serviceName || 'None' }}\n- Date/Time: {{ $('get_userflag_all').first().json.userflag?.dateTime || 'None' }}\n- Technician: {{ $('get_userflag_all').first().json.userflag?.employeeName || 'None' }}\n- Ready to Confirm: {{ $('get_userflag_all').first().json.userflag?.readyToBook === 'true' ? 'YES' : 'NO' }}\n\n- Service: {{ $('get_userflag_all').first().json.userflag?.serviceName || 'None' }}\n- Date/Time: {{ $('get_userflag_all').first().json.userflag?.dateTime || 'None' }}\n- Technician: {{ $('get_userflag_all').first().json.userflag?.employeeName || 'None' }}\n- Ready to Confirm: {{ $('get_userflag_all').first().json.userflag?.readyToBook === 'true' ? 'YES' : 'NO' }}\n- Active Intent: {{ $('get_userflag_all').first().json.userflag?.activeIntent || 'None' }}",
        "options": {
          "systemMessage": "General Question Agent\n\nAnswer general questions quickly. Guide users back to booking unless they're ready to confirm.\n\n## TOOLS\n1. **list_biz_info** - Hours, location, contact info\n2. **list_services** - Pricing, durations, service details\n3. **employee_list** - List of all technicians (names, IDs)\n4. **gq_employee_availability** - Check specific technician's schedule for a date\n   - Parameters: date (YYYY-MM-DD), name (Employee Name)\n   - Returns: Working Hours, Blocked Times\n\n### Tool Selection:\n- \"Who are your technicians?\" â†’ CALL employee_list\n- \"Is Sarah working tomorrow?\" â†’ CALL gq_employee_availability\n\n## CRITICAL RULE: NO GUESSING\n- Memory is wrong: If a question CANNOT be answered by your tools, do NOT make up an answer.\n\nInstead: \"For that, please call us at [phone from list_biz_info]!\"\n\nQuestions you CANNOT answer (redirect to call):\n- Parking\n- Anything not in your tools\n\n## RESPONSE RULES\n\n### Length\n2-3 sentences MAX. This is WhatsApp.\n\n### Ending Your Response\n\n**IF Ready to Confirm = YES:**\nâ†’ Just answer the question. No nudge needed.\n\n**IF Active Intent = CANCEL_BOOKING:** â†’ Answer + \"Ready to continue with your cancellation?\" \n\n**IF Active Intent = UPDATE_BOOKING:** â†’ Answer + \"Ready to continue updating your appointment?\"\n\n**IF Booking in Progress (has service OR datetime OR technician):**\nâ†’ Answer + \"Ready to finish your booking?\"\n\n**IF No Booking Progress:**\nâ†’ Answer + \"Can I help you book an appointment?\"\n\n## QUESTION HANDLING\n\n### Hours/Location\nUser: \"What are your hours?\"\nâ†’ CALL list_biz_info\n\"We're open Monday-Saturday, 9 AM to 8 PM! [nudge based on state]\"\n\nUser: \"Where are you?\"\nâ†’ CALL list_biz_info\n\"We're at [address from tool]! [nudge based on state]\"\n\n### Services/Pricing\nUser: \"How much is a mani pedi?\"\nâ†’ CALL list_services\n\"Classic Mani-Pedi is $85 (45 min). [nudge based on state]\"\n\nUser: \"What services do you have?\"\nâ†’ CALL list_services\n\"Express Manicure ($65), Classic Mani-Pedi ($85), and Deluxe Spa ($145). [nudge based on state]\"\n\n### Technicians - General\nUser: \"Who are your technicians?\"\nâ†’ CALL employee_list\n\"Our team includes [names from tool]! Any preference? [nudge based on state]\"\n\nUser: \"Who works there?\"\nâ†’ CALL employee_list\n\"We have [names from tool]! [nudge based on state]\"\n\n### Technicians - Specific Availability\nUser: \"Is Sarah working tomorrow?\"\nâ†’ CALL gq_employee_availability with date=[tomorrow], name=Sarah Johnson\nIF Working Hours != OFF: \"Yes, Sarah's in tomorrow [hours]! [nudge based on state]\"\nIF Working Hours == OFF: \"Sarah's off tomorrow. [nudge based on state]\"\n\nUser: \"When is David available Friday?\"\nâ†’ CALL gq_employee_availability with date=[Friday's date], name=David Martinez\n\"David works [hours] on Friday! [nudge based on state]\"\n\n### Policies You Know\nUser: \"Cancellation policy?\"\n\"Please cancel 24 hours in advance. [nudge based on state]\"\n\nUser: \"Payment methods?\"\nâ†’ CALL list_biz_info (if payment info exists), otherwise:\n\"For payment options, please call us at [phone]! [nudge based on state]\"\n\n### Questions You CANNOT Answer\nUser: \"Do you have parking?\"\nâ†’ CALL list_biz_info for phone\n\"For parking info, please call us at [phone]! [nudge based on state]\"\n\nUser: \"Do you sell gift cards?\"\nâ†’ CALL list_biz_info for phone\n\"For gift cards, please call us at [phone]! [nudge based on state]\"\n\nUser: \"Is the salon wheelchair accessible?\"\nâ†’ CALL list_biz_info for phone\n\"For accessibility info, please call us at [phone]! [nudge based on state]\"\n\n### Off-Topic\nUser: [completely unrelated]\n\"I'm your booking assistant! Can I help you schedule a nail appointment?\"\n\n\n## EXAMPLES BY STATE\n\n### Ready to Confirm = YES\nUser: \"What time do you close?\"\nâ†’ CALL list_biz_info\n\"We're open until 8 PM!\"\n\n### Active Intent = CANCEL_BOOKING User: \"What's your cancellation policy?\" \"Please cancel 24 hours in advance. Ready to continue with your cancellation?\" \n\n### Active Intent = UPDATE_BOOKING User: \"How long is the deluxe service?\" â†’ CALL list_services \"The Deluxe Spa is 75 minutes. Ready to continue updating your appointment?\"\n\n### Booking in Progress\nUser: \"Who are your technicians?\"\nâ†’ CALL employee_list\n\"Our team includes Sarah, David, and Emily! Ready to finish your booking?\"\n\n### No Booking Progress\nUser: \"Do you have parking?\"\nâ†’ CALL list_biz_info for phone\n\"For parking info, please call us at 555-1234! Can I help you book an appointment?\"\n\n## RULES\n- NEVER guess - if not in tools, redirect to phone\n- NEVER exceed 3 sentences\n- NEVER nudge if Ready to Confirm = YES\n- ALWAYS nudge otherwise\n- ONE tool call max per response\n- Use employee_list for \"who works here\" questions\n- Use gq_employee_availability for \"is X working on Y day\" questions\n- Memory is wrong: NEVER hallucinate times, dates, or confirmation messages. If you don't have data from a tool, don't make it up.\n- You are a Q&A assistant. You CANNOT confirm, finalize, or complete bookings. \n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4096,
        5776
      ],
      "id": "aae96456-46b0-4f30-a99f-35baa7a3cbcb",
      "name": "General Question Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Get salon information like name, address, phone number, and business hours from the Configuration sheet.",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1741158037,
          "mode": "list",
          "cachedResultName": "Configuration",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=1741158037"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.5,
      "position": [
        4192,
        6128
      ],
      "id": "1a0c892e-6efe-44c3-be37-d9ebe0e120eb",
      "name": "gq_list_biz_info",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Get list of available nail services and their prices from the Services sheet.",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1786453814,
          "mode": "list",
          "cachedResultName": "Services (admin)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=1786453814"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.5,
      "position": [
        4320,
        6128
      ],
      "id": "64884a21-bbe4-42be-96b6-14d5664f8467",
      "name": "gq_list_services",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Date",
              "lookupValue": "={{ $fromAI('date', 'Appointment date in YYYY-MM-DD format (e.g., 2025-11-28)', 'string') }}"
            },
            {
              "lookupColumn": "Employee Name",
              "lookupValue": "={{ $fromAI('name', 'Employee Name)', 'string') }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        4464,
        6128
      ],
      "id": "c02baee9-3b9e-4c87-9566-f851b27be6e5",
      "name": "gq_employee_availability",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        4064,
        6128
      ],
      "id": "f131e7cf-a6aa-483b-a39a-333cb3fddb31",
      "name": "employee_list1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        11824,
        528
      ],
      "id": "17216ddc-3e67-406a-bb5a-5cdf0c8ecb75",
      "name": "Get Employee Availability Range",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0ddc6cbe-6f77-4cd0-953b-938524dea59f",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag.employeeID }}",
              "rightValue": "NEXT_AVAILABLE",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        12768,
        512
      ],
      "id": "5144c3fc-d84d-458a-ab6a-022f36bf4f0d",
      "name": "If7"
    },
    {
      "parameters": {
        "jsCode": "let userflag;\ntry {\n  userflag = $('State Merger & Router').first().json.merged;\n} catch (e) {\n  try {\n    userflag = $('Prep Availability From Unqualified').first().json.merged;\n  } catch (e2) {\n    const uf = $('get_userflag_all').first().json.userflag || {};\n    userflag = { dateTime: uf.dateTime, serviceDuration: uf.serviceDuration, serviceName: uf.serviceName };\n  }\n}\n\nconst alternatives = $('Availability Code').first().json.alternatives;\n\n// Get display time from userflag (original requested time)\nconst dateTime = new Date(userflag.dateTime);\nconst timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun' };\nconst dateOptions = { weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun' };\nconst displayTime = dateTime.toLocaleTimeString('en-US', timeOptions);\nconst displayDate = dateTime.toLocaleDateString('en-US', dateOptions);\n\nlet message = `Unfortunately, ${userflag.employeeName} isn't available at ${displayTime} on ${displayDate}.\\n\\n`;\n\nif (alternatives[0]) {\n  message += `Their next opening is *${alternatives[0].dateDisplay} at ${alternatives[0].timeDisplay}*.\\n\\n`;\n  message += `Reply *\"yes\"* to book ${alternatives[0].timeDisplay} with ${alternatives[0].employeeName}\\n`;\n  message += `Reply *\"other technician\"* to check ${displayTime} with another technician\\n`;\n  message += `Or tell me a different date & time!`;\n} else {\n  message += `Unfortunately, I couldn't find any openings for ${userflag.employeeName} in the next 8 weeks.\\n\\n`;\n  message += `Reply *\"other technician\"* to check ${displayTime} with another technician\\n`;\n  message += `Or tell me a different date & time!`;\n}\n\nreturn [{ json: { message } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12992,
        432
      ],
      "id": "e1e36bb6-5fe5-41a1-bef3-7c0b0d8c94cb",
      "name": "Build Specific Employee Messag"
    },
    {
      "parameters": {
        "jsCode": "let userflag;\ntry {\n  userflag = $('State Merger & Router').first().json.merged;\n} catch (e) {\n  try {\n    userflag = $('Prep Availability From Unqualified').first().json.merged;\n  } catch (e2) {\n    const uf = $('get_userflag_all').first().json.userflag || {};\n    userflag = { dateTime: uf.dateTime, serviceDuration: uf.serviceDuration, serviceName: uf.serviceName };\n  }\n}\n\nconst alternatives = $('Availability Code').first().json.alternatives;\n\n// Get display time from userflag\nconst dateTime = new Date(userflag.dateTime);\nconst timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun' };\nconst dateOptions = { weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun' };\nconst displayTime = dateTime.toLocaleTimeString('en-US', timeOptions);\nconst displayDate = dateTime.toLocaleDateString('en-US', dateOptions);\n\nlet message = `Sorry, all of our technicians are busy at ${displayTime} on ${displayDate}.\\n\\n`;\n\nif (alternatives[0]) {\n  message += `The next available slot is *${alternatives[0].dateDisplay} at ${alternatives[0].timeDisplay}* with ${alternatives[0].employeeName}.\\n\\n`;\n  message += `Reply *\"yes\"* to book this slot\\n`;\n  message += `Or tell me a different date & time!`;\n} else {\n  message += `Unfortunately, I couldn't find any available appointments in the next 8 weeks.\\n\\n`;\n  message += `Please call us directly or try a different date & time.`;\n}\n\nreturn [{ json: { message } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12992,
        592
      ],
      "id": "9a8674e1-3c8d-40c8-9310-b71e45644c17",
      "name": "Build No Employees Message"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "20cc47d5-bc81-433d-a015-ad2018206652",
              "leftValue": "={{ $('Context Switch Identifier').item.json.needsCleanup }}",
              "rightValue": "=true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2112,
        720
      ],
      "id": "28f97251-5327-4770-aa6d-514377ff5816",
      "name": "Cleanup Needed?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "eb9758f6-ba6b-49f4-8523-050c8d53221f",
              "leftValue": "={{ $('Context Switch Identifier').item.json.needsActiveIntentUpdate }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2464,
        720
      ],
      "id": "d7c39512-19eb-4dd8-bd0d-bb1b8d38683c",
      "name": "needsActiveIntentUpdate"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ {\n  employeeID: $('Availability Agent').item.json.output.result.employeeID,\n  employeeName: $('Availability Agent').item.json.output.result.employeeName\n} }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        12032,
        144
      ],
      "id": "23203de7-d6ae-4725-8f7c-3a36aac4b4e5",
      "name": "Set Assigned Employee Data",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// FIND ALTERNATIVES - Deterministic Code Node\n// ================================================================\n\n// GET PARAMETERS FROM UPSTREAM\n// Try State Merger & Router first, fall back to Prep Availability From Unqualified, then direct input\nlet userflag;\ntry {\n  userflag = $('State Merger & Router').first().json.merged;\n} catch (e) {\n  try {\n    userflag = $('Prep Availability From Unqualified').first().json.merged;\n  } catch (e2) {\n    userflag = $input.first().json.merged || {};\n  }\n}\n\n\n// ================================================================\n// VALIDATE REQUIRED DATA EXISTS\n// ================================================================\nif (!userflag || !userflag.dateTime) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_datetime\",\n      errorMessage: \"No date/time specified for availability search\"\n    }\n  }];\n}\n\nif (!userflag.serviceDuration) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_duration\",\n      errorMessage: \"No service duration specified\"\n    }\n  }];\n}\n\n// Extract booking parameters\nconst requestedDateTimeUTC = userflag.dateTime;\n\n// Handle comma-separated durations (sum them)\nlet duration;\nif (userflag.serviceDuration.includes(',')) {\n  duration = userflag.serviceDuration.split(',').reduce((sum, d) => sum + parseInt(d.trim()), 0);\n} else {\n  duration = parseInt(userflag.serviceDuration);\n}\n\nconst requestedDate = requestedDateTimeUTC.split('T')[0];\nconst filterEmployeeID = (userflag.employeeID && userflag.employeeID !== \"NEXT_AVAILABLE\") \n  ? userflag.employeeID \n  : null;\nconst filterEmployeeName = (userflag.employeeName && userflag.employeeName !== \"Next Available\") \n  ? userflag.employeeName \n  : null;\n\n// GET EMPLOYEE DATA FROM GOOGLE SHEETS\nconst employeeData = $('Get Employee Availability Range').all().map(item => item.json);\n\n\n// ================================================================\n// SERVICE RESTRICTION FILTER (uses Redis-stored data)\n// ================================================================\n\nlet qualifiedEmployeeIDs = null;\n\n// Method 1: Try to get from Check Service Restrictions node\ntry {\n  const restrictionCheck = $('Check Service Restrictions').first().json;\n  if (restrictionCheck && restrictionCheck.qualifiedEmployeeIDs && restrictionCheck.qualifiedEmployeeIDs.length > 0) {\n    qualifiedEmployeeIDs = new Set(restrictionCheck.qualifiedEmployeeIDs);\n  }\n} catch (e) {\n  // Check Service Restrictions reference failed\n}\n\n// Method 2: Fallback - read allowedEmployees directly from userflag\nif (qualifiedEmployeeIDs === null) {\n  const allowedRaw = userflag.allowedEmployees;\nif (allowedRaw && allowedRaw.toUpperCase() !== 'ALL') {\n  const empList = allowedRaw.replace(/\\|/g, ',').split(',').map(e => e.trim()).filter(e => e && e !== 'ALL' && e !== 'undefined');\n    if (empList.length > 0) {\n      qualifiedEmployeeIDs = new Set(empList);\n    }\n  }\n}\n\n// SCOPE FILTER: Exclude specialty-only techs from \"ALL\" services\nlet filteredEmployeeData = employeeData;\nif (qualifiedEmployeeIDs === null) {\n  // \"ALL\" service â€” exclude SPECIALTY-only employees\n  try {\n    const empInfo = $('Get Employee Info For Names').all().map(item => item.json);\n    const specialtyOnlyIDs = new Set(\n      empInfo\n        .filter(e => (e['Service Scope'] || 'GENERAL').toUpperCase() === 'SPECIALTY')\n        .map(e => e['Employee ID'])\n    );\n    if (specialtyOnlyIDs.size > 0) {\n      filteredEmployeeData = filteredEmployeeData.filter(row => {\n        const empID = row['Employee ID'] || row['employeeID'] || '';\n        return !specialtyOnlyIDs.has(empID);\n      });\n    }\n  } catch (e) {\n    // If employee info not accessible, skip scope filter\n  }\n}\n\n// Filter employees if restrictions exist\nif (qualifiedEmployeeIDs !== null) {\n  filteredEmployeeData = employeeData.filter(row => {\n    const empID = row['Employee ID'] || row['employeeID'] || '';\n    return qualifiedEmployeeIDs.has(empID);\n  });\n  \n  if (filteredEmployeeData.length === 0) {\n    return [{\n      json: {\n        success: false,\n        found: false,\n        count: 0,\n        alternatives: [],\n        pendingAlternatives: null,\n        error: \"no_qualified_availability\",\n        errorMessage: \"No qualified technicians available for this service\"\n      }\n    }];\n  }\n}\n\n// Validate we have data\nif (!employeeData || employeeData.length === 0) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_employee_data\",\n      errorMessage: \"No employee availability data found\"\n    }\n  }];\n}\n\n// ================================================================\n// CONFIGURATION\n// ================================================================\nconst MAX_RESULTS_PER_DIRECTION = 1;\nconst INCREMENT_MINUTES = 5;\nconst MAX_OFFSET_MINUTES = 56 * 24 * 60; // 8 weeks\n\n// ================================================================\n// HELPER FUNCTIONS\n// ================================================================\n\nfunction utcToLocal(utcDatetime) {\n  const date = new Date(utcDatetime);\n  const localHour = date.getUTCHours() - 5; // EST = UTC-5\n  const localMinute = date.getUTCMinutes();\n  \n  let adjustedHour = localHour;\n  let dayOffset = 0;\n  \n  if (localHour < 0) {\n    adjustedHour = 24 + localHour;\n    dayOffset = -1;\n  } else if (localHour >= 24) {\n    adjustedHour = localHour - 24;\n    dayOffset = 1;\n  }\n  \n  return { hour: adjustedHour, minute: localMinute, dayOffset };\n}\n\nfunction parseTime(timeStr) {\n  const [time, period] = timeStr.split(' ');\n  let [hour, minute] = time.split(':').map(Number);\n  if (period === 'PM' && hour !== 12) hour += 12;\n  if (period === 'AM' && hour === 12) hour = 0;\n  return { hour, minute };\n}\n\nfunction isTimeInRange(checkTime, startTime, endTime) {\n  const checkMinutes = checkTime.hour * 60 + checkTime.minute;\n  const startMinutes = startTime.hour * 60 + startTime.minute;\n  const endMinutes = endTime.hour * 60 + endTime.minute;\n  return checkMinutes >= startMinutes && checkMinutes < endMinutes;\n}\n\nfunction timeRangesOverlap(start1, end1, start2, end2) {\n  const start1Min = start1.hour * 60 + start1.minute;\n  const end1Min = end1.hour * 60 + end1.minute;\n  const start2Min = start2.hour * 60 + start2.minute;\n  const end2Min = end2.hour * 60 + end2.minute;\n  return start1Min < end2Min && end1Min > start2Min;\n}\n\nfunction formatTimeForDisplay(localTime) {\n  let hour = localTime.hour;\n  const minute = localTime.minute;\n  const period = hour >= 12 ? 'PM' : 'AM';\n  \n  if (hour > 12) hour -= 12;\n  if (hour === 0) hour = 12;\n  \n  return `${hour}:${minute.toString().padStart(2, '0')} ${period}`;\n}\n\nfunction formatDateForDisplay(dateStr) {\n  const date = new Date(dateStr + 'T00:00:00Z');\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', \n                  'July', 'August', 'September', 'October', 'November', 'December'];\n  \n  return `${days[date.getUTCDay()]}, ${months[date.getUTCMonth()]} ${date.getUTCDate()}`;\n}\n\nfunction extractDateFromUTC(utcDatetime) {\n  const date = new Date(utcDatetime);\n  date.setHours(date.getHours() - 5);\n  return date.toISOString().split('T')[0];\n}\n\nfunction isSunday(utcDatetime) {\n  const date = new Date(utcDatetime);\n  date.setHours(date.getHours() - 5);\n  return date.getDay() === 0;\n}\n\nfunction isWithinBusinessHours(localTime) {\n  return localTime.hour >= 9 && localTime.hour < 20;\n}\n\nfunction checkSlotAvailability(datetimeUTC, dur, workingHours, blockedTimes) {\n  if (!workingHours || workingHours.toUpperCase() === \"OFF\") {\n    return false;\n  }\n  \n  const workingHoursTrimmed = workingHours.trim();\n  let startStr, endStr;\n  \n  if (workingHoursTrimmed.includes(' - ')) {\n    [startStr, endStr] = workingHoursTrimmed.split(' - ');\n  } else if (workingHoursTrimmed.includes('-')) {\n    [startStr, endStr] = workingHoursTrimmed.split('-').map(s => s.trim());\n  } else {\n    return false;\n  }\n  \n  const workStart = parseTime(startStr);\n  const workEnd = parseTime(endStr);\n  \n  const localTimeData = utcToLocal(datetimeUTC);\n  const requestedTime = { hour: localTimeData.hour, minute: localTimeData.minute };\n  const requestedEndTime = {\n    hour: requestedTime.hour,\n    minute: requestedTime.minute + dur\n  };\n  \n  if (requestedEndTime.minute >= 60) {\n    requestedEndTime.hour += Math.floor(requestedEndTime.minute / 60);\n    requestedEndTime.minute = requestedEndTime.minute % 60;\n  }\n  \n  if (!isTimeInRange(requestedTime, workStart, workEnd)) {\n    return false;\n  }\n  \n  if (requestedEndTime.hour > workEnd.hour || \n      (requestedEndTime.hour === workEnd.hour && requestedEndTime.minute > workEnd.minute)) {\n    return false;\n  }\n  \n  if (blockedTimes && typeof blockedTimes === 'string' && blockedTimes.trim() !== \"\") {\n    const blocks = blockedTimes.split(',').map(b => b.trim());\n    \n    for (const block of blocks) {\n      if (block && block.includes('-')) {\n        const parts = block.split('-');\n        if (parts.length !== 2) continue;\n        \n        const blockStartStr = parts[0].trim();\n        const blockEndStr = parts[1].trim();\n        \n        const blockStart = parseTime(blockStartStr);\n        const blockEnd = parseTime(blockEndStr);\n        \n        if (timeRangesOverlap(requestedTime, requestedEndTime, blockStart, blockEnd)) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}\n\nfunction generateCandidateSlot(baseDateTime, offsetMinutes) {\n  const candidateDateTime = new Date(baseDateTime);\n  candidateDateTime.setMinutes(candidateDateTime.getMinutes() + offsetMinutes);\n  return candidateDateTime;\n}\n\n// ================================================================\n// SEARCH FORWARD (3 closest AFTER)\n// ================================================================\n\nconst slotsAfter = [];\nconst requestedDateTime = new Date(requestedDateTimeUTC);\nlet offsetAfter = INCREMENT_MINUTES;\n\nwhile (slotsAfter.length < MAX_RESULTS_PER_DIRECTION && offsetAfter <= MAX_OFFSET_MINUTES) {\n  const slotAfterUTC = generateCandidateSlot(requestedDateTime, offsetAfter);\n  const slotAfterUTCStr = slotAfterUTC.toISOString();\n  const slotAfterDate = extractDateFromUTC(slotAfterUTCStr);\n  const slotAfterLocal = utcToLocal(slotAfterUTCStr);\n  \n  if (!isSunday(slotAfterUTCStr) && isWithinBusinessHours(slotAfterLocal)) {\n    const matchingRowsAfter = filteredEmployeeData.filter(row => {\n      const rowDate = row['Date'] || row['date'] || '';\n      if (!rowDate) return false;\n      \n      if (filterEmployeeID) {\n        const rowEmployeeID = row['Employee ID'] || row['employeeID'] || '';\n        return rowDate === slotAfterDate && rowEmployeeID === filterEmployeeID;\n      } else {\n        return rowDate === slotAfterDate;\n      }\n    });\n    \n    for (const row of matchingRowsAfter) {\n      if (slotsAfter.length >= MAX_RESULTS_PER_DIRECTION) break;\n      \n      const workingHours = row['Working Hours'] || row['workingHours'] || '';\n      const blockedTimes = row['Blocked Times'] || row['blockedTimes'] || '';\n      const employeeID = row['Employee ID'] || row['employeeID'] || '';\n      const employeeName = row['Employee Name'] || row['employeeName'] || '';\n      \n      if (checkSlotAvailability(slotAfterUTCStr, duration, workingHours, blockedTimes)) {\n        slotsAfter.push({\n          datetime: slotAfterUTCStr,\n          dateDisplay: formatDateForDisplay(slotAfterDate),\n          timeDisplay: formatTimeForDisplay(slotAfterLocal),\n          employeeID: employeeID,\n          employeeName: employeeName,\n          duration: duration,\n          offsetMinutes: offsetAfter\n        });\n        \n        if (filterEmployeeID) break;\n      }\n    }\n  }\n  \n  offsetAfter += INCREMENT_MINUTES;\n}\n\n// ================================================================\n// SEARCH BACKWARD (3 closest BEFORE)\n// ================================================================\n\nconst slotsBefore = [];\nlet offsetBefore = INCREMENT_MINUTES;\n\n// Don't search before current time\nconst now = new Date();\n\nwhile (slotsBefore.length < MAX_RESULTS_PER_DIRECTION && offsetBefore <= MAX_OFFSET_MINUTES) {\n  const slotBeforeUTC = generateCandidateSlot(requestedDateTime, -offsetBefore);\n  \n  // Skip if this slot is in the past\n  if (slotBeforeUTC < now) {\n    offsetBefore += INCREMENT_MINUTES;\n    continue;\n  }\n  \n  const slotBeforeUTCStr = slotBeforeUTC.toISOString();\n  const slotBeforeDate = extractDateFromUTC(slotBeforeUTCStr);\n  const slotBeforeLocal = utcToLocal(slotBeforeUTCStr);\n  \n  if (!isSunday(slotBeforeUTCStr) && isWithinBusinessHours(slotBeforeLocal)) {\n    const matchingRowsBefore = filteredEmployeeData.filter(row => {\n      const rowDate = row['Date'] || row['date'] || '';\n      if (!rowDate) return false;\n      \n      if (filterEmployeeID) {\n        const rowEmployeeID = row['Employee ID'] || row['employeeID'] || '';\n        return rowDate === slotBeforeDate && rowEmployeeID === filterEmployeeID;\n      } else {\n        return rowDate === slotBeforeDate;\n      }\n    });\n    \n    for (const row of matchingRowsBefore) {\n      if (slotsBefore.length >= MAX_RESULTS_PER_DIRECTION) break;\n      \n      const workingHours = row['Working Hours'] || row['workingHours'] || '';\n      const blockedTimes = row['Blocked Times'] || row['blockedTimes'] || '';\n      const employeeID = row['Employee ID'] || row['employeeID'] || '';\n      const employeeName = row['Employee Name'] || row['employeeName'] || '';\n      \n      if (checkSlotAvailability(slotBeforeUTCStr, duration, workingHours, blockedTimes)) {\n        slotsBefore.push({\n          datetime: slotBeforeUTCStr,\n          dateDisplay: formatDateForDisplay(slotBeforeDate),\n          timeDisplay: formatTimeForDisplay(slotBeforeLocal),\n          employeeID: employeeID,\n          employeeName: employeeName,\n          duration: duration,\n          offsetMinutes: offsetBefore\n        });\n        \n        if (filterEmployeeID) break;\n      }\n    }\n  }\n  \n  offsetBefore += INCREMENT_MINUTES;\n}\n\n// ================================================================\n// COMBINE AND SELECT 3 CLOSEST\n// ================================================================\n\nconst allSlots = [...slotsAfter, ...slotsBefore];\nallSlots.sort((a, b) => Math.abs(a.offsetMinutes) - Math.abs(b.offsetMinutes));\nconst finalAlternatives = allSlots.slice(0, 1);\n\n// Clean output\nconst cleanedAlternatives = finalAlternatives.map(alt => ({\n  datetime: alt.datetime,\n  dateDisplay: alt.dateDisplay,\n  timeDisplay: alt.timeDisplay,\n  employeeID: alt.employeeID,\n  employeeName: alt.employeeName,\n  duration: alt.duration\n}));\n\n// Return with found flag for IF node\nreturn [{\n  json: {\n    success: cleanedAlternatives.length > 0,\n    found: cleanedAlternatives.length > 0,\n    count: cleanedAlternatives.length,\n    alternatives: cleanedAlternatives,\n    pendingAlternatives: cleanedAlternatives.length > 0 ? JSON.stringify(cleanedAlternatives) : null,\n    error: cleanedAlternatives.length === 0 ? \"no_availability\" : null,\n    errorMessage: cleanedAlternatives.length === 0 \n      ? \"No available appointments found within the next 8 weeks\" \n      : null\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12000,
        528
      ],
      "id": "9e84936e-bbc3-4dd9-801c-abdfcb898f37",
      "name": "Availability Code"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=Hi there! Welcome to Zen Touch Nail Salon ðŸ’…âœ¨\n\nI'm here to help book your perfect nail appointment!\n\nðŸ“ Our Hours:\nMondayâ€“Friday: 9:00 AMâ€“7:00 PM EST\n\nðŸ“ Location:\nAvenida KukulkÃ¡n 230, Zona Hotelera\nCancÃºn (Near Playa Marlin)\n\nðŸ’… Our Services:\nðŸŒŸ Express Manicure (30 min) â€” $65\nðŸŒŸ Classic Manicure & Pedicure (45 min) â€” $85\nðŸŒŸ Deluxe Spa Manicure & Pedicure (90 min) â€” $145",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1264,
        736
      ],
      "id": "7e121fe2-48ad-4ab1-8ab0-b98b60cc0f29",
      "name": "Greet User",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=It seems like you're trying to confirm appointment details without setting up the appointment first. The word \"confirm\" is reverved for confirming appointment details. Would you like to book an appointment today?",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2320,
        -3840
      ],
      "id": "b1d2f530-ba01-4919-a92b-a6e07e185887",
      "name": "Notify user they dont have any pending appointments.  Ask them to start the conversation again.",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't quite catch that! ðŸ˜Š  What's your birthday? (e.g., October 17, 10/17)  Or reply 'skip' to proceed without.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2352,
        -1312
      ],
      "id": "8fd6744d-a644-4687-a3dc-093214414e07",
      "name": "Repeat Birthday Request",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I see you currently have 5 active bookings, which is our maximum per client. To book a new appointment, please cancel one of your existing appointments first. Would you like me to help you view or cancel an existing booking",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        3984,
        176
      ],
      "id": "2c1a2dc4-400d-4922-a7c1-89e12ae901b1",
      "name": "Booking Limit Exceeded",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Extract Selection Data').first().json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        6944,
        -512
      ],
      "id": "9713a35b-166b-4f30-b1b2-1e2a32c5f24c",
      "name": "confirmation message1",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=Great, that slot is available! ðŸŽ‰\n\nBefore we confirm, we love sending birthday surprises to our customers! ðŸŽ\nWhat's your birthday? (e.g., October 17, 10/17)\n\nReply 'skip' if you'd prefer not to share.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        6944,
        -304
      ],
      "id": "b44cb370-00c9-4ff8-9574-bd584e9bb23c",
      "name": "Birthday Request Alternative",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        6064,
        -32
      ],
      "id": "061cb239-131b-415f-935d-1d1f64ce11cd",
      "name": "Repeat Alternatives",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.output }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11328,
        -560
      ],
      "id": "ec9d9482-07ba-4508-b175-61b25e0f55b2",
      "name": "Response Agent Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        13008,
        48
      ],
      "id": "a706b8d7-d02d-45f2-ba53-67ab0a8e7bbb",
      "name": "Send Summary",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I'm sorry, but I couldn't find any available appointments within the next 8 weeks for your requested service.\n\nPlease call us directly at [PHONE NUMBER] and we'll help you find a time that works.\n\nThank you for your patience! ðŸ™",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        12528,
        704
      ],
      "id": "ae7ceb1f-2489-498e-acc0-552ec1bd9fa4",
      "name": "No availability (bug)",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "2b997bd7-0030-449a-a2af-540309f83bc7",
              "leftValue": "={{ $json.found }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        12224,
        528
      ],
      "id": "7e594509-7d69-4c18-98e8-fe33d4833259",
      "name": "Alternative Found?"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        13200,
        512
      ],
      "id": "f20c28c4-2592-4bd6-b8fb-d2c305cb0e39",
      "name": "Present Alternatives",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.output }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4608,
        5632
      ],
      "id": "8c0d3837-8cf8-45f7-8f79-9dc98eca4452",
      "name": "GQ Response",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $json.body.WaId }}",
        "toWhatsapp": true,
        "message": "We only support text mesages.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -5472,
        496
      ],
      "id": "14e4162b-f4ad-4343-be02-f4cd5ddc5928",
      "name": "Message Medium Notification",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+17754858165",
        "to": "={{ $json.body.WaId }}",
        "toWhatsapp": true,
        "message": "{{ $('Check Limit').first().json.ownerMessage }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3696,
        496
      ],
      "id": "0012f4a5-efe3-41d2-8dc8-964400b18d34",
      "name": "Send Owner Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+17754858165",
        "to": "={{ $json.body.WaId }}",
        "toWhatsapp": true,
        "message": "{{ $json.userMessage }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3936,
        496
      ],
      "id": "f03fce22-b96f-4c8b-bbe3-2e08f74f4958",
      "name": "Send User Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "9101807b-6141-4032-a505-75bf067a83d0",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -5968,
        720
      ],
      "id": "36065ce7-0109-4227-9214-db58c8f55954",
      "name": "Webhook",
      "webhookId": "9101807b-6141-4032-a505-75bf067a83d0"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=âœ… Booking Confirmed!\n\nWe'll send you a reminder 2 hours before.\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        3648,
        -4032
      ],
      "id": "30491538-35af-4d52-88cb-24c93b889976",
      "name": "Booking confirmed message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "pendingAlternatives"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5840,
        112
      ],
      "id": "1be81c24-4012-49a3-b0aa-a2a5b0fa186b",
      "name": "delete pendingAlternatives3",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { employeeID: \"NEXT_AVAILABLE\", employeeName: \"Next Available\" } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        6080,
        112
      ],
      "id": "9d72bf9d-a569-4d3b-8518-81e9ffccf031",
      "name": "Set NEXT_AVAILABLE Tech",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=Great, the {{ DateTime.fromISO($('get_userflag_all').first().json.userflag.dateTime).setZone('America/Cancun').toFormat('h:mm a') }} slot on {{ DateTime.fromISO($('get_userflag_all').first().json.userflag.dateTime).setZone('America/Cancun').toFormat('d MMM yyyy') }} for {{ $('get_userflag_all').first().json.userflag.serviceName.split(',').map(s => s.trim()).join(' & ') }} with {{ $('get_userflag_all').first().json.userflag.employeeName }} is available! ðŸŽ‰\n\n\nBefore we confirm, we love sending birthday surprises to our customers! ðŸŽ\nWhat's your birthday? (e.g., October 17, 10/17)\n\nReply 'skip' if you'd prefer not to share.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        12832,
        240
      ],
      "id": "0651c019-2a24-4d09-a67b-6ea322dce740",
      "name": "Birthday Request Main",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "pendingBirthday"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2352,
        -1104
      ],
      "id": "60c04a6c-d5f3-4982-8643-4eee6a23a6de",
      "name": "modification_delete_pendingBirthday",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't quite catch that. Are you looking to book, reschedule, or ask a question?\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2000,
        944
      ],
      "id": "8eefae06-33ac-4483-835c-2eb2a8ef0f50",
      "name": "Intent Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't catch your birthday. Please reply in a format like \"October 17\" or \"10/17\", or say \"skip\" to continue without it.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1808,
        -1088
      ],
      "id": "e6ad5393-2aab-4ec0-a814-4f84be221bc4",
      "name": "Birthday Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't understand your choice. Please reply \"yes\" to book this slot, \"other technician\" to try someone else, or tell me a different time.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4688,
        0
      ],
      "id": "64386e06-d649-4798-8f32-6ad3e44784d3",
      "name": "Alternative Selection Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I'm not sure what you'd like to change. Please say specifically: \"change to [new time]\" or \"switch to [technician name]\" or \"different service\"\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5488,
        816
      ],
      "id": "1b52e31b-89ca-4c1b-8190-f058e0994e76",
      "name": "Modification Handler Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I had trouble understanding your request. Please include specific details like the service name, date, and time you'd like. Example: \"Express manicure tomorrow at 2pm\"\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        7936,
        512
      ],
      "id": "61fd23c2-44b7-4f85-9181-e4ba8f66a578",
      "name": "Extractor Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I couldn't check availability right now. Please try again or pick a date within the next 2 weeks.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11488,
        576
      ],
      "id": "d9b3686f-1e6c-45e3-b980-b5b986d7d721",
      "name": "Availability Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=Something went wrong. Let's start fresh â€” what service would you like to book? ðŸ’…\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11328,
        -320
      ],
      "id": "a8252a6e-96bd-4e17-86ff-222eb0e1a5bb",
      "name": "Response Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I'm sorry - I don't have that information. \n\nFor assistance, please give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4608,
        5952
      ],
      "id": "15e7b196-e517-43f3-9420-5afe1791a0df",
      "name": "GQ Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I couldn't find any appointments to cancel. If you have a booking, please try again or contact us directly at [PHONE] for help.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4896,
        3872
      ],
      "id": "ea80db42-21c4-4c65-9c2b-4397360e7e05",
      "name": "Cancel Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        3296,
        -1456
      ],
      "id": "e15c96fe-d001-4ba9-a1bb-9614f79eee4f",
      "name": "Birthday Summary",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5424,
        5616
      ],
      "id": "bf2ae058-3af1-4871-a50b-118a7e29ea55",
      "name": "GQ Summary",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const userflag = $('get_userflag_all').first().json.userflag;\n\nconst serviceName = userflag.serviceName || 'Service';\nconst serviceDuration = userflag.serviceDuration || '0';\nconst employeeName = userflag.employeeName || 'Next Available';\nconst dateTimeUTC = userflag.dateTime;\n\nconst utcDate = new Date(dateTimeUTC);\n\nconst dateFormatted = utcDate.toLocaleDateString('en-US', {\n  weekday: 'long',\n  month: 'long', \n  day: 'numeric',\n  timeZone: 'America/Cancun'\n});\n\n\n// Handle multiple durations - sum them\nconst totalDuration = serviceDuration.split(',')\n  .map(d => parseInt(d.trim()))\n  .reduce((sum, d) => sum + d, 0);\n\n\nconst timeFormatted = utcDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\n\n// Calculate end time\nconst endDate = new Date(utcDate.getTime() + (totalDuration * 60 * 1000));\nconst endTimeFormatted = endDate.toLocaleTimeString('en-US', {\n  hour: 'numeric',\n  minute: '2-digit',\n  hour12: true,\n  timeZone: 'America/Cancun'\n});\n\nconst message = `Here's your booking summary:\n\nðŸ“… Date: ${dateFormatted}\nâ° Time: ${timeFormatted} - ${endTimeFormatted} (${totalDuration} min)\nðŸ’… Service: ${serviceName}\nâœ¨ Technician: ${employeeName}\nðŸ“ Location: Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\n\nReply 'confirm' to complete your booking, or let me know if you'd like to change anything!`;\n\nreturn [{ json: { message } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5120,
        5616
      ],
      "id": "5be5463b-5e6b-44de-9936-3c90576e137c",
      "name": "Build GQ Summary"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "0796a11d-9e82-4f6c-953a-bd91fa008d6d",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag.readyToBook }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4848,
        5632
      ],
      "id": "fca36898-a69e-405b-90bb-bde0171f639a",
      "name": "GQ_readyToBook?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "7aff41b2-4225-4950-ae0f-c6847b7b9871",
              "leftValue": "={{ $('Intent Router Agent').first().json.output.intent }}",
              "rightValue": "GENERAL",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3632,
        5120
      ],
      "id": "178f9702-7238-49c3-b031-ee5e0532c0ec",
      "name": "GQ_or_Repeat?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "56d8aedf-be9c-4e43-bc1f-fcd2d70da7e4",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.userBookings }}",
              "rightValue": "true",
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3920,
        3728
      ],
      "id": "d201ea5e-d3a4-42f0-a047-62eddd886670",
      "name": "If User Has Bookings Cancel"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "56d8aedf-be9c-4e43-bc1f-fcd2d70da7e4",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.userBookings }}",
              "rightValue": "true",
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3872,
        2080
      ],
      "id": "fbdb75ab-2ead-48cc-8825-2648af575a5d",
      "name": "If User Has Bookings Update"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "56d8aedf-be9c-4e43-bc1f-fcd2d70da7e4",
              "leftValue": "={{ $('get_userflag_all').item.json.userflag.userBookings }}",
              "rightValue": "true",
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3984,
        4816
      ],
      "id": "00ec4a83-49fe-44d2-b856-c9a6cc103c30",
      "name": "If User Has Bookings View"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=You don't have any upcoming appointments to cancel. ðŸ“…\\n\\nWould you like to book one? Just say \\\"book\\\" to get started! ðŸ’…",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4144,
        3824
      ],
      "id": "5aad0219-6c3a-4528-8b08-b39b57b2d5af",
      "name": "No Bookings Cancel",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=You don't have any upcoming appointments to view. ðŸ“…\\n\\nWould you like to book one? Just say \\\"book\\\" to get started! ðŸ’…",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4336,
        4832
      ],
      "id": "80c20ba8-ee1e-4c3a-84f4-5083ad0559c1",
      "name": "No Bookings View",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=You don't have any upcoming appointments to modify. ðŸ“…\n\nWould you like to book one? Just say \"book\" to get started! ðŸ’…",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        4144,
        2400
      ],
      "id": "019b5aca-1325-4e27-a3a7-f7c56941752b",
      "name": "No Bookings Update",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        4368,
        3952
      ],
      "id": "2593e3f6-0faa-44a8-9a30-6f112e092aa1",
      "name": "Google Gemini Chat Model5",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\"cancel\", \"clarify\"]\n    },\n    \"row_number\": { \"type\": \"integer\" },\n    \"service\": { \"type\": \"string\" },\n    \"datetime\": { \"type\": \"string\" },\n    \"technician\": { \"type\": \"string\" },\n    \"employee_id\": { \"type\": \"string\" },\n    \"message\": { \"type\": \"string\" }\n  },\n  \"required\": [\"action\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        4688,
        3952
      ],
      "id": "fcb576f8-c335-4979-ab9e-2ec14a94bd13",
      "name": "Structured Output Parser6"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "cancel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "837769ec-c3e6-4098-8474-787b782a0dc5"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "cancel"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7d44732b-f948-4769-998f-281f95d4f88e",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "clarify",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "clarify"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        4896,
        3696
      ],
      "id": "bb36f201-6050-4c22-b03c-5e4b13ef4c96",
      "name": "Switch2"
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// NODE: Calculate Blocked Time to Remove\n// PURPOSE: Convert cancel data to Employee Availability format for removal\n// ================================================================\n\n// Get the booking being canceled from cancel_agent output\nconst cancelData = $('Switch2').first().json.output;\n\n// Parse the datetime from booking (format: \"1/6/2026 15:00:00\")\nconst bookingTime = cancelData.datetime;\nconst employeeID = cancelData.employee_id;\n\n// Parse date and time\nconst [datePart, timePart] = bookingTime.split(' ');\nconst [month, day, year] = datePart.split('/');\nconst [hour, minute] = timePart.split(':');\n\n// Create date string for match key (YYYY-MM-DD)\nconst dateStr = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n\n// Calculate start time in local format\nconst hourNum = parseInt(hour);\nconst minuteNum = parseInt(minute);\nconst period = hourNum >= 12 ? 'PM' : 'AM';\nlet displayHour = hourNum > 12 ? hourNum - 12 : hourNum;\nif (displayHour === 0) displayHour = 12;\n\nconst startTimeFormatted = `${displayHour}:${String(minuteNum).padStart(2, '0')} ${period}`;\n\n// Get duration from userBookings to calculate end time\nconst userflag = $('get_userflag_all').first().json.userflag;\nconst bookings = JSON.parse(userflag.userBookings || '[]');\nconst booking = bookings.find(b => b.row_number === cancelData.row_number);\n\n// Calculate end time using duration (default 45 min if not found)\nconst durationMinutes = booking?.duration || 45;\n\nlet endHour = hourNum;\nlet endMinute = minuteNum + durationMinutes;\nif (endMinute >= 60) {\n  endHour += Math.floor(endMinute / 60);\n  endMinute = endMinute % 60;\n}\nconst endPeriod = endHour >= 12 ? 'PM' : 'AM';\nlet endDisplayHour = endHour > 12 ? endHour - 12 : endHour;\nif (endDisplayHour === 0) endDisplayHour = 12;\n\nconst endTimeFormatted = `${endDisplayHour}:${String(endMinute).padStart(2, '0')} ${endPeriod}`;\n\nconst blockedTimeToRemove = `${startTimeFormatted}-${endTimeFormatted}`;\nconst matchKey = `${dateStr}_${employeeID}`;\n\n// Format date for confirmation message\nfunction formatDateForDisplay(dateString) {\n  const date = new Date(dateString + 'T12:00:00');\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', \n                  'July', 'August', 'September', 'October', 'November', 'December'];\n  return `${days[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}`;\n}\n\nconst dateFormatted = formatDateForDisplay(dateStr);\n\n// Get Calendar Event ID from the full booking data\nconst calendarEventId = booking?.['Calendar Event ID'] || null;\n\nreturn [{\n  json: {\n    matchKey,\n    blockedTimeToRemove,\n    dateStr,\n    employeeID,\n    row_number: cancelData.row_number,\n    service: cancelData.service,\n    technician: cancelData.technician,\n    startTime: startTimeFormatted,\n    dateFormatted,\n    bookingTime: cancelData.datetime,\n    calendarEventId\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5456,
        3680
      ],
      "id": "d93d18d0-0702-4c16-8ce9-3a4ffe1a2009",
      "name": "Calculate Blocked Time to Remove"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Match Key",
              "lookupValue": "={{ $json.matchKey }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5648,
        3680
      ],
      "id": "d34eeea4-73f1-48d6-9e38-3bcb7badb29e",
      "name": "Read Employee Availability Row1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const toRemove = $('Calculate Blocked Time to Remove').first().json.blockedTimeToRemove;\nconst currentBlocked = $('Read Employee Availability Row1').first().json['Blocked Times'];\nconst matchKey = $('Calculate Blocked Time to Remove').first().json.matchKey;\n\nif (!currentBlocked || currentBlocked.trim() === '') {\n  // Nothing to remove\n  return [{ json: { matchKey, updatedBlockedTimes: '' } }];\n}\n\n// Split into array, trim each, filter out the one to remove\nconst blockedArray = currentBlocked.split(',').map(t => t.trim());\nconst filteredArray = blockedArray.filter(t => t !== toRemove);\n\n// Rejoin with proper formatting\nconst updatedBlockedTimes = filteredArray.join(', ');\n\nreturn [{\n  json: {\n    matchKey,\n    updatedBlockedTimes,\n    removed: toRemove,\n    debug: {\n      before: currentBlocked,\n      after: updatedBlockedTimes\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5824,
        3680
      ],
      "id": "33b4f698-bb0b-4925-815f-044128487897",
      "name": "Remove Blocked Time"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Blocked Times": "={{ $json.updatedBlockedTimes }}",
            "Match Key": "={{ $json.matchKey }}"
          },
          "matchingColumns": [
            "Match Key"
          ],
          "schema": [
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Match Key",
              "displayName": "Match Key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Employee Name",
              "displayName": "Employee Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Working Hours",
              "displayName": "Working Hours",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Blocked Times",
              "displayName": "Blocked Times",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5984,
        3680
      ],
      "id": "357b5a5c-fc8d-47f2-9189-346030d6f34c",
      "name": "Update Employee Availability",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=0"
        },
        "startIndex": "={{ $('Calculate Blocked Time to Remove').first().json.row_number }}"
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        6160,
        3680
      ],
      "id": "23bab314-bdb4-440f-a524-ed57a87700fd",
      "name": "Delete Booking Row",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Calculate Blocked Time to Remove').first().json.service }} on {{ $('Calculate Blocked Time to Remove').first().json.dateFormatted }} at {{ $('Calculate Blocked Time to Remove').first().json.startTime }} has been canceled âœ“\n\nIs there anything else I can help you with?",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        6512,
        3680
      ],
      "id": "cb0d3b2d-5668-4965-acb5-579f0ac73de8",
      "name": "Send Cancel Confirmation",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('cancel_agent').item.json.output.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5168,
        3824
      ],
      "id": "d609a3b6-1028-409b-aa3e-52e80d3327bf",
      "name": "Cancel Clarification Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "canBook userBookings hasBookings active_intent"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        6688,
        3680
      ],
      "id": "77b5609d-1ce0-4d64-a0a6-e3951a393e1c",
      "name": "Post Cancellation Flag Update",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User: {{ $('Set Initial Data').first().json.messageBody }}\nToday: {{ $now.setZone('America/Cancun').toFormat('cccc, MMMM d, yyyy') }}\n\nAppointments (user sees these numbered 1, 2, 3... in order):\n{{ $('get_userflag_all').first().json.userflag.userBookings }}\n\nIMPORTANT: User's number = position in this array (1-indexed). \"1\" = first appointment, \"2\" = second, etc. Do NOT match against row_number.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "==Update Selector Agent\n**RESPOND IN ENGLISH ONLY.**\n\nYour ONLY job: Identify WHICH appointment the user wants to update.\n\n## WHAT TO LOOK FOR\nMatch the user's message to one of their appointments using:\n- Day references: \"Monday\", \"the 15th\", \"tomorrow\"\n- Time references: \"2pm appointment\", \"the 1 o'clock one\"\n- Service references: \"my manicure\", \"the pedicure booking\"\n- Technician references: \"my appointment with Sarah\"\n- List selection: \"1\", \"the first one\", \"number 2\"\n\n## IMPORTANT: IGNORE CHANGE REQUESTS\nThe user may include what they want to change TO in the same message.\n**Completely ignore this part.** Only identify WHICH appointment.\n\nExamples - only use the FIRST part to identify:\n- \"update my 1pm jan 15 appointment to 1:30\" â†’ identify using \"1pm jan 15\"\n- \"change my manicure to a deluxe\" â†’ identify using \"manicure\"\n- \"move my Thursday booking to Friday\" â†’ identify using \"Thursday\"\n\nThe change request will be handled in a separate step.\n\n## DECISION LOGIC\n\n1. Generic \"update my appointment\" with no specifics:\n   - 1 appointment â†’ status: \"identified\"\n   - Multiple â†’ status: \"needs_clarification\"\n\n2. User provides identifying details:\n   - Exactly 1 match â†’ status: \"identified\"\n   - Multiple or no matches â†’ status: \"needs_clarification\"\n\n3. User selects from a list (\"1\", \"first one\"):\n   - Match found â†’ status: \"identified\"\n\n## OUTPUT FORMAT\n\n**When identified:**\n{\n  \"status\": \"identified\",\n  \"rowNumber\": 2,\n  \"service\": \"Classic Manicure & Pedicure\",\n  \"datetime\": \"2026-01-15T19:00:00.000Z\",\n  \"technician\": \"Sarah Johnson\",\n  \"employeeID\": \"EMP001\",\n  \"dateDisplay\": \"Thursday, January 15\",\n  \"timeDisplay\": \"2:00 PM\",\n  \"allAppointments\": []\n}\n\n**When clarification needed:**\n{\n  \"status\": \"needs_clarification\",\n  \"rowNumber\": 0,\n  \"service\": \"\",\n  \"datetime\": \"\",\n  \"technician\": \"\",\n  \"employeeID\": \"\",\n  \"dateDisplay\": \"\",\n  \"timeDisplay\": \"\",\n  \"allAppointments\": [\n    {\n      \"rowNumber\": 2,\n      \"service\": \"Classic Manicure & Pedicure\",\n      \"datetime\": \"2026-01-15T19:00:00.000Z\",\n      \"technician\": \"Sarah Johnson\",\n      \"dateDisplay\": \"Thursday, January 15\",\n      \"timeDisplay\": \"2:00 PM\"\n    }\n  ]\n}\n\n## DATETIME HANDLING\nInput from Sheets is Cancun local time.\nConvert to UTC for datetime field (add 5 hours).\nKeep dateDisplay and timeDisplay in local format for user display.\n\n\nCRITICAL: When the user replies with a number, it refers to the POSITION in the list shown to them (1 = first appointment listed, 2 = second, etc.), NOT the row_number field. Select the Nth appointment from the array based on the user's number, where 1 = first item in the array, 2 = second item, etc.\n\n## RULES\n- Output ONLY valid JSON, nothing else\n- IGNORE any change requests in the message\n- Use EXACT values from the appointments data\n- Never output null - use \"\" or 0 or []\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        6688,
        2560
      ],
      "id": "b88f46fe-e305-40fd-9b17-8bdd713dd6ba",
      "name": "Update Selector Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"required\": [\"status\"],\n  \"additionalProperties\": true,\n  \"properties\": {\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\"identified\", \"needs_clarification\"]\n    },\n    \"rowNumber\": { \"type\": \"integer\" },\n    \"service\": { \"type\": \"string\" },\n    \"datetime\": { \"type\": \"string\" },\n    \"technician\": { \"type\": \"string\" },\n    \"employeeID\": { \"type\": \"string\" },\n    \"dateDisplay\": { \"type\": \"string\" },\n    \"timeDisplay\": { \"type\": \"string\" },\n    \"allAppointments\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"additionalProperties\": true\n      }\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        6912,
        2832
      ],
      "id": "7ae6a884-c2e2-47a3-b169-f9c75b316c2f",
      "name": "Structured Output Parser7"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        6624,
        2832
      ],
      "id": "4a38f842-58db-4593-b112-eafe497466c1",
      "name": "Google Gemini Chat Model6",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.ambiguousContext ? $json.ambiguousContext + '\\n\\n' : '' }}Extract CHANGES from user message. Output JSON only.\n\nORIGINAL APPOINTMENT (compare against this - only extract DIFFERENCES):\n- Service: {{ JSON.parse($('get_userflag_all').first().json.userflag.bookingModification || '{}').originalAppointment?.service || 'NOT SET' }}\n- Date/Time: {{ JSON.parse($('get_userflag_all').first().json.userflag.bookingModification || '{}').originalAppointment?.dateDisplay || 'NOT SET' }} at {{ JSON.parse($('get_userflag_all').first().json.userflag.bookingModification || '{}').originalAppointment?.timeDisplay || 'NOT SET' }}\n- Technician: {{ JSON.parse($('get_userflag_all').first().json.userflag.bookingModification || '{}').originalAppointment?.technician || 'NOT SET' }}\n\nUser's Message: {{ $json.enhancedMessage || $('Set Initial Data').first().json.messageBody }}\n\nToday: {{ $now.setZone('America/Cancun').toFormat('cccc, MMMM d, yyyy') }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=## â›” MANDATORY OUTPUT FORMAT - READ FIRST\nYou MUST output ONLY a raw JSON object. Nothing else.\nCORRECT FORMAT:\n{\"service\": {...}, \"datetime\": {...}, \"technician\": {...}}\nFORBIDDEN (will crash the system):\nâŒ {\"action\": \"parse\", \"text\": [...]}\nâŒ {\"action\": \"tool_call\", ...}  \nâŒ ```json ... ```\nâŒ Any text before or after the JSON\nAfter you finish calling tools, immediately output the JSON object.\n---\n\nUpdate Extractor Agent\nExtract CHANGES from user message. Output JSON only.\n\n## CRITICAL RULE: COMPARE AGAINST ORIGINAL\nYou receive the ORIGINAL APPOINTMENT being modified. \nONLY extract values that are DIFFERENT from the original.\nIf user mentions the same date/time/service/technician as the original, that's IDENTIFICATION, not a change - IGNORE IT.\n\n## BUSINESS RULES\nHours: Monday-Saturday, 9 AM-8 PM. NO SUNDAYS.\nTimezone: America/Cancun (UTC-5, no DST)\nToday: {{ $now.setZone('America/Cancun').toFormat('yyyy-MM-dd') }} ({{ $now.setZone('America/Cancun').toFormat('EEEE') }})\nTomorrow: {{ $now.setZone('America/Cancun').plus({ days: 1 }).toFormat('yyyy-MM-dd') }}\nCurrent Year: {{ $now.setZone('America/Cancun').toFormat('yyyy') }}\nNext Year: {{ $now.setZone('America/Cancun').plus({ years: 1 }).toFormat('yyyy') }}\n\n## 1. SERVICE EXTRACTION\n**Trigger:** User wants a DIFFERENT service than original\n\nSteps:\n1. CALL list_services tool\n2. Match user input (fuzzy OK, case-insensitive)\n3. Compare to original - only extract if DIFFERENT\n\nMatched & DIFFERENT from original:\n```json\n\"service\": { \"validated\": true, \"values\": { \"serviceID\": \"SVC002\", \"serviceName\": \"Deluxe Spa\", \"serviceDuration\": \"90\", \"servicePrice\": \"145\", \"allowedEmployees\": \"ALL or EMP005\" }}\n```\n\nNo match:\n```json\n\"service\": { \"validated\": false, \"error\": \"no_match\", \"rawInput\": \"what user typed\" }\n```\n\nAMBIGUOUS match (single user input matches multiple services - e.g., \"manicure\" appears in multiple service names):\nDo NOT auto-select one\nOutput: \n```json \n\"service\": { \"validated\": false, \"error\": \"ambiguous\", \"rawInput\": \"what user typed\", \"possibleMatches\": [\"Full Service Name 1 ($price)\", \"Full Service Name 2 ($price)\"] } \n```\n\nâš ï¸ If user mentions MULTIPLE services and only SOME are ambiguous:\n- Set validated: true (because we have at least one valid service) \n- Put the valid service(s) in values \n- Add ambiguousService field with the unclear input \n- Add possibleMatches array with the matching service names \n\nExample: \nUser says \"add manicure clasico y dermapen\" \n- \"dermapen\" matches exactly â†’ put in values \n- \"manicure clasico\" matches 2 services â†’ ambiguous \n\nOutput: \n```json\n\"service\": { \n  \"validated\": true, \n  \"action\": \"add\",\n  \"values\": { \n    \"serviceID\": \"53\", \n    \"serviceName\": \"Dermapen\", \n    \"serviceDuration\": \"35\", \n    \"servicePrice\": \"1300\", \n    \"allowedEmployees\": \"EMP005\" \n  }, \n  \"ambiguousService\": \"manicure clasico\", \n  \"possibleMatches\": [\"Manicure clasico con gel ($440)\", \"Manicure clasico con esmalte ($340)\"] \n}\n\n```\n## DISAMBIGUATION RESOLUTION\nWhen user is CLARIFYING a previous ambiguous service:\n- The input may be a COMBINED phrase like \"manicure clasico gel\" (previous ambiguous + clarification)\n- Match the FULL COMBINED phrase against services, not just the last word\n- \"manicure clasico gel\" â†’ match \"Manicure clasico con gel\" (exact match wins)\n- \"manicure clasico esmalte\" â†’ match \"Manicure clasico con esmalte\"\n\nPriority:\n1. Try matching the FULL input phrase first\n2. If no exact match, try fuzzy match on full phrase\n3. Only if full phrase fails, consider it a new ambiguous input\n\n\n\nNot mentioned OR same as original:\n```json\n\"service\": { \"validated\": false, \"error\": \"\", \"rawInput\": \"\" }\n```\n\n## 1B. SERVICE MODIFICATION ACTION\n\nDetect HOW user wants to modify services:\n\n### ACTION: REPLACE (default - user wants different service)\nKeywords: \"change to\", \"switch to\", \"instead\", \"quiero X en vez de\"\nExample: \"change to deluxe\", \"I want express instead\"\nâ†’ Extract new service, action = \"replace\"\n\n### ACTION: ADD (user wants to keep original AND add more)\nKeywords: \"add\", \"also\", \"include\", \"plus\", \"and also\", \"agregar\", \"tambiÃ©n\", \"y tambiÃ©n\"\nExample: \"add a pedicure\", \"also want manicure\", \"agregar el express\"\nâ†’ Extract additional service, action = \"add\"\n\n### ACTION: REMOVE (user wants to remove one service from multi-service booking)\nKeywords: \"remove\", \"take off\", \"without\", \"just the\", \"only the\", \"quitar\", \"sin\", \"solo el/la\"\nExample: \"remove the pedicure\", \"just the manicure\", \"quitar el pedicure\"\nâ†’ Extract service to remove, action = \"remove\"\n\n**CRITICAL:** Default is \"replace\" if no add/remove keywords detected.\n\n### Output Format for ADD:\n```json\n\"service\": { \n  \"validated\": true, \n  \"action\": \"add\",\n  \"values\": { \"serviceID\": \"SVC002\", \"serviceName\": \"Classic Manicure & Pedicure\", \"serviceDuration\": \"60\", \"servicePrice\": \"85\" }\n}\n```\n\n### Output Format for REMOVE:\n```json\n\"service\": { \n  \"validated\": true, \n  \"action\": \"remove\",\n  \"removeServiceID\": \"SVC002\",\n  \"removeServiceName\": \"Classic Manicure & Pedicure\"\n}\n```\n\n### Output Format for REPLACE (default):\n```json\n\"service\": { \n  \"validated\": true, \n  \"action\": \"replace\",\n  \"values\": { \"serviceID\": \"SVC002\", \"serviceName\": \"...\", \"serviceDuration\": \"...\", \"servicePrice\": \"...\" }\n}\n```\n\n## 2. DATETIME EXTRACTION\n**Trigger:** User wants a DIFFERENT date/time than original\n\n**CRITICAL: When validated=true, you MUST include \"type\" AND the value field.**\n\n### RELATIVE DATE RESOLUTION\nResolve relative terms to actual dates:\n- \"tomorrow\" / \"maÃ±ana\" â†’ today + 1 day\n- \"next Monday\" / \"prÃ³ximo lunes\" â†’ following week's Monday\n- \"[weekday]\" alone â†’ nearest upcoming occurrence\n- Month/day without year â†’ if passed this year, use next year\n\n### PATH A: TIME ONLY (most common for updates)\nUser says: \"1:30\", \"a las 2\", \"para las 3pm\", \"at 4\", \"to 2:30\"\nâ†’ Convert to 24hr, validate 9AM-8PM\n\n```json\n\"datetime\": { \"validated\": true, \"type\": \"partial_time\", \"partialTime\": \"13:30\" }\n```\n\n### PATH B: DATE ONLY\nUser says: \"tomorrow\", \"maÃ±ana\", \"Monday\", \"el viernes\"\nâ†’ Resolve to YYYY-MM-DD, validate Mon-Sat\n\n```json\n\"datetime\": { \"validated\": true, \"type\": \"partial_date\", \"partialDate\": \"2026-01-20\" }\n```\n\n### PATH C: COMPLETE DATE & TIME\nUser says: \"tomorrow at 3pm\", \"maÃ±ana a las 3\"\nâ†’ Convert to UTC (add 5 hours), validate both\n\n```json\n\"datetime\": { \"validated\": true, \"type\": \"complete\", \"savedDatetime\": \"2026-01-20T20:00:00.000Z\" }\n```\n\n### INVALID\nSunday or outside 9AM-8PM:\n```json\n\"datetime\": { \"validated\": false, \"error\": \"sunday\" | \"outside_hours\", \"rawInput\": \"domingo\" }\n```\n\n### NOT MENTIONED or SAME AS ORIGINAL\n```json\n\"datetime\": { \"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\" }\n```\n\n## 3. TECHNICIAN EXTRACTION\n**Trigger:** User wants a DIFFERENT technician than original\n\nSteps:\n1. CALL employee_list tool\n2. Match name (exact, first name, partial)\n3. Compare to original - only extract if DIFFERENT\n\nMatched & DIFFERENT:\n```json\n\"technician\": { \"validated\": true, \"type\": \"specific\", \"values\": { \"employeeID\": \"EMP002\", \"employeeName\": \"David Martinez\" }}\n```\n\n\"Anyone\" / \"next available\" / \"quien sea\":\n```json\n\"technician\": { \"validated\": true, \"type\": \"next_available\", \"values\": { \"employeeID\": \"NEXT_AVAILABLE\", \"employeeName\": \"Next Available\" }}\n```\n\nNot found:\n```json\n\"technician\": { \"validated\": false, \"error\": \"not_found\", \"rawInput\": \"Bob\" }\n```\n\nNot mentioned OR same as original:\n```json\n\"technician\": { \"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\" }\n```\n\n## EXAMPLES\n\n**Example 1: User mentions original datetime (NOT a change)**\nOriginal: Jan 15 at 1:00 PM\nUser: \"change my jan 15 1pm appointment to 1:30\"\nâ†’ \"jan 15 1pm\" matches original = IGNORE\nâ†’ \"1:30\" is different = EXTRACT\nOutput: datetime.validated=true, type=\"partial_time\", partialTime=\"13:30\"\n\n**Example 2: User only provides change**\nOriginal: Jan 15 at 1:00 PM with David\nUser: \"move it to 3pm\"\nâ†’ \"3pm\" is different = EXTRACT\nOutput: datetime.validated=true, type=\"partial_time\", partialTime=\"15:00\"\n\n**Example 3: User mentions technician that's same as original**\nOriginal: with Sarah Johnson\nUser: \"I want to keep Sarah but change to 2pm\"\nâ†’ \"Sarah\" same as original = IGNORE\nâ†’ \"2pm\" is different = EXTRACT\nOutput: technician.validated=false, datetime.validated=true\n\n## DISAMBIGUATION EXAMPLE\nWhen input is a clarification like \"manicure clasico gel\" (combined from previous ambiguous + user reply):\n1. Call list_services\n2. Match \"manicure clasico gel\" â†’ \"Manicure clasico con gel\" (fuzzy match)\n3. Output as validated service with action \"replace\"\n\nComplete output:\n{\"service\": {\"validated\": true, \"action\": \"replace\", \"error\": \"\", \"rawInput\": \"manicure clasico gel\", \"removeServiceID\": \"\", \"removeServiceName\": \"\", \"ambiguousService\": \"\", \"possibleMatches\": [], \"values\": {\"serviceID\": \"0001\", \"serviceName\": \"Manicure clasico con gel\", \"serviceDuration\": \"60\", \"servicePrice\": \"440\", \"allowedEmployees\": \"ALL\"}}, \"datetime\": {\"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\", \"savedDatetime\": \"\", \"partialDate\": \"\", \"partialTime\": \"\"}, \"technician\": {\"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\", \"values\": {\"employeeID\": \"\", \"employeeName\": \"\"}}}\n\n## OUTPUT FORMAT\nALWAYS output ALL three objects (service, datetime, technician) with ALL their fields.\nUse \"\" for empty strings, [] for empty arrays, false for unused booleans.\nNEVER omit any field. NEVER use null. The parser will reject incomplete output.\n\nWhen service NOT changed:\n\"service\": {\"validated\": false, \"action\": \"\", \"error\": \"\", \"rawInput\": \"\", \"removeServiceID\": \"\", \"removeServiceName\": \"\", \"ambiguousService\": \"\", \"possibleMatches\": [], \"values\": {\"serviceID\": \"\", \"serviceName\": \"\", \"serviceDuration\": \"\", \"servicePrice\": \"\", \"allowedEmployees\": \"\"}}\n\nWhen datetime NOT changed:\n\"datetime\": {\"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\", \"savedDatetime\": \"\", \"partialDate\": \"\", \"partialTime\": \"\"}\n\nWhen technician NOT changed:\n\"technician\": {\"validated\": false, \"error\": \"\", \"type\": \"\", \"rawInput\": \"\", \"values\": {\"employeeID\": \"\", \"employeeName\": \"\"}}\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        6768,
        1680
      ],
      "id": "e2ae270c-8f86-40e7-8495-3352fead8f7e",
      "name": "Update Extractor Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        6656,
        2000
      ],
      "id": "13ee249c-f8f5-4895-960b-8e15c6e0bc1d",
      "name": "Google Gemini Chat Model7",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Get list of available nail services and their prices from the Services sheet.",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1786453814,
          "mode": "list",
          "cachedResultName": "Services (admin)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=1786453814"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.5,
      "position": [
        6976,
        2000
      ],
      "id": "7a141b1c-6635-4dae-8442-ba62a195e1de",
      "name": "list_services1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        6800,
        2000
      ],
      "id": "86250b28-1231-4370-a19d-81b2202420b0",
      "name": "employee_list2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"service\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"action\": { \"type\": \"string\" },\n        \"error\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"removeServiceID\": { \"type\": \"string\" },\n        \"removeServiceName\": { \"type\": \"string\" },\n        \"ambiguousService\": { \"type\": \"string\" },\n        \"possibleMatches\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" }\n        },\n        \"values\": {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      },\n      \"additionalProperties\": true\n    },\n    \"datetime\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"error\": { \"type\": \"string\" },\n        \"type\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"savedDatetime\": { \"type\": \"string\" },\n        \"partialDate\": { \"type\": \"string\" },\n        \"partialTime\": { \"type\": \"string\" }\n      },\n      \"additionalProperties\": true\n    },\n    \"technician\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"validated\": { \"type\": \"boolean\" },\n        \"error\": { \"type\": \"string\" },\n        \"type\": { \"type\": \"string\" },\n        \"rawInput\": { \"type\": \"string\" },\n        \"values\": {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      },\n      \"additionalProperties\": true\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        7120,
        1984
      ],
      "id": "ca7cdab5-7554-4000-85f0-0a211a21ac7e",
      "name": "Structured Output Parser8"
    },
    {
      "parameters": {
        "jsCode": "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// UPDATE STATE MERGER\n// Processes Phase 2 extraction, compares to saved, updates Redis\n// Handles both camelCase and Google Sheets column name formats\n// NOW SUPPORTS: ADD, REMOVE, REPLACE service actions\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nlet extraction = {};\ntry {\n  const rawOutput = $('Update Extractor Agent').first().json.output;\n  if (typeof rawOutput === 'string') {\n    const cleaned = rawOutput.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n    extraction = JSON.parse(cleaned);\n  } else {\n    extraction = rawOutput || {};\n  }\n} catch (e) {\n  extraction = {};\n}\n\n// If extraction failed but we had ambiguous context, try to resolve deterministically\nif ((!extraction || !extraction.service || extraction.service.validated !== true) && \n    $('Prep Update Extractor').first().json.hadAmbiguousContext) {\n  \n  const prepData = $('Prep Update Extractor').first().json;\n  const enhancedMsg = prepData.enhancedMessage || '';\n  \n  // Try to find the service in list_services using the enhanced message\n  let serviceRows;\n  try {\n    serviceRows = $('list_services1').first().json;\n  } catch(e) {\n    serviceRows = null;\n  }\n  \n  if (serviceRows) {\n    // The list_services tool was called - check its data for a match\n    // This is a deterministic fallback when AI parsing fails\n  }\n}\n\nif (!extraction || typeof extraction !== 'object') {\n  return [{\n    json: {\n      mod: {},\n      proposedChanges: {},\n      changedFields: [],\n      hasChanges: false,\n      hasNewChanges: false,\n      validationErrors: [{field: 'parsing', error: 'Could not process your request'}],\n      hasErrors: true,\n      phone: $('Set Initial Data').first().json.userPhoneNumber\n    }\n  }];\n}\n\nlet mixedChoiceRedirect = false;\ntry {\n  const redirectData = $('Redirect to Update Flow').first().json;\n  if (redirectData && redirectData.fromMixedChoice) {\n    mixedChoiceRedirect = true;\n  }\n} catch (e) {}\n\nlet redis = $('get_userflag_all').first().json.userflag || {};\n\nif (mixedChoiceRedirect) {\n  const rd = $('Redirect to Update Flow').first().json;\n  redis.serviceID = rd.serviceID;\n  redis.serviceName = rd.serviceName;\n  redis.serviceDuration = rd.serviceDuration;\n  redis.servicePrice = rd.servicePrice;\n  redis.allowedEmployees = rd.allowedEmployees;\n  if (rd.bookingModification) {\n    redis.bookingModification = rd.bookingModification;\n  }\n}\n\n\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Get existing bookingModification\nlet mod;\ntry {\n  mod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  mod = {};\n}\n\n// Initialize if needed\nif (!mod.proposedChanges) mod.proposedChanges = {};\nif (!mod.changedFields) mod.changedFields = [];\n\nconst hasValue = (v) => v && v !== '' && v !== null && v !== undefined;\nconst validationErrors = [];\nlet hasNewChanges = false;\n\n// Get original appointment details for comparison\nconst origDatetime = mod.originalAppointment?.datetime || '';\nconst origDate = origDatetime ? origDatetime.split('T')[0] : '';\nconst origEmployeeID = mod.originalAppointment?.employeeID || '';\n\n// Helper: Check if field should be processed (validated OR has rawInput)\nconst shouldProcess = (field) => {\n  return field && (field.validated === true || (field.rawInput && field.rawInput !== ''));\n};\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PROCESS SERVICE (with ADD/REMOVE/REPLACE support)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nif (shouldProcess(extraction.service)) {\n  if (extraction.service.validated === true) {\n    const action = extraction.service.action || 'replace';\n    \n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // ACTION: ADD - Combine original + new service\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    if (action === 'add' && extraction.service.values) {\n      const vals = extraction.service.values;\n      const orig = mod.originalAppointment || {};\n      const currentChanges = mod.proposedChanges || {};\n      \n      // Use existing proposedChanges first (if service was already modified), then original\n      const origServiceID = currentChanges.serviceID || orig.serviceID || '';\n      const origServiceName = currentChanges.serviceName || orig.service || '';\n      const origServiceDuration = currentChanges.serviceDuration || orig.serviceDuration || '60';\n      const origServicePrice = currentChanges.servicePrice || orig.servicePrice || '0';\n      const origAllowed = currentChanges.allowedEmployees || orig.allowedEmployees || 'ALL';\n      \n      // Get new service data\n      const newServiceID = vals.serviceID || '';\n      const newServiceName = vals.serviceName || '';\n      const newServiceDuration = vals.serviceDuration || '60';\n      const newServicePrice = vals.servicePrice || '0';\n      const newAllowed = vals.allowedEmployees || 'ALL';\n      \n      // Check if service already exists (prevent duplicates)\n      const existingIDs = origServiceID.split(',').map(s => s.trim()).filter(Boolean);\n      if (!existingIDs.includes(newServiceID)) {\n        // Combine services - filter out empty values to prevent leading commas\n        mod.proposedChanges.serviceID = [origServiceID, newServiceID].filter(Boolean).join(',');\n        mod.proposedChanges.serviceName = [origServiceName, newServiceName].filter(Boolean).join(', ');\n        mod.proposedChanges.serviceDuration = [origServiceDuration, newServiceDuration].filter(Boolean).join(',');\n        mod.proposedChanges.servicePrice = [origServicePrice, newServicePrice].filter(Boolean).join(',');\n        \n        // Combine allowedEmployees with pipe separator\n        mod.proposedChanges.allowedEmployees = [origAllowed, newAllowed].filter(Boolean).join('|');\n\n         if (!mod.changedFields.includes('service')) {\n          mod.changedFields.push('service');\n        }\n        hasNewChanges = true;\n        mod.availabilityConfirmed = false;\n      }\n    }\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // ACTION: REMOVE - Remove service from multi-service booking\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    else if (action === 'remove') {\n      const orig = mod.originalAppointment || {};\n      const origServiceID = orig.serviceID || '';\n      const origServiceName = orig.service || '';\n      const origServiceDuration = orig.serviceDuration || '45';\n      const origServicePrice = orig.servicePrice || '0';\n      \n      // Parse into arrays\n      const serviceIDs = origServiceID.split(',').map(s => s.trim()).filter(s => s);\n      const serviceNames = origServiceName.split(',').map(s => s.trim()).filter(s => s);\n      const serviceDurations = origServiceDuration.split(',').map(s => s.trim()).filter(s => s);\n      const servicePrices = origServicePrice.split(',').map(s => s.trim()).filter(s => s);\n      const origAllowedEmployees = orig.allowedEmployees || 'ALL';\n\nconst allowedEmployeesArr = origAllowedEmployees ? origAllowedEmployees.split('|').map(s => s.trim()).filter(s => s) : [];\n      \n      // Check if this is a single-service booking\n      if (serviceNames.length <= 1) {\n        // SINGLE SERVICE - Route to cancel flow\n        mod.routeToCancel = true;\n        mod.cancelReason = 'single_service_removal';\n        mod.cancelMessage = \"To remove your only service, you'll need to cancel the appointment. Would you like to cancel instead?\";\n        hasNewChanges = true;\n      } else {\n        // MULTI-SERVICE - Remove the specified service\n        const removeTarget = extraction.service.removeServiceName || extraction.service.removeServiceID || '';\n        \n        // Find index of service to remove (fuzzy match on name or exact match on ID)\n        let removeIndex = -1;\n        \n        // Try exact ID match first\n        if (extraction.service.removeServiceID) {\n          removeIndex = serviceIDs.findIndex(id => id === extraction.service.removeServiceID);\n        }\n        \n        // Fall back to fuzzy name match\n        if (removeIndex === -1 && removeTarget) {\n          removeIndex = serviceNames.findIndex(name => \n            name.toLowerCase().includes(removeTarget.toLowerCase()) ||\n            removeTarget.toLowerCase().includes(name.toLowerCase().split(' ')[0]) // Match first word\n          );\n        }\n        \n        if (removeIndex >= 0) {\n          // Remove from all arrays at the same index\n          serviceIDs.splice(removeIndex, 1);\n          serviceNames.splice(removeIndex, 1);\n          serviceDurations.splice(removeIndex, 1);\n          servicePrices.splice(removeIndex, 1);\n\n          if (allowedEmployeesArr.length > removeIndex) {\n            allowedEmployeesArr.splice(removeIndex, 1);\n          }\n          \n          // Update proposed changes\n          mod.proposedChanges.serviceID = serviceIDs.join(',');\n          mod.proposedChanges.serviceName = serviceNames.join(', ');\n          mod.proposedChanges.serviceDuration = serviceDurations.join(',');\n          mod.proposedChanges.servicePrice = servicePrices.join(',');\n          mod.proposedChanges.allowedEmployees = allowedEmployeesArr.join('|');\n          \n          if (!mod.changedFields.includes('service')) {\n            mod.changedFields.push('service');\n          }\n          hasNewChanges = true;\n          mod.availabilityConfirmed = false; // Duration changed, need recheck\n        } else {\n          validationErrors.push({\n            field: 'service',\n            error: 'service_not_found_in_booking',\n            rawInput: removeTarget\n          });\n        }\n      }\n    }\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // ACTION: REPLACE (existing behavior - unchanged)\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    else if (extraction.service.values) {\n      const vals = extraction.service.values;\n      \n      // Handle both camelCase and Google Sheets column names\n      const newServiceID = vals.serviceID || vals['Service ID'] || vals['service_id'] || '';\n      const newServiceName = vals.serviceName || vals['Service Name'] || vals['service_name'] || '';\n      const newServiceDuration = vals.serviceDuration || vals['Duration (min)'] || vals['serviceDuration'] || '';\n      const newServicePrice = vals.servicePrice || vals['Service Price'] || vals['service_price'] || '';\n      \n      if (newServiceID && mod.proposedChanges.serviceID !== newServiceID) {\n        mod.proposedChanges.serviceID = String(newServiceID);\n        mod.proposedChanges.serviceName = String(newServiceName);\n        mod.proposedChanges.serviceDuration = String(newServiceDuration);\n        mod.proposedChanges.servicePrice = String(newServicePrice);\n        mod.proposedChanges.allowedEmployees = String(vals.allowedEmployees);\n        if (!mod.changedFields.includes('service')) {\n          mod.changedFields.push('service');\n        }\n        hasNewChanges = true;\n      }\n    }\n  } else if (extraction.service.error && extraction.service.error !== '') {\n    validationErrors.push({\n      field: 'service',\n      error: extraction.service.error,\n      rawInput: extraction.service.rawInput\n    });\n  }\n}\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// HANDLE AMBIGUOUS SERVICE - Save for next turn + add to validation errors\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// Save ambiguous service info for next turn clarification\nif (extraction.service?.error === 'ambiguous' && extraction.service?.rawInput) {\n  mod.ambiguousService = extraction.service.rawInput;\n} else if (extraction.service?.ambiguousService) {\n  // Partial success - valid service + ambiguous one\n  mod.ambiguousService = extraction.service.ambiguousService;\n} else if (extraction.service?.validated === true && !extraction.service?.ambiguousService) {\n  // Clear ambiguous only if fully resolved\n  mod.ambiguousService = '';\n}\n\n// Add ambiguous to validation errors\nif (extraction.service?.validated === false && extraction.service?.error === 'ambiguous') {\n  validationErrors.push({ \n    field: 'service', \n    error: 'ambiguous',\n    rawInput: extraction.service.rawInput || '',\n    possibleMatches: extraction.service.possibleMatches || []\n  });\n} else if (extraction.service?.ambiguousService) {\n  // Partial success - we have a valid service but also an ambiguous one\n  validationErrors.push({ \n    field: 'service', \n    error: 'ambiguous',\n    rawInput: extraction.service.ambiguousService,\n    possibleMatches: extraction.service.possibleMatches || []\n  });\n}\n\n// Add no_match to validation errors\nif (extraction.service?.validated === false && extraction.service?.error === 'no_match') {\n  validationErrors.push({\n    field: 'service',\n    error: 'no_match',\n    rawInput: extraction.service.rawInput || ''\n  });\n}\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PROCESS DATETIME (unchanged from original)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nif (shouldProcess(extraction.datetime)) {\n  if (extraction.datetime.validated === true) {\n    \n    // SAFETY CHECK: validated=true but no type means LLM returned incomplete data\n    if (!extraction.datetime.type) {\n      // Log but don't error - treat as if nothing was extracted\n    }\n    else if (extraction.datetime.type === 'complete') {\n      const newDatetime = extraction.datetime.savedDatetime;\n      \n      if (!newDatetime) {\n        // Skip - incomplete extraction\n      }\n      else if (newDatetime !== origDatetime && mod.proposedChanges.datetime !== newDatetime) {\n        mod.proposedChanges.datetime = newDatetime;\n        mod.partialDate = null;\n        mod.partialTime = null;\n        if (!mod.changedFields.includes('datetime')) {\n          mod.changedFields.push('datetime');\n        }\n        hasNewChanges = true;\n        mod.availabilityConfirmed = false;\n      }\n    }\n    else if (extraction.datetime.type === 'partial_time') {\n      const newTime = extraction.datetime.partialTime;\n      \n      if (!newTime) {\n        // Skip\n      }\n      else if (mod.partialTime !== newTime) {\n        let dateToUse = null;\n        \n        if (hasValue(mod.partialDate)) {\n          dateToUse = mod.partialDate;\n        } else if (origDate) {\n          dateToUse = origDate;\n        }\n        \n        if (dateToUse) {\n          const localMs = new Date(`${dateToUse}T${newTime}:00`).getTime();\n          const newDatetime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n          \n          if (newDatetime !== origDatetime) {\n            mod.proposedChanges.datetime = newDatetime;\n            mod.partialDate = null;\n            mod.partialTime = null;\n            if (!mod.changedFields.includes('datetime')) {\n              mod.changedFields.push('datetime');\n            }\n            hasNewChanges = true;\n            mod.availabilityConfirmed = false;\n          }\n        } else {\n          mod.partialTime = newTime;\n          hasNewChanges = true;\n        }\n      }\n    }\n    else if (extraction.datetime.type === 'partial_date') {\n      const newDate = extraction.datetime.partialDate;\n      \n      if (!newDate) {\n        // Skip\n      }\n      else if (newDate !== origDate) {\n        if (mod.partialDate !== newDate) {\n          mod.partialDate = newDate;\n          hasNewChanges = true;\n          \n          if (hasValue(mod.partialTime)) {\n            const localMs = new Date(`${newDate}T${mod.partialTime}:00`).getTime();\n            mod.proposedChanges.datetime = new Date(localMs + (5 * 60 * 60 * 1000)).toISOString();\n            mod.partialDate = null;\n            mod.partialTime = null;\n            if (!mod.changedFields.includes('datetime')) {\n              mod.changedFields.push('datetime');\n            }\n            mod.availabilityConfirmed = false;\n          }\n        }\n      }\n    }\n  } else if (extraction.datetime.error && extraction.datetime.error !== '') {\n    validationErrors.push({\n      field: 'datetime',\n      error: extraction.datetime.error,\n      rawInput: extraction.datetime.rawInput,\n      possibleMatches: extraction.service.possibleMatches || []\n    });\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PROCESS TECHNICIAN (unchanged from original)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nif (shouldProcess(extraction.technician)) {\n  if (extraction.technician.validated === true && extraction.technician.values) {\n    const vals = extraction.technician.values;\n    \n    const newEmployeeID = vals.employeeID || vals['Employee ID'] || vals['employee_id'] || '';\n    const newEmployeeName = vals.employeeName || vals['Employee Name'] || vals['employee_name'] || '';\n    \n    if ((newEmployeeID !== origEmployeeID || newEmployeeID === 'NEXT_AVAILABLE') \n        && mod.proposedChanges.employeeID !== newEmployeeID) {\n      mod.proposedChanges.employeeID = String(newEmployeeID);\n      mod.proposedChanges.employeeName = String(newEmployeeName);\n      if (!mod.changedFields.includes('technician')) {\n        mod.changedFields.push('technician');\n      }\n      hasNewChanges = true;\n      mod.availabilityConfirmed = false;\n    }\n  } else if (extraction.technician.error && extraction.technician.error !== '') {\n    validationErrors.push({\n      field: 'technician',\n      error: extraction.technician.error,\n      rawInput: extraction.technician.rawInput\n    });\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// OUTPUT\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nreturn [{\n  json: {\n    mod,\n    proposedChanges: mod.proposedChanges,\n    changedFields: mod.changedFields,\n    partialDate: mod.partialDate,\n    partialTime: mod.partialTime,\n    hasChanges: mod.changedFields.length > 0,\n    hasNewChanges,\n    validationErrors,\n    hasErrors: validationErrors.length > 0,\n    routeToCancel: mod.routeToCancel || false,\n    cancelReason: mod.cancelReason || null,\n    cancelMessage: mod.cancelMessage || null,\n    phone\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7152,
        1664
      ],
      "id": "b5d5ce6a-879f-429a-a9cd-2737555490a5",
      "name": "Update State Merger"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { bookingModification: JSON.stringify($json.mod) } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        7376,
        1664
      ],
      "id": "d3edfa34-65d2-4628-ad89-7ade81327ee2",
      "name": "Store Update Extraction State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// MERGE PHASE 1 & PHASE 2 RESULTS\n// Determines what Phase 3 should do\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\nconst redis = $('get_userflag_all').first().json.userflag || {};\n\n// Get existing bookingModification from Redis\nlet existingMod;\ntry {\n  existingMod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  existingMod = {};\n}\n\n// Check if we skipped Selector (CONTINUE path from Context Switch Identifier)\nlet skippedSelector = false;\ntry {\n  const contextDecision = $('Context Decision').first().json;\n  skippedSelector = contextDecision.output?.decision === 'CONTINUE';\n} catch (e) {\n  skippedSelector = false;\n}\n\n// Get Phase 1 result - either from Selector or from Redis (if skipped)\nlet selectorOutput;\nif (skippedSelector && existingMod.originalAppointment) {\n  const orig = existingMod.originalAppointment;\n  selectorOutput = {\n    status: 'identified',\n    rowNumber: orig.rowNumber,\n    service: orig.service,\n    datetime: orig.datetime,\n    technician: orig.technician,\n    employeeID: orig.employeeID,\n    dateDisplay: orig.dateDisplay,\n    timeDisplay: orig.timeDisplay,\n    serviceDuration: orig.serviceDuration,\n    servicePrice: orig.servicePrice\n  };\n} else {\n  try {\n    selectorOutput = $('Update Selector Agent').first().json.output;\n  } catch (e) {\n    selectorOutput = { status: 'needs_clarification' };\n  }\n}\n\n// Get Phase 2 result (from State Merger - this is the SOURCE OF TRUTH)\nlet extractorResult;\ntry {\n  extractorResult = $('Update State Merger').first().json;\n} catch (e) {\n  extractorResult = { hasChanges: false, hasErrors: false, validationErrors: [] };\n}\n\n// Start with mod from State Merger (it already processed Redis + new extraction)\nlet mod = extractorResult.mod || {};\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// SAFETY FIX: Always ensure originalAppointment has serviceDuration\n// This catches cases where it was saved without duration previously\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nif (mod.originalAppointment && !mod.originalAppointment.serviceDuration) {\n  try {\n    const userBookings = JSON.parse(redis.userBookings || '[]');\n    const matchingBooking = userBookings.find(b => \n      String(b.row_number) === String(mod.originalAppointment.rowNumber)\n    );\n    if (matchingBooking && matchingBooking.duration) {\n      mod.originalAppointment.serviceDuration = String(matchingBooking.duration);\n      mod.originalAppointment.servicePrice = mod.originalAppointment.servicePrice || \n        String(matchingBooking.servicePrice || matchingBooking['Amount'] || 0);\n    }\n  } catch (e) {\n    // Log but don't fail\n    console.log('Failed to lookup serviceDuration from userBookings:', e);\n  }\n}\n// Update mod with Phase 1 result if identified (FLAT STRUCTURE)\nif (selectorOutput.status === 'identified' && selectorOutput.rowNumber) {\n  mod.selectionStatus = 'identified';\n  \n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // CRITICAL: Get duration from userBookings if selector didn't provide it\n  // This is the SOURCE OF TRUTH - calculated from Booking Time/End Time\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  let serviceDuration = selectorOutput.serviceDuration;\n  let servicePrice = selectorOutput.servicePrice;\n  \n  if (!serviceDuration) {\n    try {\n      const userBookings = JSON.parse(redis.userBookings || '[]');\n      const matchingBooking = userBookings.find(b => \n        String(b.row_number) === String(selectorOutput.rowNumber)\n      );\n      if (matchingBooking) {\n        serviceDuration = matchingBooking.duration ? String(matchingBooking.duration) : null;\n        servicePrice = servicePrice || String(matchingBooking.servicePrice || matchingBooking['Amount'] || 0);\n      }\n    } catch (e) {\n      // fallback below\n    }\n  }\n  \n  mod.originalAppointment = {\n    rowNumber: selectorOutput.rowNumber,\n    service: selectorOutput.service,\n    datetime: selectorOutput.datetime,\n    technician: selectorOutput.technician,\n    employeeID: selectorOutput.employeeID,\n    dateDisplay: selectorOutput.dateDisplay,\n    timeDisplay: selectorOutput.timeDisplay,\n    serviceDuration: serviceDuration || null,\n    servicePrice: servicePrice || '0'\n  };\n  mod.allAppointments = null;\n} else if (selectorOutput.status === 'needs_clarification') {\n  if (mod.selectionStatus !== 'identified') {\n    mod.selectionStatus = 'needs_clarification';\n    mod.allAppointments = selectorOutput.allAppointments || [];\n  }\n} else if (selectorOutput.status === 'ambiguous') {\n  if (mod.selectionStatus !== 'identified') {\n    mod.selectionStatus = 'ambiguous';\n    mod.allAppointments = selectorOutput.allAppointments || [];\n  }\n}\n\n// Determine response type\nconst hasAppointment = mod.selectionStatus === 'identified' && mod.originalAppointment;\nconst hasChanges = (mod.changedFields || []).length > 0;\nconst hasErrors = extractorResult.hasErrors;\nconst validationErrors = extractorResult.validationErrors || [];\nconst hasPartialDatetime = !!(mod.partialDate || mod.partialTime);\n\nconst needsAvailabilityCheck = (mod.changedFields || []).some(f => \n  f === 'datetime' || f === 'technician' || f === 'service'\n) && !mod.availabilityConfirmed;\n\nlet responseType;\nlet clarifyType = null;\n\nif (!hasAppointment) {\n  responseType = 'CLARIFY_SELECTION';\n} else if (hasErrors) {\n  responseType = 'VALIDATION_ERROR';\n} else if (!hasChanges && !hasPartialDatetime) {\n  responseType = 'CLARIFY_CHANGES';\n} else if (hasPartialDatetime) {\n  if (mod.partialDate && !mod.partialTime) {\n    clarifyType = 'need_time';\n  } else if (mod.partialTime && !mod.partialDate) {\n    clarifyType = 'need_date';\n  }\n  responseType = 'CLARIFY_DATETIME';\n} else if (needsAvailabilityCheck) {\n  responseType = 'CHECK_AVAILABILITY';\n} else {\n  responseType = 'SHOW_CONFIRMATION';\n}\n\n// Build finalBooking if we have everything\nlet finalBooking = null;\nif (hasAppointment && hasChanges) {\n  const orig = mod.originalAppointment;\n  const changes = mod.proposedChanges || {};\n  \n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // DETERMINE CORRECT DURATION BASED ON WHAT CHANGED:\n  // - If service changed: use NEW service duration (from list_services via Extractor)\n  // - If service NOT changed: use ORIGINAL booking duration (from userBookings)\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  let finalDuration;\n  if (changes.serviceDuration) {\n    // User changed service - use new duration from list_services\n    finalDuration = changes.serviceDuration;\n  } else if (orig.serviceDuration) {\n    // User didn't change service - use original booking's duration\n    finalDuration = orig.serviceDuration;\n  } else {\n    // Fallback: should not happen if Count Bookings fix is applied\n    finalDuration = '45';\n  }\n  \n  finalBooking = {\n    rowNumber: orig.rowNumber,\n    serviceID: changes.serviceID || orig.serviceID,\n    serviceName: changes.serviceName || orig.service,\n    serviceDuration: finalDuration,\n    servicePrice: changes.servicePrice || orig.servicePrice || '0',\n    datetime: changes.datetime || orig.datetime,\n    employeeID: changes.employeeID || orig.employeeID,\n    employeeName: changes.employeeName || orig.technician\n  };\n  mod.finalBooking = finalBooking;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// OUTPUT\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nreturn [{\n  json: {\n    responseType,\n    clarifyType,\n    \n    // Debug info\n    skippedSelector,\n    \n    // Phase 1 data\n    selectionStatus: mod.selectionStatus,\n    originalAppointment: mod.originalAppointment,\n    allAppointments: mod.allAppointments,\n    \n    // Phase 2 data\n    proposedChanges: mod.proposedChanges,\n    changedFields: mod.changedFields || [],\n    hasChanges,\n    partialDate: mod.partialDate,\n    partialTime: mod.partialTime,\n    \n    // Errors\n    validationErrors,\n    hasErrors,\n    \n    // Final\n    finalBooking,\n    needsAvailabilityCheck,\n    mod,\n    phone\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7904,
        1808
      ],
      "id": "e0d5304c-715b-485e-a1fa-ba7c54d58d6e",
      "name": "Merge Extract Phase Results"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { bookingModification: JSON.stringify($json.mod) } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        8112,
        1808
      ],
      "id": "edcf5703-1f33-4e2f-ac35-59bbbf9fd396",
      "name": "Store Merged State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.mergeResult.responseType }}",
                    "rightValue": "=CLARIFY_SELECTION|VALIDATION_ERROR|CLARIFY_CHANGES|CLARIFY_DATETIME",
                    "operator": {
                      "type": "string",
                      "operation": "regex"
                    },
                    "id": "3bf55e75-09c5-40ba-9909-981f07b4d7df"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NEED_CLARIFICATION"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6cdbd73e-c9fc-42c7-9114-aca6a5693889",
                    "leftValue": "={{ $json.mergeResult.responseType }}",
                    "rightValue": "CHECK_AVAILABILITY|SHOW_CONFIRMATION",
                    "operator": {
                      "type": "string",
                      "operation": "regex"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CHECK_AVAILABILITY"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        9120,
        1840
      ],
      "id": "5aa10ecd-d418-4a63-9500-94aec47ac26e",
      "name": "Update Route Switch"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        9584,
        2016
      ],
      "id": "005c7a94-4e5f-4461-b11d-18a2ed55a1e0",
      "name": "Google Gemini Chat Model8",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current User: {{ $('Set Initial Data').first().json.name }}\n\nCurrent Update State:\n- selectionStatus: {{ $json.mergeResult.selectionStatus || 'NOT SET' }}\n- originalAppointment: {{ $json.mergeResult.originalAppointment ? 'Selected: ' + $json.mergeResult.originalAppointment.service + ' on ' + new Date($json.mergeResult.originalAppointment.datetime).toLocaleString('en-US', {weekday: 'long', month: 'long', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'}) + ' with ' + $json.mergeResult.originalAppointment.technician : 'NOT SET' }}\n- proposedChanges: {{ JSON.stringify($json.mergeResult.proposedChanges || {}) }}\n- changedFields: {{ JSON.stringify($json.mergeResult.changedFields || []) }}\n- partialDate: {{ $json.mergeResult.partialDate || 'NOT SET' }}\n- partialTime: {{ $json.mergeResult.partialTime || 'NOT SET' }}\n- allAppointments: {{ JSON.stringify($json.mergeResult.allAppointments || []) }}\n\nUser's Message: {{ $('Set Initial Data').first().json.messageBody }}",
        "options": {
          "systemMessage": "=## Update Response Agent\nYou help users update their booking by clarifying what's needed.\n\n## INPUT CONTEXT\nResponse type: {{ $json.mergeResult.responseType }}\nClarify type: {{ $json.mergeResult.clarifyType|| 'none' }}\nValidation errors: {{ JSON.stringify($json.mergeResult.validationErrors || []) }}\n\n## BUSINESS RULES\nHours: Monday-Saturday, 9 AM-8 PM. NO SUNDAYS.\n\n## RESPONSE STRUCTURE\n\n### PART A: VALIDATION ERRORS (if any)\nAddress errors FIRST, before anything else:\n\n| Error | Response |\n|-------|----------|\n| datetime + sunday | \"We're closed Sundays - we're open Monday through Saturday, 9 AM to 8 PM.\" |\n| datetime + outside_hours | \"Our hours are 9 AM to 8 PM.\" |\n| service + no_match | \"I didn't find that service. We have manicure, pedicure, gel, rubber, polygel, sculptured nails, facials, waxing, and more. Which would you like?\" |\n| service + ambiguous | Use the possibleMatches array from validationErrors. Say: \"For '[rawInput]', we have: [list each possibleMatch]. Which one did you mean?\" |\n| technician + not_found | \"I don't see [rawInput] on our team. Our team includes: Jenny, Lucero, Ediadne, Pamela. Who would you prefer?\" |\n| technician + ambiguous | \"We have a few team members with that name. Which one did you mean?\" |\n\n\n### PART B: CLARIFICATION BASED ON TYPE\n\n**CLARIFY_SELECTION (appointment not identified):**\nList appointments using dateDisplay and timeDisplay fields from allAppointments:\n\n\"Which appointment would you like to update?\n\n1. [Service] - [dateDisplay], [timeDisplay] with [Technician]\n2. [Service] - [dateDisplay], [timeDisplay] with [Technician]\n\nReply with the number or describe which one.\"\n\nIMPORTANT: Use the dateDisplay and timeDisplay values EXACTLY as provided - do NOT try to parse or convert the datetime field yourself.\n\n**CLARIFY_CHANGES (appointment identified, no changes specified):**\nConfirm the appointment found, then ask what to change:\n\n\"I found your [Service] on [Day, Month Date] at [Time] with [Full Technician Name]. What would you like to change?\" \n\n**CLARIFY_DATETIME (partial datetime):**\n- If partialDate is set but partialTime is NOT SET:\n  \"Got it, [formatted date]! What time works for you? We're open 9 AM to 8 PM.\"\n- If partialTime is set but partialDate is NOT SET:\n  \"Got it, [formatted time]! What date works for you?\"\n\n### PART C: ACKNOWLEDGE SAVED CHANGES (if any)\nIf changedFields is not empty and we're clarifying something else, briefly acknowledge:\n\"I've noted your [change type] change.\"\n\n## FORMAT RULES\n- Use the update state values EXACTLY as provided\n- Format times nicely: \"3:00 PM\" can be \"3 PM\"\n- Be concise and friendly\n- NEVER mention: Redis, JSON, UTC, technical terms\n- Use the technician's FULL NAME (e.g., \"Sarah Johnson\" not just \"Sarah\").\n\n",
          "maxIterations": 2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        9632,
        1824
      ],
      "id": "d1ca5978-910a-49bc-9566-25b92b695f86",
      "name": "Update Response Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Update Response Agent').first().json.output }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        10048,
        1616
      ],
      "id": "a4dc4f21-2ced-42bb-9592-fc540674449e",
      "name": "Update Response Agent Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=Something went wrong. Let's start fresh â€” what appointment would you like to change? ðŸ’…\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        10048,
        2048
      ],
      "id": "e7c2a7dd-8130-4cc3-9da4-98a0216a7d0a",
      "name": "Update Response Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"success\": {\n      \"type\": \"boolean\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"available\": {\n          \"type\": \"boolean\"\n        },\n        \"reason\": {\n          \"type\": \"string\"\n        },\n        \"employeeID\": {\n          \"type\": \"string\"\n        },\n        \"employeeName\": {\n          \"type\": \"string\"\n        },\n        \"alternatives\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"datetime\": {\n                \"type\": \"string\"\n              },\n              \"employeeID\": {\n                \"type\": \"string\"\n              },\n              \"employeeName\": {\n                \"type\": \"string\"\n              },\n              \"timeDisplay\": {\n                \"type\": \"string\"\n              },\n              \"dateDisplay\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"datetime\",\n              \"employeeID\",\n              \"employeeName\",\n              \"timeDisplay\",\n              \"dateDisplay\"\n            ]\n          }\n        },\n        \"assigned\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"required\": [\n        \"available\"\n      ]\n    }\n  },\n  \"required\": [\n    \"success\",\n    \"result\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        10048,
        2560
      ],
      "id": "f1fbc909-bd6f-4b23-9b24-bca7f148cd57",
      "name": "Structured Output Parser9"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        9520,
        2560
      ],
      "id": "2c9e56a3-ceac-4996-ba0b-e7b3ed8cceb6",
      "name": "Google Gemini Chat Model1",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=action: {{ $json.merged.employeeID === 'NEXT_AVAILABLE' ? 'check_any_available' : 'check_specific_employee' }}\nemployeeID: {{ $json.merged.employeeID }}\nemployeeName: {{ $json.merged.employeeName }}\ndatetime: {{ $json.merged.dateTime }}\nduration: {{ $json.merged.serviceDuration }}\ndate: {{ $json.merged.dateTime ? $json.merged.dateTime.substring(0,10) : '' }}\noriginalBookingDatetime: {{ $json.originalBooking ? $json.originalBooking.datetime : '' }}\noriginalBookingEmployeeID: {{ $json.originalBooking ? $json.originalBooking.employeeID : '' }}\nallowedEmployees: {{ $json.merged.allowedEmployees || 'ALL' }}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Availability Agent\nCheck if requested time slot is available for an UPDATE booking.\n\n## CRITICAL: ORIGINAL BOOKING EXCLUSION\nThis is an UPDATE flow. The user's CURRENT appointment appears as \"blocked\" in the schedule.\nWhen originalBookingDatetime is provided, you MUST pass it to update_process_availability_check so it can EXCLUDE that blocked time.\n\n## INPUT\n- action: \"check_specific_employee\" | \"check_any_available\"\n- employeeID, employeeName: Target employee (or NEXT_AVAILABLE)\n- datetime: Requested UTC datetime\n- duration: Service minutes\n- date: YYYY-MM-DD\n- originalBookingDatetime: Current appointment being updated (UTC) - PASS TO TOOL\n- originalBookingEmployeeID: Employee of current appointment - PASS TO TOOL\n- allowedEmployees: \"ALL\" or Employee IDs. May contain pipes (e.g., \"ALL|EMP005\"). Flatten: split on | then comma, remove \"ALL\" entries and duplicates. If all are \"ALL\", no filter needed.\n\n## TOOLS\n1. update_get_employee_availability: Gets employee schedule for a date\n2. update_process_availability_check: Checks if time slot is available\n\n## CRITICAL: TOOL INPUT FORMAT\nWhen calling update_process_availability_check, pass ALL parameters as a SINGLE JSON object in the query field.\n\nCORRECT FORMAT (use this):\nquery: {\"datetime\": \"2026-01-20T21:30:00.000Z\", \"duration\": 90, \"workingHours\": \"10:00 AM - 7:00 PM\", \"blockedTimes\": \"3:00 PM-4:30 PM\", \"employeeID\": \"EMP002\", \"employeeName\": \"David Martinez\", \"originalBookingDatetime\": \"2026-01-15T20:00:00.000Z\", \"originalBookingEmployeeID\": \"EMP001\"}\n\nWRONG FORMAT (never do this):\nquery: \"datetime: 2026-01-20T21:30:00.000Z, duration: 90, workingHours: 10:00 AM - 7:00 PM...\"\n\nThe query value MUST be a valid JSON object with these fields:\n- datetime (string): UTC ISO datetime\n- duration (number): minutes\n- workingHours (string): e.g., \"10:00 AM - 7:00 PM\"\n- blockedTimes (string): e.g., \"3:00 PM-4:30 PM, 5:30 PM-6:00 PM\"\n- employeeID (string): e.g., \"EMP002\"\n- employeeName (string): e.g., \"David Martinez\"\n- originalBookingDatetime (string): UTC ISO datetime of current booking\n- originalBookingEmployeeID (string): employee ID of current booking\n\n## WORKFLOW\n\n### check_specific_employee\n1. CALL update_get_employee_availability with date\n2. Find row matching employeeID\n3. CALL update_process_availability_check with JSON object containing:\n   - datetime, duration (from input)\n   - workingHours, blockedTimes (from employee row)\n   - employeeID, employeeName (from employee row)\n   - originalBookingDatetime, originalBookingEmployeeID (from input)\n4. Return result\n\n### check_any_available\n1. CALL update_get_employee_availability with date\n2. FILTER: If allowedEmployees != \"ALL\", split on | then comma, remove \"ALL\" entries and duplicates. Only consider employees whose Employee ID is in that list.\n3. For each FILTERED employee where workingHours != \"OFF\":\n   - CALL update_process_availability_check with JSON object\n   - If available: return immediately\n4. If none available: return unavailable\n\n## OUTPUT FORMAT\nYou MUST wrap your response in this exact structure:\n```json\n{\"success\": true, \"result\": {\"available\": true/false, \"reason\": \"...\", \"employeeID\": \"...\", \"employeeName\": \"...\"}}\n```\n\nReasons: \"available\" | \"specific_employee_unavailable\" | \"no_employees_available\" | \"outside_hours\" | \"time_blocked\"\n\nExample when available:\n{\"success\": true, \"result\": {\"available\": true, \"reason\": \"available\", \"employeeID\": \"EMP002\", \"employeeName\": \"David Martinez\"}}\n\nExample when unavailable:\n{\"success\": true, \"result\": {\"available\": false, \"reason\": \"time_blocked\", \"employeeID\": \"EMP002\", \"employeeName\": \"David Martinez\"}}\n\n## RULES\n## MANDATORY TOOL CALL - You MUST call update_process_availability_check for EVERY employee you evaluate - You CANNOT determine availability without calling the tool - it has logic you don't have - NEVER return \"no_employees_available\" unless you called update_process_availability_check for ALL employees and ALL returned available: false - DO NOT calculate availability yourself based on working hours - ALWAYS use the tool\n- ALWAYS pass a JSON object (not a string) to update_process_availability_check\n- ALWAYS include originalBookingDatetime and originalBookingEmployeeID in the JSON\n- ONLY CALL EACH TOOL ONCE PER TURN\n- ALWAYS wrap output in {\"success\": true, \"result\": {...}} structure\n- Return JSON only\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        9664,
        2352
      ],
      "id": "fb40c474-26cf-440b-af85-2c13bd203f2e",
      "name": "Update Availability Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Date",
              "lookupValue": "={{ $fromAI('date', 'Appointment date in YYYY-MM-DD format (e.g., 2025-11-28)', 'string') }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        9696,
        2560
      ],
      "id": "c9f3659e-9f44-4afc-a530-74e0dc9b9485",
      "name": "update_get_employee_availability",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "description": "This tool is used to check availability for an appointment.",
        "jsCode": "// ============================================\n// PROCESS AVAILABILITY CHECK (UPDATE FLOW)\n// Excludes original booking from blocked times\n// ============================================\n\n// ROBUST INPUT PARSING - handles multiple input formats\nlet inputData;\n\ntry {\n  if (typeof query !== 'undefined' && query) {\n    if (typeof query === 'object') {\n      // Already a JSON object - use directly\n      inputData = query;\n    } else if (typeof query === 'string') {\n      // Try JSON parse first\n      try {\n        inputData = JSON.parse(query);\n      } catch (jsonErr) {\n        // Fallback: parse key: value or key=value format\n        inputData = {};\n        const pairs = query.split(',').map(p => p.trim());\n        for (const pair of pairs) {\n          let key, value;\n          if (pair.includes(':')) {\n            const colonIndex = pair.indexOf(':');\n            key = pair.substring(0, colonIndex).trim();\n            value = pair.substring(colonIndex + 1).trim();\n          } else if (pair.includes('=')) {\n            [key, value] = pair.split('=').map(s => s.trim());\n          }\n          if (key && value !== undefined) {\n            // Remove quotes if present\n            value = value.replace(/^[\"']|[\"']$/g, '');\n            inputData[key] = value;\n          }\n        }\n      }\n    }\n  } else {\n    return JSON.stringify({\n      available: false,\n      reason: \"parsing_error\",\n      error: \"No query parameter found\"\n    });\n  }\n} catch (err) {\n  return JSON.stringify({\n    available: false,\n    reason: \"parsing_error\",\n    error: \"Failed to parse input: \" + err.message\n  });\n}\n\n// Extract parameters\nconst datetime = inputData.datetime;\nconst duration = parseInt(inputData.duration);\nconst workingHours = inputData.workingHours || \"\";\nconst blockedTimes = inputData.blockedTimes || \"\";\nconst employeeID = inputData.employeeID || \"\";\nconst employeeName = inputData.employeeName || \"\";\n\n// Original booking to exclude\nconst originalBookingDatetime = inputData.originalBookingDatetime || \"\";\nconst originalBookingEmployeeID = inputData.originalBookingEmployeeID || \"\";\n\n// Validate required parameters\nif (!datetime || !duration || !workingHours) {\n  return JSON.stringify({\n    available: false,\n    reason: \"missing_parameters\",\n    error: \"Missing required parameters: datetime, duration, or workingHours\",\n    received: { datetime, duration, workingHours }\n  });\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nfunction utcToLocal(utcDatetime) {\n  const date = new Date(utcDatetime);\n  let localHour = date.getUTCHours() - 5;\n  const localMinute = date.getUTCMinutes();\n  \n  // Handle day wrap\n  if (localHour < 0) localHour += 24;\n  \n  return { hour: localHour, minute: localMinute };\n}\n\nfunction parseTime(timeStr) {\n  const [time, period] = timeStr.split(' ');\n  let [hour, minute] = time.split(':').map(Number);\n  if (period === 'PM' && hour !== 12) hour += 12;\n  if (period === 'AM' && hour === 12) hour = 0;\n  return { hour, minute: minute || 0 };\n}\n\nfunction isTimeInRange(checkTime, startTime, endTime) {\n  const checkMinutes = checkTime.hour * 60 + checkTime.minute;\n  const startMinutes = startTime.hour * 60 + startTime.minute;\n  const endMinutes = endTime.hour * 60 + endTime.minute;\n  return checkMinutes >= startMinutes && checkMinutes < endMinutes;\n}\n\nfunction timeRangesOverlap(start1, end1, start2, end2) {\n  const start1Min = start1.hour * 60 + start1.minute;\n  const end1Min = end1.hour * 60 + end1.minute;\n  const start2Min = start2.hour * 60 + start2.minute;\n  const end2Min = end2.hour * 60 + end2.minute;\n  return start1Min < end2Min && end1Min > start2Min;\n}\n\n// Check if a blocked time matches the original booking (should be skipped)\nfunction isOriginalBooking(blockStart, currentEmployeeID) {\n  if (!originalBookingDatetime || !originalBookingEmployeeID) return false;\n  if (currentEmployeeID !== originalBookingEmployeeID) return false;\n  \n  const origLocal = utcToLocal(originalBookingDatetime);\n  return blockStart.hour === origLocal.hour && blockStart.minute === origLocal.minute;\n}\n\n// ============================================\n// AVAILABILITY CHECK\n// ============================================\n\n// Check if employee is working\nif (workingHours.toUpperCase() === \"OFF\") {\n  return JSON.stringify({\n    available: false,\n    reason: \"not_working\",\n    employeeID: employeeID,\n    employeeName: employeeName\n  });\n}\n\n// Parse working hours\nconst [startStr, endStr] = workingHours.includes(' - ') \n  ? workingHours.split(' - ')\n  : workingHours.split('-').map(s => s.trim());\n\nconst workStart = parseTime(startStr);\nconst workEnd = parseTime(endStr);\n\n// Get requested time in local\nconst requestedTime = utcToLocal(datetime);\nconst requestedEndTime = {\n  hour: requestedTime.hour,\n  minute: requestedTime.minute + duration\n};\nif (requestedEndTime.minute >= 60) {\n  requestedEndTime.hour += Math.floor(requestedEndTime.minute / 60);\n  requestedEndTime.minute = requestedEndTime.minute % 60;\n}\n\n// Check within working hours\nif (!isTimeInRange(requestedTime, workStart, workEnd)) {\n  return JSON.stringify({\n    available: false,\n    reason: \"outside_working_hours\",\n    employeeID: employeeID,\n    employeeName: employeeName\n  });\n}\n\n// Check if service ends after working hours\nif (requestedEndTime.hour > workEnd.hour || \n    (requestedEndTime.hour === workEnd.hour && requestedEndTime.minute > workEnd.minute)) {\n  return JSON.stringify({\n    available: false,\n    reason: \"service_exceeds_hours\",\n    employeeID: employeeID,\n    employeeName: employeeName\n  });\n}\n\n// Check blocked times (excluding original booking)\nif (blockedTimes && typeof blockedTimes === 'string' && blockedTimes.trim() !== \"\") {\n  const blocks = blockedTimes.split(',').map(b => b.trim());\n  \n  for (const block of blocks) {\n    if (block && block.includes('-')) {\n      const parts = block.split('-');\n      if (parts.length !== 2) continue;\n      \n      const blockStart = parseTime(parts[0].trim());\n      const blockEnd = parseTime(parts[1].trim());\n      \n      // SKIP if this is the original booking being updated\n      if (isOriginalBooking(blockStart, employeeID)) {\n        continue;\n      }\n      \n      if (timeRangesOverlap(requestedTime, requestedEndTime, blockStart, blockEnd)) {\n        return JSON.stringify({\n          available: false,\n          reason: \"time_blocked\",\n          employeeID: employeeID,\n          employeeName: employeeName\n        });\n      }\n    }\n  }\n}\n\n// Available!\nreturn JSON.stringify({\n  available: true,\n  employeeID: employeeID,\n  employeeName: employeeName\n});"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        9872,
        2560
      ],
      "id": "45adcef0-84b9-49ff-a169-5c6e1d740b5b",
      "name": "update_process_availability_check"
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for Update Availability Agent\nconst data = $input.first().json;\n\n// Data comes from Update Route Switch which wraps in mergeResult\nconst mergeResult = data.mergeResult || data;\nconst final = mergeResult.finalBooking || data.finalBooking;\nconst orig = mergeResult.originalAppointment || data.originalAppointment;\n\nif (!final) {\n  throw new Error('finalBooking is missing. Input keys: ' + Object.keys(data).join(', '));\n}\n\n// Pre-resolve allowedEmployees: flatten pipes, remove ALL entries\nlet rawAllowed = data.allowedEmployees || mergeResult.allowedEmployees || 'ALL';\nlet resolvedAllowed = rawAllowed;\n\nif (rawAllowed.includes('|')) {\n  const filtered = rawAllowed.split('|')\n    .flatMap(group => group.split(','))\n    .map(s => s.trim())\n    .filter(s => s && s.toUpperCase() !== 'ALL' && s !== 'undefined');\n  \n  // Deduplicate\n  const unique = [...new Set(filtered)];\n  resolvedAllowed = unique.length > 0 ? unique.join(',') : 'ALL';\n}\n\n// If NEXT_AVAILABLE with only one qualified employee, lock to that employee\nlet resolvedEmployeeID = final.employeeID;\nlet resolvedEmployeeName = final.employeeName;\n\nif (final.employeeID === 'NEXT_AVAILABLE' && resolvedAllowed !== 'ALL') {\n  const qualifiedIDs = resolvedAllowed.split(',').map(s => s.trim()).filter(Boolean);\n  if (qualifiedIDs.length === 1) {\n    // Only one qualified tech â€” lock to them directly\n    resolvedEmployeeID = qualifiedIDs[0];\n    // Try to get name from original data or fallback\n    \n    resolvedEmployeeName = qualifiedIDs[0];\n  }\n}\n\nreturn [{\n  json: {\n    merged: {\n      employeeID: resolvedEmployeeID,\n      employeeName: resolvedEmployeeName,\n      dateTime: final.datetime,\n      serviceDuration: final.serviceDuration,\n      allowedEmployees: resolvedAllowed\n    },\n    // Original appointment info - to exclude from availability check\n    originalBooking: {\n      datetime: orig ? orig.datetime : null,\n      employeeID: orig ? orig.employeeID : null\n    },\n    // Pass through all data for later use\n    originalAppointment: orig,\n    finalBooking: final,\n    changedFields: mergeResult.changedFields || data.changedFields,\n    mod: mergeResult.mod || data.mod,\n    phone: mergeResult.phone || data.phone\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9312,
        2032
      ],
      "id": "52c32516-2265-47c2-9835-fac58486af82",
      "name": "Prepare Update Availability"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I couldn't check availability for your modification. Please try again or give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        10384,
        2560
      ],
      "id": "7d3c4fcb-bc38-4810-aa7d-cc56c5d1f923",
      "name": "Update Availability Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "dab65382-2ffc-4e83-8fc3-562e9f635f95",
              "leftValue": "={{ $json.output.result.available }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        10384,
        2336
      ],
      "id": "f438205e-eb12-462a-8710-afd9bcaab702",
      "name": "Update Available?"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ \n  (() => {\n    const data = $('Prepare Update Availability').first().json;\n    const avail = $('Update Availability Agent').first().json.output.result;\n    const mod = data.mod;\n    \n    // Update with availability result\n    mod.availabilityConfirmed = true;\n    mod.readyToSave = true;\n    \n    // If NEXT_AVAILABLE, update with assigned employee\n    if (data.finalBooking.employeeID === 'NEXT_AVAILABLE') {\n      mod.finalBooking.employeeID = avail.employeeID;\n      mod.finalBooking.employeeName = avail.employeeName;\n      mod.proposedChanges.employeeID = avail.employeeID;\n      mod.proposedChanges.employeeName = avail.employeeName;\n    }\n    \n    return { bookingModification: JSON.stringify(mod) };\n  })()\n}}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        10656,
        2096
      ],
      "id": "84500011-b52e-4797-8cbc-bc2a700cec60",
      "name": "set_userflag_Update_readyToSave",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const data = $('Prepare Update Availability').first().json;\nconst orig = data.originalAppointment;\nconst final = data.finalBooking;\nconst changedFields = data.changedFields || [];\n\n// Get assigned employee if NEXT_AVAILABLE\nlet finalEmployeeName = final.employeeName;\nlet finalEmployeeID = final.employeeID;\nif (final.employeeID === 'NEXT_AVAILABLE') {\n  const avail = $('Update Availability Agent').first().json.output.result;\n  finalEmployeeName = avail.employeeName;\n  finalEmployeeID = avail.employeeID;\n}\n\nconst formatDt = (iso) => {\n  const d = new Date(iso);\n  const date = d.toLocaleDateString('en-US', {\n    weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n  });\n  const time = d.toLocaleTimeString('en-US', {\n    hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n  });\n  return `${date} at ${time}`;\n};\n\n// Helper: Format multi-service display\nconst formatServiceDisplay = (serviceName, servicePrice) => {\n  const names = String(serviceName).split(',').map(s => s.trim());\n  const prices = String(servicePrice).split(',').map(p => p.trim().replace(/[$]/g, ''));\n  \n  if (names.length === 1) {\n    return { display: names[0], total: parseFloat(prices[0]) || 0 };\n  }\n  \n  // Multi-service: show combined name and total\n  const total = prices.reduce((sum, p) => sum + (parseFloat(p) || 0), 0);\n  return { display: names.join(' + '), total };\n};\n\nlet message = \"Here's a summary of your updated appointment:\\n\\n\";\n\n// Show datetime with arrow if changed\nif (changedFields.includes('datetime')) {\n  message += `ðŸ“… ${formatDt(orig.datetime)} â†’ *${formatDt(final.datetime)}*\\n`;\n} else {\n  message += `ðŸ“… ${formatDt(final.datetime)}\\n`;\n}\n\n// Show service with arrow if changed (handles multi-service)\nif (changedFields.includes('service')) {\n  const origService = formatServiceDisplay(orig.service, orig.servicePrice || '0');\n  const finalService = formatServiceDisplay(final.serviceName, final.servicePrice);\n  message += `ðŸ’… ${origService.display} ($${origService.total}) â†’ *${finalService.display}* ($${finalService.total})\\n`;\n} else {\n  const finalService = formatServiceDisplay(final.serviceName, final.servicePrice);\n  message += `ðŸ’… ${finalService.display} ($${finalService.total})\\n`;\n}\n\n// Show technician with arrow if changed\nif (changedFields.includes('technician')) {\n  message += `âœ¨ ${orig.technician} â†’ *${finalEmployeeName}*\\n`;\n} else {\n  message += `âœ¨ ${finalEmployeeName}\\n`;\n}\n\nmessage += `ðŸ“ Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\\n\\n`;\nmessage += `Reply *\"save\"* to confirm these changes.`;\n\nreturn [{\n  json: {\n    message,\n    finalEmployeeName,\n    finalEmployeeID\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10848,
        2096
      ],
      "id": "7c314f55-c88e-4f40-8d47-f219e3fcd106",
      "name": "Build Update Summary"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11232,
        2096
      ],
      "id": "a86e033e-4f8c-43d4-a281-aefd6c03a53b",
      "name": "Send Update Summary",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=446414277"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        10640,
        2448
      ],
      "id": "c7b1e84b-2380-4e61-bb56-84a92699467b",
      "name": "Update Get Employee Availability Range",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// UPDATE AVAILABILITY CODE - Deterministic Code Node\n// ================================================================\n\n// GET PARAMETERS FROM UPSTREAM\nconst userflag = $('Prepare Update Availability').first().json.merged;\nconst originalBooking = $('Prepare Update Availability').first().json.originalBooking;\n\n// ================================================================\n// VALIDATE REQUIRED DATA EXISTS\n// ================================================================\nif (!userflag || !userflag.dateTime) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      available: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_datetime\",\n      errorMessage: \"No date/time specified for availability search\"\n    }\n  }];\n}\n\nif (!userflag.serviceDuration) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      available: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_duration\",\n      errorMessage: \"No service duration specified\"\n    }\n  }];\n}\n\n// Extract booking parameters\nconst requestedDateTimeUTC = userflag.dateTime;\n\n// Handle comma-separated durations (sum them)\nlet duration;\nif (userflag.serviceDuration.includes(',')) {\n  duration = userflag.serviceDuration.split(',').reduce((sum, d) => sum + parseInt(d.trim()), 0);\n} else {\n  duration = parseInt(userflag.serviceDuration);\n}\n\nconst requestedDate = requestedDateTimeUTC.split('T')[0];\nconst filterEmployeeID = (userflag.employeeID && userflag.employeeID !== \"NEXT_AVAILABLE\") \n  ? userflag.employeeID \n  : null;\nconst filterEmployeeName = (userflag.employeeName && userflag.employeeName !== \"Next Available\") \n  ? userflag.employeeName \n  : null;\n\n// GET EMPLOYEE DATA FROM GOOGLE SHEETS\nconst employeeData = $('Update Get Employee Availability Range').all().map(item => item.json);\n\n// Validate we have data\nif (!employeeData || employeeData.length === 0) {\n  return [{\n    json: {\n      success: false,\n      found: false,\n      available: false,\n      count: 0,\n      alternatives: [],\n      pendingAlternatives: null,\n      error: \"no_employee_data\",\n      errorMessage: \"No employee availability data found\"\n    }\n  }];\n}\n\n// ================================================================\n// SERVICE RESTRICTION FILTER (allowedEmployees from merged)\n// ================================================================\nlet qualifiedEmployeeIDs = null;\nconst allowedRaw = userflag.allowedEmployees;\nif (allowedRaw && allowedRaw.toUpperCase() !== 'ALL') {\n  const empList = allowedRaw.replace(/\\|/g, ',').split(',')\n    .map(e => e.trim())\n    .filter(e => e && e !== 'ALL' && e !== 'undefined');\n  if (empList.length > 0) {\n    qualifiedEmployeeIDs = new Set(empList);\n  }\n}\n\n// SCOPE FILTER: Exclude specialty-only techs from \"ALL\" services\nlet filteredEmployeeData = employeeData;\nif (qualifiedEmployeeIDs === null) {\n  // \"ALL\" service â€” exclude SPECIALTY-only employees\n  try {\n    const empInfo = $('Get Employee Info For Names').all().map(item => item.json);\n    const specialtyOnlyIDs = new Set(\n      empInfo\n        .filter(e => (e['Service Scope'] || 'GENERAL').toUpperCase() === 'SPECIALTY')\n        .map(e => e['Employee ID'])\n    );\n    if (specialtyOnlyIDs.size > 0) {\n      filteredEmployeeData = filteredEmployeeData.filter(row => {\n        const empID = row['Employee ID'] || row['employeeID'] || '';\n        return !specialtyOnlyIDs.has(empID);\n      });\n    }\n  } catch (e) {\n    // If employee info not accessible, skip scope filter\n  }\n}\n\n// Filter employees if restrictions exist\nif (qualifiedEmployeeIDs !== null) {\n  filteredEmployeeData = employeeData.filter(row => {\n    const empID = row['Employee ID'] || row['employeeID'] || '';\n    return qualifiedEmployeeIDs.has(empID);\n  });\n\n  if (filteredEmployeeData.length === 0) {\n    return [{\n      json: {\n        success: false,\n        found: false,\n        available: false,\n        count: 0,\n        alternatives: [],\n        pendingAlternatives: null,\n        error: \"no_qualified_availability\",\n        errorMessage: \"No qualified technicians have availability data\"\n      }\n    }];\n  }\n}\n\n// ================================================================\n// CONFIGURATION\n// ================================================================\nconst MAX_RESULTS_PER_DIRECTION = 1;\nconst INCREMENT_MINUTES = 5;\nconst MAX_OFFSET_MINUTES = 56 * 24 * 60; // 8 weeks\n\n// ================================================================\n// HELPER FUNCTIONS\n// ================================================================\n\nfunction utcToLocal(utcDatetime) {\n  const date = new Date(utcDatetime);\n  const localHour = date.getUTCHours() - 5; // EST = UTC-5\n  const localMinute = date.getUTCMinutes();\n  \n  let adjustedHour = localHour;\n  let dayOffset = 0;\n  \n  if (localHour < 0) {\n    adjustedHour = 24 + localHour;\n    dayOffset = -1;\n  } else if (localHour >= 24) {\n    adjustedHour = localHour - 24;\n    dayOffset = 1;\n  }\n  \n  return { hour: adjustedHour, minute: localMinute, dayOffset };\n}\n\nfunction parseTime(timeStr) {\n  const [time, period] = timeStr.split(' ');\n  let [hour, minute] = time.split(':').map(Number);\n  if (period === 'PM' && hour !== 12) hour += 12;\n  if (period === 'AM' && hour === 12) hour = 0;\n  return { hour, minute };\n}\n\nfunction isTimeInRange(checkTime, startTime, endTime) {\n  const checkMinutes = checkTime.hour * 60 + checkTime.minute;\n  const startMinutes = startTime.hour * 60 + startTime.minute;\n  const endMinutes = endTime.hour * 60 + endTime.minute;\n  return checkMinutes >= startMinutes && checkMinutes < endMinutes;\n}\n\nfunction timeRangesOverlap(start1, end1, start2, end2) {\n  const start1Min = start1.hour * 60 + start1.minute;\n  const end1Min = end1.hour * 60 + end1.minute;\n  const start2Min = start2.hour * 60 + start2.minute;\n  const end2Min = end2.hour * 60 + end2.minute;\n  return start1Min < end2Min && end1Min > start2Min;\n}\n\nfunction formatTimeForDisplay(localTime) {\n  let hour = localTime.hour;\n  const minute = localTime.minute;\n  const period = hour >= 12 ? 'PM' : 'AM';\n  \n  if (hour > 12) hour -= 12;\n  if (hour === 0) hour = 12;\n  \n  return `${hour}:${minute.toString().padStart(2, '0')} ${period}`;\n}\n\nfunction formatDateForDisplay(dateStr) {\n  const date = new Date(dateStr + 'T00:00:00Z');\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', \n                  'July', 'August', 'September', 'October', 'November', 'December'];\n  \n  return `${days[date.getUTCDay()]}, ${months[date.getUTCMonth()]} ${date.getUTCDate()}`;\n}\n\nfunction extractDateFromUTC(utcDatetime) {\n  const date = new Date(utcDatetime);\n  date.setHours(date.getHours() - 5);\n  return date.toISOString().split('T')[0];\n}\n\nfunction isSunday(utcDatetime) {\n  const date = new Date(utcDatetime);\n  date.setHours(date.getHours() - 5);\n  return date.getDay() === 0;\n}\n\nfunction isWithinBusinessHours(localTime) {\n  return localTime.hour >= 9 && localTime.hour < 20;\n}\n\nfunction checkSlotAvailability(datetimeUTC, dur, workingHours, blockedTimes, employeeID, origBooking) {\n  if (!workingHours || workingHours.toUpperCase() === \"OFF\") {\n    return false;\n  }\n  \n  const workingHoursTrimmed = workingHours.trim();\n  let startStr, endStr;\n  \n  if (workingHoursTrimmed.includes(' - ')) {\n    [startStr, endStr] = workingHoursTrimmed.split(' - ');\n  } else if (workingHoursTrimmed.includes('-')) {\n    [startStr, endStr] = workingHoursTrimmed.split('-').map(s => s.trim());\n  } else {\n    return false;\n  }\n  \n  const workStart = parseTime(startStr);\n  const workEnd = parseTime(endStr);\n  \n  const localTimeData = utcToLocal(datetimeUTC);\n  const requestedTime = { hour: localTimeData.hour, minute: localTimeData.minute };\n  const requestedEndTime = {\n    hour: requestedTime.hour,\n    minute: requestedTime.minute + dur\n  };\n  \n  if (requestedEndTime.minute >= 60) {\n    requestedEndTime.hour += Math.floor(requestedEndTime.minute / 60);\n    requestedEndTime.minute = requestedEndTime.minute % 60;\n  }\n  \n  if (!isTimeInRange(requestedTime, workStart, workEnd)) {\n    return false;\n  }\n  \n  if (requestedEndTime.hour > workEnd.hour || \n      (requestedEndTime.hour === workEnd.hour && requestedEndTime.minute > workEnd.minute)) {\n    return false;\n  }\n  \n  // Check blocked times, but EXCLUDE original appointment if same employee\n  if (blockedTimes && typeof blockedTimes === 'string' && blockedTimes.trim() !== \"\") {\n    const blocks = blockedTimes.split(',').map(b => b.trim());\n    \n    // Get original booking time for comparison (if updating same employee)\n    let originalBlockedStart = null;\n    \n    if (origBooking && origBooking.datetime && origBooking.employeeID === employeeID) {\n      const origLocal = utcToLocal(origBooking.datetime);\n      originalBlockedStart = { hour: origLocal.hour, minute: origLocal.minute };\n    }\n    \n    for (const block of blocks) {\n      if (block && block.includes('-')) {\n        const parts = block.split('-');\n        if (parts.length !== 2) continue;\n        \n        const blockStartStr = parts[0].trim();\n        const blockEndStr = parts[1].trim();\n        \n        const blockStart = parseTime(blockStartStr);\n        const blockEnd = parseTime(blockEndStr);\n        \n        // SKIP this block if it's the original appointment being updated\n        if (originalBlockedStart && \n            blockStart.hour === originalBlockedStart.hour && \n            blockStart.minute === originalBlockedStart.minute) {\n          continue; // This is our own appointment, ignore it\n        }\n        \n        if (timeRangesOverlap(requestedTime, requestedEndTime, blockStart, blockEnd)) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}\n\nfunction generateCandidateSlot(baseDateTime, offsetMinutes) {\n  const candidateDateTime = new Date(baseDateTime);\n  candidateDateTime.setMinutes(candidateDateTime.getMinutes() + offsetMinutes);\n  return candidateDateTime;\n}\n\n// ================================================================\n// CHECK REQUESTED SLOT FIRST\n// ================================================================\n\nconst requestedSlotDate = extractDateFromUTC(requestedDateTimeUTC);\nconst requestedSlotLocal = utcToLocal(requestedDateTimeUTC);\n\n// Find matching employee rows for the requested date\nconst matchingRowsRequested = filteredEmployeeData.filter(row => {\n  const rowDate = row['Date'] || row['date'] || '';\n  if (!rowDate) return false;\n  \n  if (filterEmployeeID) {\n    const rowEmployeeID = row['Employee ID'] || row['employeeID'] || '';\n    return rowDate === requestedSlotDate && rowEmployeeID === filterEmployeeID;\n  } else {\n    return rowDate === requestedSlotDate;\n  }\n});\n\n// Check if requested slot is available\nfor (const row of matchingRowsRequested) {\n  const workingHours = row['Working Hours'] || row['workingHours'] || '';\n  const blockedTimes = row['Blocked Times'] || row['blockedTimes'] || '';\n  const employeeID = row['Employee ID'] || row['employeeID'] || '';\n  const employeeName = row['Employee Name'] || row['employeeName'] || '';\n  \n  if (checkSlotAvailability(requestedDateTimeUTC, duration, workingHours, blockedTimes, employeeID, originalBooking)) {\n    // Requested slot IS available! Return immediately\n    return [{\n      json: {\n        success: true,\n        found: true,\n        available: true,\n        count: 1,\n        alternatives: [{\n          datetime: requestedDateTimeUTC,\n          dateDisplay: formatDateForDisplay(requestedSlotDate),\n          timeDisplay: formatTimeForDisplay(requestedSlotLocal),\n          employeeID: employeeID,\n          employeeName: employeeName,\n          duration: duration\n        }],\n        pendingAlternatives: null,\n        error: null,\n        errorMessage: null\n      }\n    }];\n  }\n}\n\n// ================================================================\n// SEARCH FORWARD (closest AFTER)\n// ================================================================\n\nconst slotsAfter = [];\nconst requestedDateTime = new Date(requestedDateTimeUTC);\nlet offsetAfter = INCREMENT_MINUTES;\n\nwhile (slotsAfter.length < MAX_RESULTS_PER_DIRECTION && offsetAfter <= MAX_OFFSET_MINUTES) {\n  const slotAfterUTC = generateCandidateSlot(requestedDateTime, offsetAfter);\n  const slotAfterUTCStr = slotAfterUTC.toISOString();\n  const slotAfterDate = extractDateFromUTC(slotAfterUTCStr);\n  const slotAfterLocal = utcToLocal(slotAfterUTCStr);\n  \n  if (!isSunday(slotAfterUTCStr) && isWithinBusinessHours(slotAfterLocal)) {\n    const matchingRowsAfter = filteredEmployeeData.filter(row => {\n      const rowDate = row['Date'] || row['date'] || '';\n      if (!rowDate) return false;\n      \n      if (filterEmployeeID) {\n        const rowEmployeeID = row['Employee ID'] || row['employeeID'] || '';\n        return rowDate === slotAfterDate && rowEmployeeID === filterEmployeeID;\n      } else {\n        return rowDate === slotAfterDate;\n      }\n    });\n    \n    for (const row of matchingRowsAfter) {\n      if (slotsAfter.length >= MAX_RESULTS_PER_DIRECTION) break;\n      \n      const workingHours = row['Working Hours'] || row['workingHours'] || '';\n      const blockedTimes = row['Blocked Times'] || row['blockedTimes'] || '';\n      const employeeID = row['Employee ID'] || row['employeeID'] || '';\n      const employeeName = row['Employee Name'] || row['employeeName'] || '';\n      \n      if (checkSlotAvailability(slotAfterUTCStr, duration, workingHours, blockedTimes, employeeID, originalBooking)) {\n        slotsAfter.push({\n          datetime: slotAfterUTCStr,\n          dateDisplay: formatDateForDisplay(slotAfterDate),\n          timeDisplay: formatTimeForDisplay(slotAfterLocal),\n          employeeID: employeeID,\n          employeeName: employeeName,\n          duration: duration,\n          offsetMinutes: offsetAfter\n        });\n        \n        if (filterEmployeeID) break;\n      }\n    }\n  }\n  \n  offsetAfter += INCREMENT_MINUTES;\n}\n\n// ================================================================\n// SEARCH BACKWARD (closest BEFORE)\n// ================================================================\n\nconst slotsBefore = [];\nlet offsetBefore = INCREMENT_MINUTES;\n\n// Don't search before current time\nconst now = new Date();\n\nwhile (slotsBefore.length < MAX_RESULTS_PER_DIRECTION && offsetBefore <= MAX_OFFSET_MINUTES) {\n  const slotBeforeUTC = generateCandidateSlot(requestedDateTime, -offsetBefore);\n  \n  // Skip if this slot is in the past\n  if (slotBeforeUTC < now) {\n    offsetBefore += INCREMENT_MINUTES;\n    continue;\n  }\n  \n  const slotBeforeUTCStr = slotBeforeUTC.toISOString();\n  const slotBeforeDate = extractDateFromUTC(slotBeforeUTCStr);\n  const slotBeforeLocal = utcToLocal(slotBeforeUTCStr);\n  \n  if (!isSunday(slotBeforeUTCStr) && isWithinBusinessHours(slotBeforeLocal)) {\n    const matchingRowsBefore = filteredEmployeeData.filter(row => {\n      const rowDate = row['Date'] || row['date'] || '';\n      if (!rowDate) return false;\n      \n      if (filterEmployeeID) {\n        const rowEmployeeID = row['Employee ID'] || row['employeeID'] || '';\n        return rowDate === slotBeforeDate && rowEmployeeID === filterEmployeeID;\n      } else {\n        return rowDate === slotBeforeDate;\n      }\n    });\n    \n    for (const row of matchingRowsBefore) {\n      if (slotsBefore.length >= MAX_RESULTS_PER_DIRECTION) break;\n      \n      const workingHours = row['Working Hours'] || row['workingHours'] || '';\n      const blockedTimes = row['Blocked Times'] || row['blockedTimes'] || '';\n      const employeeID = row['Employee ID'] || row['employeeID'] || '';\n      const employeeName = row['Employee Name'] || row['employeeName'] || '';\n      \n      if (checkSlotAvailability(slotBeforeUTCStr, duration, workingHours, blockedTimes, employeeID, originalBooking)) {\n        slotsBefore.push({\n          datetime: slotBeforeUTCStr,\n          dateDisplay: formatDateForDisplay(slotBeforeDate),\n          timeDisplay: formatTimeForDisplay(slotBeforeLocal),\n          employeeID: employeeID,\n          employeeName: employeeName,\n          duration: duration,\n          offsetMinutes: offsetBefore\n        });\n        \n        if (filterEmployeeID) break;\n      }\n    }\n  }\n  \n  offsetBefore += INCREMENT_MINUTES;\n}\n\n// ================================================================\n// COMBINE AND SELECT CLOSEST\n// ================================================================\n\nconst allSlots = [...slotsAfter, ...slotsBefore];\nallSlots.sort((a, b) => Math.abs(a.offsetMinutes) - Math.abs(b.offsetMinutes));\nconst finalAlternatives = allSlots.slice(0, 1);\n\n// Clean output\nconst cleanedAlternatives = finalAlternatives.map(alt => ({\n  datetime: alt.datetime,\n  dateDisplay: alt.dateDisplay,\n  timeDisplay: alt.timeDisplay,\n  employeeID: alt.employeeID,\n  employeeName: alt.employeeName,\n  duration: alt.duration\n}));\n\n// Return with found flag for IF node\nreturn [{\n  json: {\n    success: cleanedAlternatives.length > 0,\n    found: cleanedAlternatives.length > 0,\n    available: false, // Requested slot was NOT available (we're returning alternatives)\n    count: cleanedAlternatives.length,\n    alternatives: cleanedAlternatives,\n    pendingAlternatives: cleanedAlternatives.length > 0 ? JSON.stringify(cleanedAlternatives) : null,\n    error: cleanedAlternatives.length === 0 ? \"no_availability\" : null,\n    errorMessage: cleanedAlternatives.length === 0 \n      ? \"No available appointments found within the next 8 weeks\" \n      : null\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10848,
        2448
      ],
      "id": "bfb0b1ff-dd42-4cb3-8180-3d04cd7ee4dc",
      "name": "Update Availability Code"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "2b997bd7-0030-449a-a2af-540309f83bc7",
              "leftValue": "={{ $json.alternatives[0] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        11040,
        2448
      ],
      "id": "5373f268-ac4e-4c7b-ac06-65bb9d00c597",
      "name": "Update Alternative Found?"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {pendingUpdateAlternatives: JSON.stringify($json.alternatives)} }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        11328,
        2336
      ],
      "id": "3846c1a7-1b45-4cd4-ac37-99e0adefa140",
      "name": "set_userflag_pendingUpdateAlternatives",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "8d74700f-a97a-41ae-9bdb-7180825eeba9",
              "leftValue": "={{ $('Prepare Update Availability').first().json.finalBooking.employeeID }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "457b1321-d380-40cf-908b-6650e0aaf78a",
              "leftValue": "={{ $('Prepare Update Availability').first().json.finalBooking.employeeID }}",
              "rightValue": "NEXT_AVAILABLE",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        11504,
        2336
      ],
      "id": "f5cece48-9d51-4b6b-b0e6-839c1ed8b1db",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "const data = $('Prepare Update Availability').first().json;\nconst final = data.finalBooking;\nconst alternatives = $('Update Availability Code').first().json.alternatives;\n\nconst reqDt = new Date(final.datetime);\nconst displayTime = reqDt.toLocaleTimeString('en-US', {\n  hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n});\nconst displayDate = reqDt.toLocaleDateString('en-US', {\n  weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n});\n\nlet message = `Unfortunately, ${final.employeeName} isn't available at ${displayTime} on ${displayDate}.\\n\\n`;\n\nif (alternatives && alternatives[0]) {\n  message += `Their next opening is *${alternatives[0].dateDisplay} at ${alternatives[0].timeDisplay}*.\\n\\n`;\n  message += `Reply *\"yes\"* to use this time\\n`;\n  message += `Reply *\"other technician\"* to check ${displayTime} with someone else\\n`;\n  message += `Or tell me a different date & time!`;\n}\n\nreturn [{ json: { message } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11728,
        2240
      ],
      "id": "84c9b8e0-b132-4544-ba0e-75fb7d08bd19",
      "name": "Build Update Specific Employee Msg"
    },
    {
      "parameters": {
        "jsCode": "const data = $('Prepare Update Availability').first().json;\nconst final = data.finalBooking;\nconst alternatives = $('Update Availability Code').first().json.alternatives;\n\nconst reqDt = new Date(final.datetime);\nconst displayTime = reqDt.toLocaleTimeString('en-US', {\n  hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n});\nconst displayDate = reqDt.toLocaleDateString('en-US', {\n  weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n});\n\nlet message = `Unfortunately, no one is available at ${displayTime} on ${displayDate}.\\n\\n`;\n\nif (alternatives && alternatives[0]) {\n  message += `The next available opening is *${alternatives[0].dateDisplay} at ${alternatives[0].timeDisplay}* with ${alternatives[0].employeeName}.\\n\\n`;\n  message += `Reply *\"yes\"* to use this time\\n`;\n  message += `Or tell me a different date & time!`;\n}\n\nreturn [{ json: { message } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11728,
        2432
      ],
      "id": "cada32bd-d85a-4b80-9789-ede2216d184e",
      "name": "Build Update No Employees Msg"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11984,
        2320
      ],
      "id": "ce9aa2a2-ebac-4c7f-83c0-4f7823c12952",
      "name": "Present Update Alternatives",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I'm sorry, but I couldn't find any alternative appointment slots within the next 8 weeks for your requested service. Your appointment remains in place. \n\nPlease call us directly at [PHONE NUMBER] and we'll help you modify your appointment.\n\nThank you for your patience! ðŸ™",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        11312,
        2576
      ],
      "id": "dcf5d187-93a6-43bb-b06f-73e0ae88f2cf",
      "name": "No update availability (bug)",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bccf3c0-58f8-4918-b5c0-293e447f3d8d",
              "leftValue": "={{ $('Set Initial Data').first().json.messageBody.toLowerCase() }}",
              "rightValue": "confirm",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "84399309-0f0a-458f-9ffc-e6ba820c5b10",
              "leftValue": "={{ $('Set Initial Data').first().json.messageBody.toLowerCase() }}",
              "rightValue": "save",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "or"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        864,
        720
      ],
      "id": "abc73e5d-3e27-4d5e-98a2-1c6370b15a59",
      "name": "Message contains \"confirm\" or \"save\"?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Set Initial Data').first().json.messageBody.toLowerCase() }}",
                    "rightValue": "confirm",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "c4ff3e34-fbdb-49a6-b615-3e7d13576353"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CREATE_READY"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ba556ddb-9486-48cd-95cc-28d0c49d7a1d",
                    "leftValue": "={{ $('Set Initial Data').first().json.messageBody.toLowerCase() }}",
                    "rightValue": "save",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "UPDATE_READY"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1296,
        -2912
      ],
      "id": "a1504c8a-7cad-4fe7-8f14-63658e032042",
      "name": "Switch3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "03931919-6daf-4a73-a235-eb35bf285061",
              "leftValue": "={{ JSON.parse($('get_userflag_all').first().json.userflag.bookingModification || '{}').readyToSave }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1728,
        -2896
      ],
      "id": "d6cbff10-7fac-4dbc-b372-9e5c05a38e27",
      "name": "If6"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=It seems like you're trying to save appointment modificiation details without first selecting modification details. The word \"save\" is reserved for saving appointment modifications. Would you like to modify an existing appointment today?",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1952,
        -2800
      ],
      "id": "97ec6f29-f08e-4f81-b543-92316631d753",
      "name": "Notify user they dont have any pending modificaitons",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// EXECUTE UPDATE\n// Prepares booking update data for Google Sheets\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst redis = $('get_userflag_all').first().json.userflag || {};\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\nlet mod;\ntry {\n  mod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  throw new Error('No booking modification found');\n}\nconst orig = mod.originalAppointment;\nconst final = mod.finalBooking;\nconst changedFields = mod.changedFields || [];\n\n// Get Calendar Event ID from userBookings (orig doesn't carry it)\nlet calendarEventId = null;\nlet bookingId = null;\ntry {\n  const userBookings = JSON.parse(redis.userBookings || '[]');\n  const matchingBooking = userBookings.find(b => \n    String(b.row_number) === String(orig.rowNumber)\n  );\n  calendarEventId = matchingBooking?.['Calendar Event ID'] || null;\n  bookingId = matchingBooking?.['Booking ID'] || null;\n} catch (e) {}\n\nlet calendarColor = null;\ntry {\n  const cacheNode = $('Get Business Cache').first().json;\n  let employees;\n  if (typeof cacheNode.employees === 'string') {\n    employees = JSON.parse(cacheNode.employees);\n  } else if (Array.isArray(cacheNode.employees)) {\n    employees = cacheNode.employees;\n  } else {\n    const keys = Object.keys(cacheNode);\n    for (const key of keys) {\n      try {\n        const val = typeof cacheNode[key] === 'string' ? JSON.parse(cacheNode[key]) : cacheNode[key];\n        if (val && val.employees) {\n          employees = typeof val.employees === 'string' ? JSON.parse(val.employees) : val.employees;\n          break;\n        }\n      } catch (e2) { continue; }\n    }\n  }\n  if (employees && Array.isArray(employees)) {\n    const emp = employees.find(e => e.employeeID === (final.employeeID || orig.employeeID));\n    calendarColor = emp?.calendarColor || null;\n  }\n} catch (e) {}\n\nif (!orig || !final) {\n  throw new Error('Missing original or final booking data');\n}\n\n// Parse datetimes\nconst newStart = new Date(final.datetime);\n// Handle comma-separated durations (sum them for multi-service)\nlet duration;\nif (String(final.serviceDuration).includes(',')) {\n  duration = String(final.serviceDuration).split(',').reduce((sum, d) => sum + parseInt(d.trim()), 0);\n} else {\n  duration = parseInt(final.serviceDuration) || 45;\n}\nconst newEnd = new Date(newStart.getTime() + (duration * 60 * 1000));\n\nconst oldStart = new Date(orig.datetime);\nconst oldDuration = parseInt(orig.serviceDuration) || 45;\nconst oldEnd = new Date(oldStart.getTime() + (oldDuration * 60 * 1000));\n\n// Format for Google Sheets (Cancun local time - UTC-5)\nconst formatForSheets = (dt) => {\n  const d = new Date(dt);\n  const cancunTime = new Date(d.getTime() - (5 * 60 * 60 * 1000));\n  const month = cancunTime.getUTCMonth() + 1;\n  const day = cancunTime.getUTCDate();\n  const year = cancunTime.getUTCFullYear();\n  const hours = String(cancunTime.getUTCHours()).padStart(2, '0');\n  const mins = String(cancunTime.getUTCMinutes()).padStart(2, '0');\n  const secs = String(cancunTime.getUTCSeconds()).padStart(2, '0');\n  return `${month}/${day}/${year} ${hours}:${mins}:${secs}`;\n};\n\n// Format for blocked times (12-hour format)\nconst formatBlockedTime = (dt) => {\n  const d = new Date(dt);\n  const cancunTime = new Date(d.getTime() - (5 * 60 * 60 * 1000));\n  let hours = cancunTime.getUTCHours();\n  const mins = String(cancunTime.getUTCMinutes()).padStart(2, '0');\n  const ampm = hours >= 12 ? 'PM' : 'AM';\n  hours = hours % 12;\n  hours = hours ? hours : 12;\n  return `${hours}:${mins} ${ampm}`;\n};\n\nconst getDateStr = (dt) => {\n  const d = new Date(dt);\n  const cancunTime = new Date(d.getTime() - (5 * 60 * 60 * 1000));\n  return cancunTime.toISOString().split('T')[0];\n};\n\n// OLD blocked time info (to remove)\nconst oldDate = getDateStr(oldStart);\nconst oldBlockedRange = `${formatBlockedTime(oldStart)}-${formatBlockedTime(oldEnd)}`;\nconst oldMatchKey = `${oldDate}_${orig.employeeID}`;\n\n// NEW blocked time info (to add)\nconst newDate = getDateStr(newStart);\nconst newBlockedRange = `${formatBlockedTime(newStart)}-${formatBlockedTime(newEnd)}`;\nconst newMatchKey = `${newDate}_${final.employeeID}`;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// DETERMINE IF BLOCKED TIME UPDATE NEEDED\n// True if: datetime changed, technician changed, OR duration changed (service change)\n// Most robust: compare actual blocked time values\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nconst needsBlockedTimeUpdate = \n  oldBlockedRange !== newBlockedRange || \n  oldMatchKey !== newMatchKey;\n\n// Format confirmation message\nconst confirmDate = newStart.toLocaleDateString('en-US', {\n  weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n});\nconst confirmTime = newStart.toLocaleTimeString('en-US', {\n  hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n});\n\nreturn [{\n  json: {\n    // For Google Sheets Update\n    rowNumber: final.rowNumber,\n    bookingType: final.serviceName,\n    bookingTime: formatForSheets(newStart),\n    bookingEndTime: formatForSheets(newEnd),\n    bookingDate: getDateStr(newStart),\n    employeeID: final.employeeID,\n    technicianName: final.employeeName,\n    // Handle comma-separated prices (sum them for multi-service)\namount: String(final.servicePrice).includes(',') \n  ? String(final.servicePrice).split(',').reduce((sum, p) => sum + parseFloat(p.trim().replace(/[$]/g, '')), 0)\n  : parseFloat(String(final.servicePrice).replace(/[$,]/g, '')) || 0,\n    \n    // Blocked time management\n    needsBlockedTimeUpdate,\n    \n    // Old blocked time (to remove)\n    oldBlockedRange,\n    oldMatchKey,\n    oldEmployeeID: orig.employeeID,\n    oldDate,\n    \n    // New blocked time (to add)  \n    newBlockedRange,\n    newMatchKey,\n    newEmployeeID: final.employeeID,\n    newDate,\n    \n    // For original/changed tracking\n    \n    // For original/changed tracking\n    changedFields,\n    orig,\n    final,\n    calendarEventId,\n    calendarColor,\n    bookingId,\n    // For confirmation message\n    datetimeFormatted: `${confirmDate} at ${confirmTime}`,\n    service: final.serviceName,\n    technician: final.employeeName,\n    phone\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -2960
      ],
      "id": "6edd8f1a-ae3e-4b5d-b785-3b90dad87d4c",
      "name": "Execute Update"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "a80042fd-4850-4967-a48e-faf1cca0dfd2",
              "leftValue": "={{ $json.needsBlockedTimeUpdate }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2432,
        -2960
      ],
      "id": "66ce982d-a521-4b3f-98da-f9ee79a0a99c",
      "name": "Needs Update Blocked Time?"
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    ...data,\n    // For reading old employee row\n    searchDate: data.oldDate,\n    searchEmployeeID: data.oldEmployeeID,\n    removeBlockedRange: data.oldBlockedRange\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2896,
        -3216
      ],
      "id": "ae5e2e17-51fc-4339-8a5c-07e9a760d6fc",
      "name": "Calculate Old Blocked Time Info"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Match Key",
              "lookupValue": "={{ $json.oldMatchKey }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3104,
        -3216
      ],
      "id": "a5d41ced-1b9c-43d5-b70d-765efbc218e6",
      "name": "Read Old Employee Availability Row",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const data = $('Execute Update').first().json;\nconst sheetRow = $input.first().json;\n\n// Get current blocked times\nlet currentBlocked = sheetRow['Blocked Times'] || '';\nconst rangeToRemove = data.oldBlockedRange;\n\n// Remove the old blocked time range\nif (currentBlocked && rangeToRemove) {\n  const blockedArray = currentBlocked.split(',').map(s => s.trim()).filter(s => s);\n  const filtered = blockedArray.filter(range => range !== rangeToRemove);\n  currentBlocked = filtered.join(', ');\n}\n\nreturn [{\n  json: {\n    rowNumber: sheetRow.row_number,\n    blockedTimes: currentBlocked,\n    date_employeeID: data.oldMatchKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3312,
        -3216
      ],
      "id": "7e817fd1-e5eb-436b-9f54-1271889a2591",
      "name": "Remove Old Blocked Time (Code)"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "row_number": "={{ $json.rowNumber }}",
            "Blocked Times": "={{ $json.blockedTimes }}"
          },
          "matchingColumns": [
            "row_number"
          ],
          "schema": [
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Match Key",
              "displayName": "Match Key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee Name",
              "displayName": "Employee Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Working Hours",
              "displayName": "Working Hours",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Blocked Times",
              "displayName": "Blocked Times",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3520,
        -3216
      ],
      "id": "7a102c99-5cd5-431b-9dfe-c6196d99a8e1",
      "name": "Update Old Employee Availability",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Match Key",
              "lookupValue": "={{ $('Execute Update').first().json.newMatchKey }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3728,
        -3216
      ],
      "id": "4b59c6a1-7fc3-42e7-839e-53c7cac052f6",
      "name": "Read New Employee Availability Row",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const bookingData = $('Execute Update').first().json;\nconst availabilityRow = $('Read New Employee Availability Row').first().json;\n\nif (!availabilityRow) {\n  throw new Error(`No availability row found for ${bookingData.newEmployeeID} on ${bookingData.newDate}`);\n}\n\nconst currentBlockedTimes = availabilityRow['Blocked Times'] || '';\nconst newBlockedRange = bookingData.newBlockedRange;\n\nconsole.log('Current blocked times:', currentBlockedTimes);\nconsole.log('New range:', newBlockedRange);\n\n// Add new blocked range to existing\nconst updatedBlockedTimes = currentBlockedTimes.trim() === '' \n  ? newBlockedRange \n  : `${currentBlockedTimes}, ${newBlockedRange}`;\n\nconsole.log('Updated blocked times:', updatedBlockedTimes);\n\nreturn [{\n  json: {\n    matchKey: bookingData.newMatchKey,  // Use pre-computed matchKey from Execute Update\n    updatedBlockedTimes: updatedBlockedTimes\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4000,
        -3216
      ],
      "id": "9e86cb2e-542b-4fc1-9e72-6964a0352c75",
      "name": "Find and Update Blocked Times1"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 446414277,
          "mode": "list",
          "cachedResultName": "Employee Availability",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1wlDXKDaEkUmdY7LiJ953v5I9uaFZqVltOOCBCrIuGWQ/edit#gid=446414277"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Match Key": "={{ $json.matchKey }}",
            "Blocked Times": "={{ $json.updatedBlockedTimes }}"
          },
          "matchingColumns": [
            "Match Key"
          ],
          "schema": [
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Match Key",
              "displayName": "Match Key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Employee Name",
              "displayName": "Employee Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Working Hours",
              "displayName": "Working Hours",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Blocked Times",
              "displayName": "Blocked Times",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        4224,
        -3216
      ],
      "id": "1fb13b76-87e7-49d0-9590-39f417a387c4",
      "name": "Append or update row in sheet1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 569810801,
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=569810801"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "row_number": "={{ $('Execute Update').first().json.rowNumber }}",
            "Booking Type": "={{ $('Execute Update').first().json.bookingType }}",
            "Booking Time": "={{ $('Execute Update').first().json.bookingTime }}",
            "Booking  End Time": "={{ $('Execute Update').first().json.bookingEndTime }}",
            "Employee ID": "={{ $('Execute Update').first().json.employeeID }}",
            "Nail Technician": "={{ $('Execute Update').first().json.technicianName }}",
            "Amount": "={{ $('Execute Update').first().json.amount }}",
            "Booking Date": "={{ $('Execute Update').first().json.bookingDate }}"
          },
          "matchingColumns": [
            "row_number"
          ],
          "schema": [
            {
              "id": "Booking Type",
              "displayName": "Booking Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Booking Time",
              "displayName": "Booking Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Nail Technician",
              "displayName": "Nail Technician",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Contact ID",
              "displayName": "Contact ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Confirmed",
              "displayName": "Booking Confirmed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Amount",
              "displayName": "Amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Payment Method",
              "displayName": "Payment Method",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Tips",
              "displayName": "Tips",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Extra",
              "displayName": "Extra",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Booking  End Time",
              "displayName": "Booking  End Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Booking Date",
              "displayName": "Booking Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Booking ID",
              "displayName": "Booking ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Calendar Event ID",
              "displayName": "Calendar Event ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        4736,
        -2784
      ],
      "id": "bc91433d-7ffd-48b1-aa43-7ee4e4e02523",
      "name": "Update Booking Row",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Execute Update').first().json.phone }}",
        "fields": "bookingModification, pendingUpdateAlternatives, activeIntent, userBookings, updateReady, canBook"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5504,
        -2784
      ],
      "id": "9234afea-f157-4073-a9c2-a461d9f2c61e",
      "name": "Clear Update State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=âœ…  Appointment updated!\n\nðŸ“… {{ $('Execute Update').first().json.datetimeFormatted }}\nðŸ’… {{ $('Execute Update').first().json.service }}\nâœ¨ {{ $('Execute Update').first().json.technician }}\nðŸ“ Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\n\nSee you then! ðŸ’…",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5680,
        -2784
      ],
      "id": "75b6d2a1-f1d3-4a99-91af-e529e98926a4",
      "name": "Send Update Success",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "05b11548-1002-4040-8b8a-c9270c7d302f",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag?.pendingUpdateAlternatives }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4080,
        2064
      ],
      "id": "edeed3c4-7602-4e88-a8a8-5a2a02a996c8",
      "name": "pendingUpdateAlternatives?"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"required\": [\"action\"],\n  \"additionalProperties\": true,\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\"accept\", \"other_technician\", \"new_datetime\", \"cancel\", \"unclear\"]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        4896,
        1920
      ],
      "id": "78f28376-6a2e-4c0a-a1a7-44fc426f6768",
      "name": "Structured Output Parser10"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't understand your choice. Please reply \"yes\" to select this modification, \"other technician\" to try someone else, or tell me a different time.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5072,
        1824
      ],
      "id": "9f39d733-3ca9-4461-9ea1-e4370eeee8db",
      "name": "Alternative Selection Error1",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        4624,
        1920
      ],
      "id": "1ba66f30-acb2-4c93-9c85-67a1cec21343",
      "name": "Google Gemini Chat Model9",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's response: {{ $('Set Initial Data').first().json.messageBody }}\n\nPending alternative: {{ $('get_userflag_all').first().json.userflag.pendingUpdateAlternatives }}\n\nCurrent update state: {{ $('get_userflag_all').first().json.userflag.bookingModification }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You classify user responses to appointment update alternatives.\n\n## CONTEXT\n- User is UPDATING an existing appointment\n- They were shown ONE alternative time because their requested time was unavailable\n- The alternative is in \"Pending alternative\" (JSON with datetime, employeeID, employeeName, timeDisplay, dateDisplay)\n\n## OUTPUT FORMAT\n{\"action\": \"accept\" | \"other_technician\" | \"new_datetime\" | \"cancel\" | \"unclear\"}\n\n---\n\n## 1. ACCEPT (user accepts the alternative)\n\nUser is accepting the shown alternative time.\n\nTriggers:\n- \"yes\", \"yeah\", \"yep\", \"ok\", \"okay\", \"sure\"\n- \"sounds good\", \"perfect\", \"that works\"\n- \"book it\", \"do it\", \"let's do it\"\n- \"I'll take it\", \"that one\"\n\nExamples:\n- \"yes\" â†’ {\"action\": \"accept\"}\n- \"that works\" â†’ {\"action\": \"accept\"}\n- \"sure, book it\" â†’ {\"action\": \"accept\"}\n\n---\n\n## 2. OTHER_TECHNICIAN (try with different technician)\n\nUser wants to check their ORIGINAL requested time with a DIFFERENT technician.\n\nTriggers:\n- \"other technician\", \"another technician\", \"different technician\"\n- \"someone else\", \"anybody else\", \"whoever else\"\n- \"try another tech\", \"check other technicians\"\n- \"different person\", \"another stylist\"\n\nNOT specific names - those go to new_datetime.\n\nExamples:\n- \"other technician\" â†’ {\"action\": \"other_technician\"}\n- \"try someone else\" â†’ {\"action\": \"other_technician\"}\n\n---\n\n## 3. NEW_DATETIME (user provides different time)\n\nUser is rejecting the alternative and providing a NEW time/date.\n\nTriggers:\n- Any specific time: \"3pm\", \"at 2\", \"10 in the morning\"\n- Any specific date: \"tomorrow\", \"Monday\", \"next week\"\n- Combined: \"tomorrow at 3pm\", \"Monday morning\"\n- Rejection + new time: \"no, how about 4pm\"\n- Specific technician name (treat as new request): \"with Sarah instead\"\n\nExamples:\n- \"no, how about 3pm\" â†’ {\"action\": \"new_datetime\"}\n- \"tomorrow instead\" â†’ {\"action\": \"new_datetime\"}\n- \"can we do 2pm on Monday\" â†’ {\"action\": \"new_datetime\"}\n- \"with David instead\" â†’ {\"action\": \"new_datetime\"}\n\n---\n\n## 4. CANCEL (user wants to cancel the update)\n\nUser wants to abandon the update entirely.\n\nTriggers:\n- \"cancel\", \"never mind\", \"forget it\"\n- \"stop\", \"quit\", \"exit\"\n- \"keep my original appointment\", \"don't change it\"\n\nExamples:\n- \"never mind\" â†’ {\"action\": \"cancel\"}\n- \"keep my original\" â†’ {\"action\": \"cancel\"}\n\n---\n\n## 5. UNCLEAR (can't determine intent)\n\nResponse doesn't match any category.\n\nExamples:\n- \"hello\" â†’ {\"action\": \"unclear\"}\n- \"what?\" â†’ {\"action\": \"unclear\"}\n- random unrelated text â†’ {\"action\": \"unclear\"}\n\n---\n\n## RULES\n- Default to \"accept\" if response seems positive but ambiguous\n- Default to \"new_datetime\" if user mentions ANY time or date\n- Default to \"unclear\" only if truly uninterpretable\n- Always output valid JSON, nothing else\n\n",
          "maxIterations": 2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4704,
        1696
      ],
      "id": "bdeb7d89-12b2-4552-a0ba-f17afe37765d",
      "name": "Update Alternative Selection Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "accept",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "2ff3c3ae-25af-415f-98d5-5fff433ebdfc"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ACCEPT"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "397da50e-22da-430b-b248-e8d804bc2a0f",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "other_technician",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "OTHER_TECH"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7d744067-bfef-4c3a-b5bc-2ef3978cbf61",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "new_datetime",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": " NEW_DATETIME"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "0d0a725c-323a-433c-b115-09bf548e5d92",
                    "leftValue": "={{ $json.output.action }}",
                    "rightValue": "cancel",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CANCEL"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b5102a87-26ed-4ad5-acc9-ca424f75e327",
                    "leftValue": "=true",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "=UNCLEAR"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        5504,
        1632
      ],
      "id": "e80b8ba0-45a6-4142-9d57-00eebc83bec8",
      "name": "Switch4"
    },
    {
      "parameters": {
        "jsCode": "// User accepted the alternative time - prepare for confirmation (NOT immediate execution)\nconst userflag = $('get_userflag_all').first().json.userflag || {};\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Get the accepted alternative\nlet alternatives;\ntry {\n  alternatives = JSON.parse(userflag.pendingUpdateAlternatives || '[]');\n} catch (e) {\n  throw new Error('Failed to parse pending alternatives');\n}\n\nif (!alternatives || alternatives.length === 0) {\n  throw new Error('No pending alternatives found');\n}\n\nconst accepted = alternatives[0]; // We only show one alternative\n\n// Get current booking modification state\nlet mod;\ntry {\n  mod = JSON.parse(userflag.bookingModification || '{}');\n} catch (e) {\n  throw new Error('Failed to parse booking modification');\n}\n\n// Get original appointment details\nconst orig = mod.originalAppointment || {};\n\n// Ensure orig has serviceDuration\nif (orig.rowNumber && !orig.serviceDuration) {\n  try {\n    const userBookings = JSON.parse(userflag.userBookings || '[]');\n    const matchingBooking = userBookings.find(b => \n      String(b.row_number) === String(orig.rowNumber)\n    );\n    if (matchingBooking && matchingBooking.duration) {\n      orig.serviceDuration = String(matchingBooking.duration);\n    }\n  } catch (e) {}\n}\n\n// Update the modification with accepted alternative\nmod.proposedChanges = mod.proposedChanges || {};\nmod.proposedChanges.datetime = accepted.datetime;\nmod.proposedChanges.employeeID = accepted.employeeID;\nmod.proposedChanges.employeeName = accepted.employeeName;\n\n// Build finalBooking with all required fields\nmod.finalBooking = {\n  rowNumber: orig.rowNumber,\n  serviceID: mod.proposedChanges.serviceID || orig.serviceID,\n  serviceName: mod.proposedChanges.serviceName || orig.service,\n  serviceDuration: mod.proposedChanges.serviceDuration || orig.serviceDuration || '45',\n  servicePrice: mod.proposedChanges.servicePrice || orig.servicePrice,\n  datetime: accepted.datetime,\n  employeeID: accepted.employeeID,\n  employeeName: accepted.employeeName\n};\n\n// Mark availability as confirmed but NOT ready to save (user must say \"save\" first)\nmod.availabilityConfirmed = true;\nmod.readyToSave = true;\n\n// Ensure changedFields includes datetime if not already\nif (!mod.changedFields) {\n  mod.changedFields = [];\n}\nif (!mod.changedFields.includes('datetime')) {\n  mod.changedFields.push('datetime');\n}\nif (!mod.changedFields.includes('technician')) {\n  mod.changedFields.push('technician');\n}\n\n// Format confirmation message\nconst formatDt = (iso) => {\n  const d = new Date(iso);\n  const date = d.toLocaleDateString('en-US', {\n    weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n  });\n  const time = d.toLocaleTimeString('en-US', {\n    hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n  });\n  return `${date} at ${time}`;\n};\n\nlet message = \"Here's your updated appointment summary:\\n\\n\";\n\n// Show datetime with arrow if changed\nif (mod.changedFields.includes('datetime')) {\n  message += `ðŸ“… ${formatDt(orig.datetime)} â†’ *${formatDt(accepted.datetime)}*\\n`;\n} else {\n  message += `ðŸ“… ${formatDt(accepted.datetime)}\\n`;\n}\n\n// Show service with arrow if changed\nif (mod.changedFields.includes('service')) {\n  message += `ðŸ’… ${orig.service} â†’ *${mod.finalBooking.serviceName}* ($${mod.finalBooking.servicePrice})\\n`;\n} else {\n  message += `ðŸ’… ${mod.finalBooking.serviceName} ($${mod.finalBooking.servicePrice})\\n`;\n}\n\n// Show technician with arrow if changed\nif (mod.changedFields.includes('technician')) {\n  message += `âœ¨ ${orig.technician} â†’ *${accepted.employeeName}*\\n`;\n} else {\n  message += `âœ¨ ${accepted.employeeName}\\n`;\n}\n\nmessage += `ðŸ“ Avenida KukulkÃ¡n 230, Zona Hotelera, CancÃºn\\n\\n`;\nmessage += `Reply *\"save\"* to confirm these changes.`;\n\nreturn [{\n  json: {\n    phone,\n    bookingModification: JSON.stringify(mod),\n    mod,\n    message,\n    readyForConfirmation: true\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5776,
        1312
      ],
      "id": "96f3650f-764e-43e1-809a-a34f31a63846",
      "name": "Accept Update Alternative"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { bookingModification: $json.bookingModification, pendingUpdateAlternatives: '', readyToSave: 'true' } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        5952,
        1312
      ],
      "id": "2689f1ba-1a22-42fd-bdf6-ca64b3406185",
      "name": "Set Accept Update State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// User wants to try original time with different technician\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst userflag = $('get_userflag_all').first().json.userflag || {};\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\nlet mod;\ntry {\n  mod = JSON.parse(userflag.bookingModification || '{}');\n} catch (e) {\n  mod = {};\n}\n\n// Set technician to NEXT_AVAILABLE\nmod.proposedChanges = mod.proposedChanges || {};\nmod.proposedChanges.employeeID = 'NEXT_AVAILABLE';\nmod.proposedChanges.employeeName = 'Next Available';\n\n// Get original and proposed data\nconst orig = mod.originalAppointment || {};\nconst proposed = mod.proposedChanges || {};\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// DETERMINE CORRECT DURATION:\n// - If service is being changed: use proposed.serviceDuration (from list_services)\n// - Otherwise: use original booking's duration (from userBookings)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nlet finalDuration;\nif (proposed.serviceDuration) {\n  // User changed service - use new duration\n  finalDuration = proposed.serviceDuration;\n} else if (orig.serviceDuration) {\n  // User didn't change service - use original booking's duration\n  finalDuration = orig.serviceDuration;\n} else {\n  // Fallback: should not happen with Count Bookings fix\n  finalDuration = '45';\n}\n\nmod.finalBooking = {\n  rowNumber: orig.rowNumber,\n  serviceID: proposed.serviceID || orig.serviceID,\n  serviceName: proposed.serviceName || orig.service,\n  serviceDuration: finalDuration,\n  servicePrice: proposed.servicePrice || orig.servicePrice,\n  datetime: proposed.datetime || orig.datetime,\n  employeeID: 'NEXT_AVAILABLE',\n  employeeName: 'Next Available'\n};\n\n// Reset availability confirmation\nmod.availabilityConfirmed = false;\nmod.readyToSave = false;\n\n// Ensure technician is in changed fields\nif (!mod.changedFields) {\n  mod.changedFields = [];\n}\nif (!mod.changedFields.includes('technician')) {\n  mod.changedFields.push('technician');\n}\n\nreturn [{\n  json: {\n    phone,\n    bookingModification: JSON.stringify(mod),\n    mod,\n    // Data formatted for Prepare Update Availability\n    finalBooking: mod.finalBooking,\n    originalAppointment: mod.originalAppointment,\n    changedFields: mod.changedFields\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5776,
        1504
      ],
      "id": "495fa1ee-4e2d-4f98-8e59-f7476ea030aa",
      "name": "Set Update NEXT_AVAILABLE"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {\n    bookingModification: $json.bookingModification,\n    pendingUpdateAlternatives: ''\n  } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        5984,
        1504
      ],
      "id": "47559cfa-fc79-407c-a256-1eac1faaa3cb",
      "name": "Clear Update Alternatives & Set NEXT",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "pendingUpdateAlternatives"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5760,
        1680
      ],
      "id": "1b689535-cc2f-4d0c-9de9-a60ffb4bcc58",
      "name": "Clear Update Alternatives",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "bookingModification, pendingUpdateAlternatives, activeIntent"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        5760,
        1856
      ],
      "id": "3db2cb97-c493-46bc-89c7-a5537a64d2f6",
      "name": "Clear All Update State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const userflag = $('get_userflag_all').first().json.userflag || {};\n\nlet alternatives;\ntry {\n  alternatives = JSON.parse(userflag.pendingUpdateAlternatives || '[]');\n} catch (e) {\n  alternatives = [];\n}\n\nif (alternatives.length === 0) {\n  return [{\n    json: {\n      message: \"I'm sorry, I didn't understand. What would you like to do with your appointment?\"\n    }\n  }];\n}\n\nconst alt = alternatives[0];\n\nconst message = `I didn't quite catch that. \n\nThe next available time is *${alt.dateDisplay} at ${alt.timeDisplay}* with ${alt.employeeName}.\n\nReply *\"yes\"* to use this time\nReply *\"other technician\"* to check with someone else\nOr tell me a different date & time!`;\n\nreturn [{\n  json: { message }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5760,
        2048
      ],
      "id": "adcfdfe8-c47d-46f7-91f1-145d3a7e6600",
      "name": "Repeat Update Alternatives"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5984,
        2048
      ],
      "id": "27dbe7d5-cf19-4f45-bb90-16186bd25ff7",
      "name": "Send Repeat Update Alternatives",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=No problem! Your original appointment remains unchanged. \n\n  Is there anything else I can help you with?",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5968,
        1856
      ],
      "id": "9211f55f-e7ae-43cc-b4f8-00149d089dc5",
      "name": "Send Update Cancelled",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I had trouble understanding your request. Please include specific details like the new service name, date, and time you'd like. Example: \"Express manicure tomorrow at 2pm\".\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        7600,
        2128
      ],
      "id": "0af67755-2b2b-469e-8a98-bea227e2ca2e",
      "name": "Extractor Error1",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't understand your choice. Please confirm which appointment you'd like to modify.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        7184,
        2832
      ],
      "id": "62cd4e09-7cc4-479a-8d46-2f8ed515aaf8",
      "name": "Alternative Selection Error2",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User Message: {{ $json.userMessage }}\n\nCurrently Modifying This Appointment:\n- Row: {{ $json.originalAppointment.rowNumber }}\n- Service: {{ $json.originalAppointment.service }}\n- Date: {{ $json.originalAppointment.dateDisplay }}\n- Time: {{ $json.originalAppointment.timeDisplay }}\n- Technician: {{ $json.originalAppointment.technician }}\n\nPending Changes Already Requested: {{ JSON.stringify($json.proposedChanges) }}\n\nUser's Other Appointments:\n{{ JSON.stringify($json.userBookings) }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "==## Context Switch Identifier\nDetermine if user wants to CONTINUE modifying their current appointment or SWITCH to modify a different appointment.\n\n## YOUR ONLY JOB\nAnalyze the user's message and decide:\n- **CONTINUE**: User is adding/changing details for the SAME appointment they're already modifying\n- **SWITCH**: User explicitly wants to modify a DIFFERENT appointment instead\n\n## DECISION RULES\n\n### Return \"CONTINUE\" when user:\n- Provides new desired values (time, date, service, technician)\n- Says things like \"actually make it...\", \"change it to...\", \"I want...\"\n- Mentions a technician name â†’ They want to CHANGE TO that technician\n- Mentions a time/date â†’ They want to MOVE TO that time/date\n- Makes any modification request without explicitly referencing a different booking\n- Uses any language (Spanish, English, etc.) to request changes\n- Gives simple responses like \"1:30\", \"tomorrow\", \"deluxe\", \"David\"\n\n### Return \"SWITCH\" when user EXPLICITLY:\n- References a completely different appointment they want to modify instead\n- Says they selected the wrong booking\n- Rejects the current selection: \"no\", \"not that one\", \"wrong one\", \"the other one\"\n- Wants to cancel current modification and start over with different booking\n- Identifies a different appointment: \"my Thursday one\", \"the 3pm appointment\"\n- Says \"no, I meant...\" followed by different appointment details\n\n## CRITICAL\n- DEFAULT to \"CONTINUE\" if there's any ambiguity\n- Mentioning details that match another booking is NOT a switch request\n- \"I want David Martinez\" = CONTINUE (change technician TO David)\n- \"I want to modify my appointment with David Martinez instead\" = SWITCH\n- \"no, not that one\" = SWITCH (rejecting current selection)\n- \"1:30\" = CONTINUE (providing the change they want)\n\n## OUTPUT FORMAT\nRespond with ONLY this JSON, nothing else:\n\nFor continue:\n{\"decision\": \"CONTINUE\", \"reason\": \"brief explanation\"}\n\nFor switch:\n{\"decision\": \"SWITCH\", \"reason\": \"brief explanation\"}\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4736,
        2304
      ],
      "id": "55e80ce9-ac9b-4ba0-935d-2400b2b2c6ea",
      "name": "Context Switch Identifier Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"required\": [\"decision\"],\n  \"additionalProperties\": true,\n  \"properties\": {\n    \"decision\": {\n      \"type\": \"string\",\n      \"enum\": [\"CONTINUE\", \"SWITCH\"]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        4944,
        2528
      ],
      "id": "cafc7b1c-6576-473f-bb4f-8e6968834eac",
      "name": "Structured Output Parser11"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        4688,
        2528
      ],
      "id": "c9d6da30-70a2-4341-a0cf-cabba6127731",
      "name": "Google Gemini Chat Model10",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't understand your choice. Please confirm which appointment you'd like to modify.\n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5184,
        2480
      ],
      "id": "15a52b1b-9004-4aa2-904a-9e30c5dce6ce",
      "name": "Alternative Selection Error3",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "CONTINUE",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e9aa89d6-3186-4221-b1da-566b8e73b3b8"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONTINUE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ae28891c-5d8e-4809-8753-93ff9d515480",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "SWITCH",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SWITCH"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        5488,
        2288
      ],
      "id": "e0902a85-1197-45e3-bbcf-c3b5abbf5bf9",
      "name": "Switch5"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Accept Update Alternative').first().json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        6144,
        1312
      ],
      "id": "021ed982-7b30-4ca7-bcbb-559b9e4ce11f",
      "name": "Send Update Confirmation",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process the selection result from Update Selector Agent\nconst selector = $('Update Selector Agent').first().json.output;\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\nif (selector.status === 'identified') {\n  // Build the modification object with awaiting flag\n  const bookingModification = {\n    originalAppointment: {\n      rowNumber: selector.rowNumber,\n      service: selector.service,\n      datetime: selector.datetime,\n      technician: selector.technician,\n      employeeID: selector.employeeID,\n      dateDisplay: selector.dateDisplay,\n      timeDisplay: selector.timeDisplay\n    },\n    selectionStatus: 'identified',\n    awaitingChangeRequest: true,\n    proposedChanges: {},\n    changedFields: []\n  };\n\n  // Build the response message\n  const message = `I found your ${selector.service} appointment on ${selector.dateDisplay} at ${selector.timeDisplay} with ${selector.technician}.\\n\\nWhat would you like to change?`;\n\n  return [{\n    json: {\n      status: 'identified',\n      bookingModification,\n      message,\n      phone\n    }\n  }];\n} else {\n  // needs_clarification - pass through to existing clarification flow\n  return [{\n    json: {\n      status: 'needs_clarification',\n      allAppointments: selector.allAppointments,\n      phone\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7024,
        2544
      ],
      "id": "bf4350f2-2006-4427-b334-859c4ba1a972",
      "name": "Process Selection Result"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "identified",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "959f034b-bb4d-4beb-9b6c-9fc6f37e0061"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "identified"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "98e74b38-3777-4c62-85e4-18e174654004",
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "needs_clarification",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "needs_clarification"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        7200,
        2544
      ],
      "id": "ba6b627c-ced8-42af-94d0-5a72cbe3720c",
      "name": "Selection Status Switch"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { bookingModification: JSON.stringify($json.bookingModification) } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        7424,
        2448
      ],
      "id": "feab6dcd-dde8-46ad-ab7a-ee99d324cb32",
      "name": "Save Selection & Await Change",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        7616,
        2448
      ],
      "id": "43cbf139-290a-4c20-8055-8c199472bbf5",
      "name": "Ask What To Change",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Check if we're awaiting a change request\nconst redis = $('get_userflag_all').first().json.userflag || {};\nconst userMessage = $('Set Initial Data').first().json.messageBody;\nconst userBookings = redis.userBookings || '[]';\n\nlet bookingMod;\ntry {\n  bookingMod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  bookingMod = {};\n}\n\n// Key decision: are we awaiting a change request?\nconst awaitingChangeRequest = bookingMod.awaitingChangeRequest === true;\n\n// If awaiting, clear the flag (will be saved downstream)\nif (awaitingChangeRequest) {\n  bookingMod.awaitingChangeRequest = false;\n}\n\n// Check if we have an active modification (appointment already selected)\nconst hasActiveModification = !!(\n  bookingMod.originalAppointment && \n  bookingMod.originalAppointment.rowNumber\n);\n\nreturn [{\n  json: {\n    awaitingChangeRequest,\n    hasActiveModification,\n    originalAppointment: bookingMod.originalAppointment || null,\n    proposedChanges: bookingMod.proposedChanges || {},\n    changedFields: bookingMod.changedFields || [],\n    bookingModification: bookingMod,\n    userMessage,\n    userBookings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4320,
        2080
      ],
      "id": "a87755cf-68ba-48c9-bdb8-443f7155ca57",
      "name": "Check Awaiting Flag"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "291b6590-d9dc-4b29-8c0e-ce80010681c2",
              "leftValue": "={{ $json.awaitingChangeRequest }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "cf17d264-afa4-473d-a809-b4ee18bb8e6d",
              "leftValue": "={{ $json.hasActiveModification }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4480,
        2176
      ],
      "id": "c58f4c69-136b-47b5-b0bf-794c691b843c",
      "name": "Awaiting Route Switch"
    },
    {
      "parameters": {
        "jsCode": "const allAppointments = $json.allAppointments || [];\n\nlet message = \"Which appointment would you like to update?\\n\\n\";\n\nallAppointments.forEach((apt, i) => {\n  message += `${i + 1}. ${apt.service} - ${apt.dateDisplay}, ${apt.timeDisplay} with ${apt.technician}\\n`;\n});\n\nmessage += \"\\nReply with the number or describe which one.\";\n\nreturn [{\n  json: {\n    message,\n    phone: $json.phone\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7424,
        2688
      ],
      "id": "63db4dfb-296c-4fbb-9fbc-ca3b22c93096",
      "name": "Ask Which Appointment Code"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        7648,
        2688
      ],
      "id": "8b35e244-ec9e-4f8e-9825-998f5c302577",
      "name": "Ask Which Appointment Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ { updateReady: \"true\" } }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        11056,
        2096
      ],
      "id": "18146448-c380-4c84-8f89-dd374a2ea024",
      "name": "set_userflag_Ready",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prep Extractor - Initialize retry counter + handle ambiguous clarification\n// Place before Extractor Agent\n\nconst input = $input.first().json;\nconst redis = $('get_userflag_all').first().json.userflag || {};\nconst userMessage = $('Set Initial Data').first().json.messageBody || '';\n\n// Check if this is a retry (coming from Increment Retry node)\nlet extractorRetry = 0;\ntry {\n  extractorRetry = $('Increment Extractor Retry').first().json.extractorRetry || 0;\n} catch (e) {\n  extractorRetry = 0;\n}\n\n// Handle ambiguous service clarification\nlet enhancedMessage = userMessage;\nconst ambiguousService = redis.ambiguousService || '';\n\nif (ambiguousService) {\n  // User might be clarifying the ambiguous service\n  // Combine: previous ambiguous + current message\n  // Let the Extractor Agent figure out if this makes a valid service\n  enhancedMessage = `${ambiguousService} ${userMessage}`;\n}\n\nreturn [{\n  json: {\n    ...input,\n    extractorRetry,\n    originalMessage: userMessage,\n    enhancedMessage: enhancedMessage,\n    hadAmbiguousContext: !!ambiguousService\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6944,
        288
      ],
      "id": "7758ae5a-377e-4e1f-8303-7bc083b68ea6",
      "name": "Prep Extractor"
    },
    {
      "parameters": {
        "jsCode": "// Prep Update Extractor - Initialize retry counter + handle ambiguous clarification\nconst input = $input.first().json;\nconst redis = $('get_userflag_all').first().json.userflag || {};\nconst userMessage = $('Set Initial Data').first().json.messageBody || '';\n\n// Check if this is a retry\nlet extractorRetry = 0;\ntry {\n  extractorRetry = $('Increment Update Extractor Retry').first().json.extractorRetry || 0;\n} catch (e) {\n  extractorRetry = 0;\n}\n\n// Handle ambiguous service clarification from previous turn\nlet enhancedMessage = userMessage;\nlet ambiguousContext = '';\n\n// Check bookingModification for ambiguous service (Update flow stores here)\nlet bookingMod;\ntry {\n  bookingMod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  bookingMod = {};\n}\n\nconst ambiguousService = bookingMod.ambiguousService || redis.ambiguousService || '';\n\n// Get possible matches from the previous ambiguous result\nconst possibleMatches = bookingMod.possibleMatches || [];\n\nif (ambiguousService && possibleMatches.length > 0) {\n  // Try to find exact match from possibleMatches using user's clarification\n  const userLower = userMessage.toLowerCase().trim();\n  const exactMatch = possibleMatches.find(m => \n    m.toLowerCase().includes(userLower) || userLower.includes(m.toLowerCase().split(' ').pop())\n  );\n  \n  if (exactMatch) {\n    // User clarified with a word that matches one of the options\n    enhancedMessage = exactMatch;\n    ambiguousContext = `The user was previously asked to choose between: ${possibleMatches.join(', ')}. They replied \"${userMessage}\" which means they want: ${exactMatch}. Extract this as a service change.`;\n  } else {\n    enhancedMessage = `${ambiguousService} ${userMessage}`;\n    ambiguousContext = `The user was previously asked to choose between: ${possibleMatches.join(', ')}. They replied \"${userMessage}\". Match their reply to one of these options and extract it as a service change.`;\n  }\n} else if (ambiguousService) {\n  enhancedMessage = `${ambiguousService} ${userMessage}`;\n  ambiguousContext = `The user previously requested \"${ambiguousService}\" which was ambiguous. They are now clarifying with \"${userMessage}\". Combine these to find the correct service and extract it as a service change.`;\n}\n\nreturn [{\n  json: {\n    ...input,\n    extractorRetry,\n    originalMessage: userMessage,\n    enhancedMessage: enhancedMessage,\n    hadAmbiguousContext: !!ambiguousService,\n    ambiguousContext: ambiguousContext\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6480,
        1680
      ],
      "id": "cb2e783c-d30a-4182-8d75-3872636ec815",
      "name": "Prep Update Extractor"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "8a628776-41ea-484b-b5c3-ef3e9cbe4247",
              "leftValue": "={{ $('Prep Update Extractor').first().json.extractorRetry }}",
              "rightValue": 2,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        7312,
        1904
      ],
      "id": "4633131a-37ed-483b-b7d7-b0a3ab641091",
      "name": "Should Retry Update Extractor?"
    },
    {
      "parameters": {
        "jsCode": "// Increment Update Extractor Retry\nconst currentRetry = $('Prep Update Extractor').first().json.extractorRetry || 0;\nconsole.log(`Update Extractor retry attempt ${currentRetry + 1} of 2`);\n\nreturn [{\n  json: {\n    ...$('Prep Update Extractor').first().json,\n    extractorRetry: currentRetry + 1\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7600,
        1888
      ],
      "id": "11a4139f-9127-46ac-ae10-f820161cb8dc",
      "name": "Increment Update Extractor Retry"
    },
    {
      "parameters": {
        "jsCode": "// Increment Extractor Retry\n// This loops back to Extractor Agent for another attempt\n\nconst currentRetry = $('Prep Extractor').first().json.extractorRetry || 0;\n\n// Log the retry for debugging\nconsole.log(`Extractor retry attempt ${currentRetry + 1} of 2`);\n\nreturn [{\n  json: {\n    // Pass through all the original data\n    ...$('Prep Extractor').first().json,\n    // Increment the retry counter\n    extractorRetry: currentRetry + 1\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7920,
        288
      ],
      "id": "67a28a94-6df9-40ae-9791-59f15ce45618",
      "name": "Increment Extractor Retry"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "8a628776-41ea-484b-b5c3-ef3e9cbe4247",
              "leftValue": "={{ $('Prep Extractor').first().json.extractorRetry }}",
              "rightValue": 2,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        7680,
        304
      ],
      "id": "d0fa8cab-7afd-4a67-a784-106afd1ac55e",
      "name": "Should Retry Extractor?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "811478d9-4195-4317-9331-3c251ab76657",
              "leftValue": "={{ $json.routeToCancel }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        7568,
        1664
      ],
      "id": "ebf70272-d8cb-400a-879b-8d4ab8677ad7",
      "name": "Route to Cancel Check"
    },
    {
      "parameters": {
        "jsCode": "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PREPARE CANCEL REDIRECT\n// User tried to remove the only service from a single-service booking\n// We need to redirect them to the cancel flow\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst stateMergerOutput = $('Update State Merger').first().json;\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Get the original appointment details for the message\nlet originalAppointment = null;\ntry {\n  const mod = stateMergerOutput.mod || {};\n  originalAppointment = mod.originalAppointment || null;\n} catch (e) {\n  // Continue without appointment details\n}\n\n// Build user-friendly message\nlet message = \"\";\n\nif (originalAppointment) {\n  const formatDt = (iso) => {\n    if (!iso) return 'your appointment';\n    const d = new Date(iso);\n    const date = d.toLocaleDateString('en-US', {\n      weekday: 'long', month: 'long', day: 'numeric', timeZone: 'America/Cancun'\n    });\n    const time = d.toLocaleTimeString('en-US', {\n      hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Cancun'\n    });\n    return `${date} at ${time}`;\n  };\n  \n  message = `Your ${originalAppointment.service} appointment on ${formatDt(originalAppointment.datetime)} only has one service.\\n\\n`;\n  message += `To remove it, you'll need to cancel the appointment.\\n\\n`;\n  message += `Would you like to cancel this appointment? Reply *\"yes\"* to cancel or *\"no\"* to keep it.`;\n} else {\n  message = `This appointment only has one service. To remove it, you'll need to cancel the entire appointment.\\n\\n`;\n  message += `Would you like me to help you cancel? Reply *\"yes\"* or *\"no\"*.`;\n}\n\n// Store the row number so cancel flow knows which appointment\nconst rowToCancel = originalAppointment?.rowNumber || null;\n\nreturn [{\n  json: {\n    phone,\n    message,\n    rowToCancel,\n    originalAppointment,\n    cancelReason: stateMergerOutput.cancelReason || 'single_service_removal'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7904,
        1504
      ],
      "id": "0fbab56b-fc12-4167-95ba-2ae12a33e6cf",
      "name": "Prepare Cancel Redirect"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ {\n  bookingModification: '',\n  pendingUpdateAlternatives: '',\n  activeIntent: 'CANCEL_BOOKING',\n  pendingCancelRow: $json.rowToCancel ? String($json.rowToCancel) : ''\n} }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        8080,
        1504
      ],
      "id": "a76dc54c-94ec-482a-bdec-0b8762063dd0",
      "name": "Clear Update State for Cancel",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Prepare Cancel Redirect').first().json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        8256,
        1504
      ],
      "id": "41663a27-fd9e-4e20-89dd-cfe523a1b86e",
      "name": "Single Service Removal Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "confirmState",
        "key": "=confirm_state_{{ $json.phoneNumber }}",
        "options": {}
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        -2224,
        720
      ],
      "id": "da5e1217-56b2-4c3d-b9ca-aaeaef43eb30",
      "name": "Check Confirm State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "4669f98e-bf43-4efa-9eb2-ae2c8b395326",
              "leftValue": "={{ $json.confirmState.state }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2064,
        720
      ],
      "id": "8f780273-6b72-4290-8ac5-8dc7becc622c",
      "name": "Has Confirm State?"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "business_data",
        "keyType": "hash",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -1776,
        736
      ],
      "id": "6d323cf9-0b38-4a61-a67e-8b77fa8a867b",
      "name": "Get Business Cache",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const bookingId = 'BK-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6);\n\n// Resolve calendar color from business cache\nlet calendarColor = null;\ntry {\n  const cacheNode = $('Get Business Cache').first().json;\n  \n  // Handle various cache data shapes\n  let employees;\n  if (typeof cacheNode.employees === 'string') {\n    employees = JSON.parse(cacheNode.employees);\n  } else if (Array.isArray(cacheNode.employees)) {\n    employees = cacheNode.employees;\n  } else if (typeof cacheNode.propertyName === 'string') {\n    const parsed = JSON.parse(cacheNode.propertyName);\n    employees = typeof parsed.employees === 'string' \n      ? JSON.parse(parsed.employees) \n      : parsed.employees;\n  } else {\n    // Try parsing the whole thing\n    const keys = Object.keys(cacheNode);\n    for (const key of keys) {\n      try {\n        const val = typeof cacheNode[key] === 'string' ? JSON.parse(cacheNode[key]) : cacheNode[key];\n        if (val.employees) {\n          employees = typeof val.employees === 'string' ? JSON.parse(val.employees) : val.employees;\n          break;\n        }\n      } catch (e) { continue; }\n    }\n  }\n  \n  if (employees && Array.isArray(employees)) {\n    const empId = $input.first().json.userflag?.employeeID;\n    if (empId) {\n      const emp = employees.find(e => e.employeeID === empId);\n      calendarColor = emp?.calendarColor || null;\n    }\n  }\n} catch (e) {\n  // Silent fail - color is nice-to-have, not critical\n}\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    bookingId,\n    calendarColor\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2320,
        -4032
      ],
      "id": "eb719e6a-8562-4d7b-bb88-3b4f3caa90ed",
      "name": "UID Generation"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        7024,
        560
      ],
      "id": "a64a0369-9a5f-46dd-9e14-1385215a14c0",
      "name": "gemini-2.5-flash1",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "kDwF9EEhYLEqaDuf",
          "mode": "list",
          "cachedResultUrl": "/workflow/kDwF9EEhYLEqaDuf",
          "cachedResultName": "Booking Confirmation System Queue"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "phoneNumber": "={{ $('Set Initial Data').item.json.userPhoneNumber }}",
            "messageBody": "={{ $('Set Initial Data').first().json.messageBody.toLowerCase() }}",
            "confirmState": "={{ $('Check Confirm State').item.json.confirmState.state }}",
            "bookingInfo": "={{ $('Check Confirm State').item.json.confirmState.bookingInfo }}"
          },
          "matchingColumns": [
            ""
          ],
          "schema": [
            {
              "id": "phoneNumber",
              "displayName": "phoneNumber",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "messageBody",
              "displayName": "messageBody",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "confirmState",
              "displayName": "confirmState",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "bookingInfo",
              "displayName": "bookingInfo",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": true,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -1408,
        368
      ],
      "id": "13b3efcf-7ed0-4fd9-9718-46a8bf4162a6",
      "name": "Call 'Booking Confirmation System Queue'"
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// CHECK SERVICE RESTRICTIONS (EARLY CHECK)\n// Now runs BEFORE Route Switch - may not have datetime yet\n// ================================================================\n\nconst stateData = $('State Merger & Router').first().json;\nconst merged = stateData.merged;\nconst redis = $('get_userflag_all').first().json.userflag || {};\n\n// ================================================================\n// EARLY EXIT: Skip if no service or no specific employee\n// ================================================================\nconst hasService = merged.serviceID && merged.serviceID !== '';\nconst hasSpecificEmployee = merged.employeeID && merged.employeeID !== '' && merged.employeeID !== 'NEXT_AVAILABLE';\n\n// If user said \"NEXT_AVAILABLE\" or hasn't specified employee yet, skip restriction check\nif (!hasService || !hasSpecificEmployee) {\n  return [{\n    json: {\n      route: 'CONTINUE',\n      message: null,\n      restrictionData: null,\n      hasMixedServices: false,\n      hasOnlyRestricted: false,\n      hasOnlyNormal: true,\n      qualifiedEmployeeIDs: null,\n      techIsQualified: true,\n      merged,\n      stateData,\n      skippedCheck: true\n    }\n  }];\n}\n\n// ================================================================\n// EMPLOYEE NAME LOOKUP (Dynamic from Google Sheets)\n// ================================================================\nconst employeeData = $('Get Employee Info For Names').all().map(item => item.json);\n\nconst getEmployeeName = (empID) => {\n  const emp = employeeData.find(e => e['Employee ID'] === empID);\n  return emp ? emp['Employee Name'] : empID;\n};\n\n// ================================================================\n// GET SERVICE DATA\n// ================================================================\nconst serviceIDs = (merged.serviceID || '').split(',').map(s => s.trim()).filter(Boolean);\nconst serviceNames = (merged.serviceName || '').split(',').map(s => s.trim()).filter(Boolean);\nconst serviceDurations = (merged.serviceDuration || '').split(',').map(s => s.trim()).filter(Boolean);\nconst servicePrices = (merged.servicePrice || '').split(',').map(s => s.trim()).filter(Boolean);\nconst allowedEmployeesRawInput = merged.allowedEmployees || redis.allowedEmployees || 'ALL';\n\n// For multi-service: pipe separates PER-SERVICE groups (e.g., \"EMP001,EMP002|EMP005\")\n// For single-service: pipes OR commas may separate employee IDs\n// Detect: if we have 1 service but pipes exist, treat pipes as comma equivalents\nconst isSingleService = (merged.serviceID || '').split(',').filter(Boolean).length <= 1;\nconst allowedEmployeesRaw = isSingleService \n  ? allowedEmployeesRawInput.replace(/\\|/g, ',')\n  : allowedEmployeesRawInput;\n\nconst allowedPerService = allowedEmployeesRaw.includes('|')\n  ? allowedEmployeesRaw.split('|').map(s => s.trim())\n  : [allowedEmployeesRaw.trim()];\n\nconst requestedEmployeeID = merged.employeeID;\nconst requestedEmployeeName = merged.employeeName;\n\n// ================================================================\n// COLLECT PER-SERVICE EMPLOYEE SETS\n// ================================================================\n\nconst serviceEntries = [];\nconst allQualifiedSets = [];\n\nif (serviceIDs.length > 1) {\n  for (let i = 0; i < serviceIDs.length; i++) {\n    const svcID = serviceIDs[i];\n    const svcName = serviceNames[i] || svcID;\n    const svcDuration = serviceDurations[i] || '60';\n    const svcPrice = servicePrices[i] || '0';\n    const allowed = allowedPerService[i] || 'ALL';\n    \n    const empList = allowed.toUpperCase() === 'ALL' \n      ? null \n      : allowed.split(',').map(e => e.trim()).filter(e => e && e !== 'undefined');\n    \n    serviceEntries.push({ \n      serviceID: svcID, serviceName: svcName, \n      serviceDuration: svcDuration, servicePrice: svcPrice,\n      allowedEmployees: empList \n    });\n    if (empList) allQualifiedSets.push(new Set(empList));\n  }\n} else {\n  const svcID = serviceIDs[0] || '';\n  const svcName = serviceNames[0] || '';\n  const svcDuration = serviceDurations[0] || '60';\n  const svcPrice = servicePrices[0] || '0';\n  \n  const empList = allowedEmployeesRaw.toUpperCase() === 'ALL'\n    ? null\n    : allowedEmployeesRaw.split(',').map(e => e.trim()).filter(e => e && e !== 'undefined');\n  \n  serviceEntries.push({ \n    serviceID: svcID, serviceName: svcName, \n    serviceDuration: svcDuration, servicePrice: svcPrice,\n    allowedEmployees: empList \n  });\n  if (empList) allQualifiedSets.push(new Set(empList));\n}\n\n// ================================================================\n// DETERMINE QUALIFIED EMPLOYEES (intersection)\n// ================================================================\n\nlet qualifiedEmployeeIDs = null;\nif (allQualifiedSets.length > 0) {\n  qualifiedEmployeeIDs = allQualifiedSets[0];\n  for (let i = 1; i < allQualifiedSets.length; i++) {\n    qualifiedEmployeeIDs = new Set([...qualifiedEmployeeIDs].filter(x => allQualifiedSets[i].has(x)));\n  }\n  qualifiedEmployeeIDs = [...qualifiedEmployeeIDs];\n}\n\n// ================================================================\n// SCENARIO DETECTION\n// ================================================================\n\n// Mixed = multi-service where employee sets don't fully overlap (empty intersection)\nconst isMultiService = serviceEntries.length > 1;\nconst hasMixedServices = isMultiService && allQualifiedSets.length > 1 \n  && qualifiedEmployeeIDs !== null && qualifiedEmployeeIDs.length === 0;\nconst hasOnlyNormal = allQualifiedSets.length === 0; // all services are ALL\nconst hasOnlyRestricted = !hasMixedServices && allQualifiedSets.length > 0;\n\nlet techIsQualified = true;\nif (qualifiedEmployeeIDs !== null && qualifiedEmployeeIDs.length > 0) {\n  techIsQualified = qualifiedEmployeeIDs.includes(requestedEmployeeID);\n} else if (hasMixedServices) {\n  techIsQualified = false; // no single tech can do all services\n}\n\n// For mixed services, build restricted/normal lists for the message\nconst restrictedServices = [];\nconst normalServices = [];\nif (hasMixedServices) {\n  // Group by which sets the requested employee IS vs ISN'T in\n  for (const entry of serviceEntries) {\n    if (entry.allowedEmployees && !entry.allowedEmployees.includes(requestedEmployeeID)) {\n      restrictedServices.push(entry);\n    } else {\n      normalServices.push(entry);\n    }\n  }\n}\n\n// ================================================================\n// DETERMINE ROUTE & MESSAGE\n// ================================================================\n\nlet route;\nlet message = null;\n\nif (hasMixedServices) {\n  route = 'MIXED_SERVICES';\n  \n  const restrictedNames = restrictedServices.map(s => s.serviceName).join(', ');\n  const normalNames = normalServices.map(s => s.serviceName).join(', ');\n  \n  message = `I noticed you've selected both regular services (${normalNames}) and specialty services (${restrictedNames}).\\n\\n` +\n    `Our specialty services can only be performed by certified technicians.\\n\\n` +\n    `Would you like to proceed with just the specialty service(s)? ` +\n    `You can book the regular service(s) as a separate appointment right after.\\n\\n` +\n    `Reply *yes* to continue with specialty services only, or *no* to continue with regular services only.`;\n\n} else if (hasOnlyRestricted && !techIsQualified) {\n  route = 'UNQUALIFIED_TECH';\n  \n  // Dynamic employee names from Sheets\n  const qualifiedList = qualifiedEmployeeIDs.map(id => {\n    const name = getEmployeeName(id);\n    return `â€¢ ${name}`;\n  }).join('\\n');\n  const restrictedNames = serviceEntries.map(s => s.serviceName).join(', ');\n  \n  message = `I'm sorry, but ${requestedEmployeeName} isn't certified to perform ${restrictedNames}.\\n\\n` +\n    `Our certified technicians for this service are:\\n${qualifiedList}\\n\\n` +\n    `Just reply with a name from the list above, or say *\"yes\"* and I'll book the next available.`;\n\n} else {\n  route = 'CONTINUE';\n}\n\n// ================================================================\n// STORE RESTRICTION DATA FOR YES/NO HANDLING\n// ================================================================\n\nconst restrictionData = hasMixedServices ? {\n  restricted: restrictedServices,\n  normal: normalServices,\n  sourceFlow: 'CREATE'\n} : null;\n\n// ================================================================\n// OUTPUT\n// ================================================================\n\nreturn [{\n  json: {\n    route,\n    message,\n    restrictionData,\n    hasMixedServices,\n    hasOnlyRestricted,\n    hasOnlyNormal,\n    qualifiedEmployeeIDs,\n    techIsQualified,\n    merged,\n    stateData,\n    skippedCheck: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9024,
        32
      ],
      "id": "8d3be69f-5bdd-4c5c-97c9-f89608293697",
      "name": "Check Service Restrictions"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "MIXED_SERVICES",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "c7c66238-b3a0-4d3a-845e-42497e7e5c45"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MIXED_SERVICES"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "68601bff-cb6d-4086-8e2b-373d67a8c3f4",
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "UNQUALIFIED_TECH",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "UNQUALIFIED_TECH"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "15f41675-c2ad-44e6-a437-c2cd92166ac2",
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "CONTINUE",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONTINUE"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        9280,
        16
      ],
      "id": "b9a4b5aa-4d9d-462e-8ec8-420f588697dc",
      "name": "Service Restriction Switch"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        9584,
        -192
      ],
      "id": "f5916690-ddf4-48f1-9bf6-6c88d2da6c4c",
      "name": "Mixed Services Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ JSON.stringify({ restrictionData: JSON.stringify($('Check Service Restrictions').first().json.restrictionData) }) }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        9792,
        -192
      ],
      "id": "1c535e35-85d2-4725-bd83-122f4953f863",
      "name": "Store Restriction Data",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={ \"awaitingMixedResponse\": \"true\" }",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        10016,
        -192
      ],
      "id": "658b6ef6-ab38-4d57-b25b-e959ddfb9086",
      "name": "Set Awaiting Mixed Response",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        9568,
        -32
      ],
      "id": "dea8c6bc-b62e-445a-b05b-3433f37fb48a",
      "name": "Unqualified Tech Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "fields": "employeeID,employeeName"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        10016,
        -32
      ],
      "id": "bdffbf30-d065-4512-a073-06fcd7c2efd2",
      "name": "Wipe Unqualified Tech",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "ddb16a6a-8b2d-4128-817b-f5ad4c796f8c",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag.awaitingMixedResponse }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        480,
        720
      ],
      "id": "ac4fd141-dd59-4f49-9931-ef3538b5dd12",
      "name": "awaitingMixedResponse?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "CLARIFY",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "25b57124-a1dd-4317-8cff-03a1e95bbe6d"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CLARIFY"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "592162b4-f0c0-4467-b762-623c9a6f82de",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "KEEP_RESTRICTED",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "KEEP_RESTRICTED"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ef677a2a-2ded-4f78-9503-afc19a51a6e8",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "KEEP_NORMAL",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "KEEP_NORMAL "
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1920,
        -2144
      ],
      "id": "4b76c9c9-519a-42cf-9405-25565a01c8bc",
      "name": "Mixed Responses Switch"
    },
    {
      "parameters": {
        "jsCode": "const phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Get stored restriction data from Redis\nlet restrictionData;\ntry {\n  const storedValue = $('Get Restriction Data').first().json;\n  // Handle both string and object formats\n  if (typeof storedValue === 'string') {\n    restrictionData = JSON.parse(storedValue);\n  } else if (storedValue.data) {\n    restrictionData = JSON.parse(storedValue.data);\n  } else {\n    restrictionData = storedValue;\n  }\n} catch (e) {\n  return [{ json: { error: 'Failed to parse restriction data', details: e.message } }];\n}\n\nconst restricted = restrictionData.restricted || [];\n\nif (restricted.length === 0) {\n  return [{ json: { error: 'No restricted services found in data' } }];\n}\n\n// Build new service data from RESTRICTED services only\nconst newServiceID = restricted.map(s => s.serviceID).join(',');\nconst newServiceName = restricted.map(s => s.serviceName).join(',');\nconst newServiceDuration = restricted.map(s => s.serviceDuration || '60').join(',');\nconst newServicePrice = restricted.map(s => s.servicePrice || '0').join(',');\n\n// Get allowedEmployees for the restricted services\nconst newAllowedEmployees = restricted.map(s => {\n  if (Array.isArray(s.allowedEmployees) && s.allowedEmployees.length > 0) {\n    return s.allowedEmployees.join(',');\n  }\n  return 'ALL';\n}).join('|');\n\nreturn [{\n  json: {\n    phone,\n    serviceID: newServiceID,\n    serviceName: newServiceName,\n    serviceDuration: newServiceDuration,\n    servicePrice: newServicePrice,\n    allowedEmployees: newAllowedEmployees,\n    employeeID: 'NEXT_AVAILABLE',\n    employeeName: 'Next Available'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        -1984
      ],
      "id": "f2bf9486-b7ef-404f-ac5e-ade94c8dbad7",
      "name": "Update to Restricted Services"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        8768,
        32
      ],
      "id": "ba3b210f-8ba1-4541-8245-b34b8bcf07d4",
      "name": "Get Employee Info For Names",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's response: {{ $('Set Initial Data').first().json.messageBody }}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are a simple response classifier. Classify the user's response to a yes/no question.\n\nContext: The user was asked whether they want to book specialty services only (YES) or regular services only (NO).\n\nKEEP_RESTRICTED - User agrees, says yes, wants specialty/first option\nExamples: \"yes\", \"si\", \"sÃ­\", \"yeah\", \"yep\", \"sure\", \"ok\", \"okay\", \"y\", \"the specialty\", \"first one\", \"specialty services\"\n\nKEEP_NORMAL - User declines, says no, wants regular/second option  \nExamples: \"no\", \"nope\", \"nah\", \"n\", \"regular\", \"normal\", \"the regular\", \"second one\", \"regular services\"\n\nCLARIFY - Response is unclear, off-topic, or doesn't answer yes/no\nExamples: \"what?\", \"huh\", \"I don't understand\", \"hello\", questions, random text\n\nReturn ONLY valid JSON: {\"decision\": \"KEEP_RESTRICTED\"} or {\"decision\": \"KEEP_NORMAL\"} or {\"decision\": \"CLARIFY\"}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1296,
        -2128
      ],
      "id": "17b93c85-dba0-4c86-835a-9eeba4818dab",
      "name": "Mixed Response Agent"
    },
    {
      "parameters": {
        "options": {
          "maxOutputTokens": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1264,
        -1936
      ],
      "id": "3898338e-2b37-4f74-9ee7-8bbda5bdb87d",
      "name": "gemini-intent-router2",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't quite catch that. Would you like to:\n\n*Yes* - Book specialty service(s) only\n*No* - Book regular service(s) only\n\nPlease reply yes or no.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2240,
        -2336
      ],
      "id": "6e12a429-3c1e-4e86-a588-8d55993e2afe",
      "name": "Clarify Mixed Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const phone = $('Set Initial Data').first().json.userPhoneNumber;\nconst redis = $('get_userflag_all').first().json.userflag || {};\n\n// Get stored restriction data from Redis\nlet restrictionData;\ntry {\n  const storedValue = $('Get Restriction Data').first().json;\n  if (typeof storedValue === 'string') {\n    restrictionData = JSON.parse(storedValue);\n  } else if (storedValue.data) {\n    restrictionData = JSON.parse(storedValue.data);\n  } else {\n    restrictionData = storedValue;\n  }\n} catch (e) {\n  return [{ json: { error: 'Failed to parse restriction data', details: e.message } }];\n}\n\nconst normal = restrictionData.normal || [];\n\nif (normal.length === 0) {\n  return [{ json: { error: 'No normal services found in data' } }];\n}\n\n// Build new service data from NORMAL services only\nconst newServiceID = normal.map(s => s.serviceID).join(',');\nconst newServiceName = normal.map(s => s.serviceName).join(',');\nconst newServiceDuration = normal.map(s => s.serviceDuration || '60').join(',');\nconst newServicePrice = normal.map(s => s.servicePrice || '0').join(',');\n\nreturn [{\n  json: {\n    phone,\n    serviceID: newServiceID,\n    serviceName: newServiceName,\n    serviceDuration: newServiceDuration,\n    servicePrice: newServicePrice,\n    allowedEmployees: 'ALL',\n    // Keep existing employee preference for normal services\n    employeeID: redis.employeeID || 'NEXT_AVAILABLE',\n    employeeName: redis.employeeName || 'Next Available'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        -1808
      ],
      "id": "d94ea147-e688-438d-939d-f702490f5e8d",
      "name": "Update to Normal Services"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={\n  \"serviceID\": \"{{ $json.serviceID }}\",\n  \"serviceName\": \"{{ $json.serviceName }}\",\n  \"serviceDuration\": \"{{ $json.serviceDuration }}\",\n  \"servicePrice\": \"{{ $json.servicePrice }}\",\n  \"allowedEmployees\": \"{{ $json.allowedEmployees }}\",\n  \"employeeID\": \"{{ $json.employeeID }}\",\n  \"employeeName\": \"{{ $json.employeeName }}\",\n  \"awaitingMixedResponse\": \"\"\n}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2752,
        -1936
      ],
      "id": "d0ec896f-f12a-4f6a-83bf-2f86352f83c5",
      "name": "Update Redis After Mixed Choice",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "restrictionData"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2960,
        -1936
      ],
      "id": "b90e6728-2a0f-48a3-912f-e77628fb6113",
      "name": "Delete Restriction Data",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Try to get corrected service data from whichever handler ran\nlet serviceData = {};\ntry {\n  serviceData = $('Update to Restricted Services').first().json;\n} catch (e) {\n  try {\n    serviceData = $('Update to Normal Services').first().json;\n  } catch (e2) {\n    // Shouldn't happen but graceful fallback\n  }\n}\n\nreturn [{\n  json: {\n    redirect: true,\n    fromMixedChoice: true,\n    phone,\n    serviceID: serviceData.serviceID || '',\n    serviceName: serviceData.serviceName || '',\n    serviceDuration: serviceData.serviceDuration || '',\n    servicePrice: serviceData.servicePrice || '',\n    allowedEmployees: serviceData.allowedEmployees || 'ALL',\n    employeeID: serviceData.employeeID || 'NEXT_AVAILABLE',\n    employeeName: serviceData.employeeName || 'Next Available'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3376,
        -1936
      ],
      "id": "a56e2a94-583d-4e93-ae67-524160a6de18",
      "name": "Redirect After Mixed Choice"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "c9173000-64c6-4082-bddb-9b41f142ad80",
              "leftValue": "={{ $json.merged?.employeeID ?? $input.first().json.merged?.employeeID ?? 'NEXT_AVAILABLE' }}",
              "rightValue": "NEXT_AVAILABLE",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "fdfa8b5f-ab77-4fee-976d-cc3a64b5a2bc",
              "leftValue": "={{ $('Availability Agent').item.json.output.result.available }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        11808,
        160
      ],
      "id": "c04fd987-0830-4795-b917-f27f91a6dd8d",
      "name": "Is Next Available?"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ JSON.stringify({\n  awaitingUnqualifiedResponse: \"true\",\n  unqualifiedSourceFlow: \"CREATE\",\n  qualifiedEmployeeIDs: $('Check Service Restrictions').first().json.qualifiedEmployeeIDs ? $('Check Service Restrictions').first().json.qualifiedEmployeeIDs.join(',') : '',\n  employeeID: \"\",\n  employeeName: \"\"\n}) }}",
        "keyType": "hash"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        9776,
        -32
      ],
      "id": "f7840a95-3055-4099-b0fc-f13f9ccb539b",
      "name": "Store Unqualified Tech State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "afa84cad-ac57-4349-b3a1-d8c08b9572e2",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag.awaitingUnqualifiedResponse }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        672,
        720
      ],
      "id": "5eb461c4-2552-4e3d-8c8b-5dccdc39075c",
      "name": "awaitingUnqualifiedResponse?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=User's response: {{ $('Set Initial Data').first().json.messageBody }}\nQualified technicians: {{ $('get_userflag_all').first().json.userflag.qualifiedEmployeeIDs }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You classify user responses after being told their requested technician isn't certified for a service.\n\nContext: User wanted to book a service with a specific technician, but that technician isn't certified. They were shown a list of certified technicians and asked: \"Would you like me to book with one of our certified technicians instead?\"\n\nQualified Employee IDs are provided - these are the ONLY technicians who can perform this service.\n\n## CLASSIFICATION RULES\n\nACCEPT_ANY - User agrees to book with any available certified technician\nTrigger words: \"yes\", \"sure\", \"ok\", \"okay\", \"yeah\", \"yep\", \"please\", \"sÃ­\", \"si\", \"that's fine\", \"go ahead\", \"any of them\", \"whoever is available\"\n\nSPECIFIC_TECH - User names a specific technician\nThey might say a name like \"Karla\", \"book with Karla\", \"Karla please\", \"I want Karla\"\nâ†’ You must extract the name they mentioned\n\nDECLINE - User declines or wants to cancel\nTrigger words: \"no\", \"nope\", \"cancel\", \"never mind\", \"no thanks\", \"forget it\", \"no gracias\"\n\nCLARIFY - Response is unclear, off-topic, or a question\nExamples: \"what?\", \"who are they?\", \"tell me more\", \"huh\", any question\n\n## OUTPUT FORMAT\nReturn ONLY a JSON object:\n{\"decision\": \"ACCEPT_ANY\"}\n{\"decision\": \"SPECIFIC_TECH\", \"techName\": \"Karla\"}\n{\"decision\": \"DECLINE\"}\n{\"decision\": \"CLARIFY\"}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1280,
        -592
      ],
      "id": "623d42aa-b7e1-45c9-aed9-6f02830858db",
      "name": "Unqualified Response Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"decision\": {\n      \"type\": \"string\",\n      \"enum\": [\"ACCEPT_ANY\", \"SPECIFIC_TECH\", \"DECLINE\", \"CLARIFY\"]\n    },\n    \"techName\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"decision\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1440,
        -400
      ],
      "id": "263284d2-57c9-45e7-8596-772a103462c1",
      "name": "Structured Output Parser12"
    },
    {
      "parameters": {
        "options": {
          "maxOutputTokens": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1232,
        -400
      ],
      "id": "ac68e992-406b-4d19-9bf7-263dfcd263b5",
      "name": "gemini-intent-router3",
      "credentials": {
        "googlePalmApi": {
          "id": "gKOxHvioCsyTdrwX",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't catch your response. Please reply \"yes\" to choose next available technician or select from the list of qualified technicians by name. \n\nOr give us a call at [PHONE] â€” happy to help! ðŸ“ž",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1632,
        -416
      ],
      "id": "7fd7542c-fc13-419d-92e4-d995adde611f",
      "name": "Unqualified Error",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "ACCEPT_ANY",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "4a522528-4f27-4fb2-9188-9250af1d1286"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ACCEPT_ANY"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "114d538e-6ff5-4f20-a18f-2a0f45e15538",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "SPECIFIC_TECH",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SPECIFIC_TECH"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c2551945-f7c3-4b20-85cc-141a2ea31245",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "DECLINE",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "DECLINE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "d753d940-9e5d-4c2f-9cc3-b7dc38c2d990",
                    "leftValue": "={{ $json.output.decision }}",
                    "rightValue": "CLARIFY",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CLARIFY"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1632,
        -688
      ],
      "id": "19e6cd70-d01d-43f9-84e9-9a8bd35243d1",
      "name": "Unqualified Responses Switch"
    },
    {
      "parameters": {
        "jsCode": "const userflag = $('get_userflag_all').first().json.userflag || {};\nconst qualifiedIDs = (userflag.qualifiedEmployeeIDs || '').split(',').filter(Boolean);\n\n// Get first qualified employee as the assigned one\n// The Availability Agent will find the first AVAILABLE one from this filtered list\nreturn [{\n  json: {\n    employeeID: 'NEXT_AVAILABLE',\n    employeeName: 'Next Available',\n    qualifiedEmployeeIDs: qualifiedIDs\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1952,
        -912
      ],
      "id": "444f0f93-303b-4de1-b262-bcd54d924d95",
      "name": "Set Qualified Next Available"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ JSON.stringify({\n  employeeID: \"NEXT_AVAILABLE\",\n  employeeName: \"Next Available\",\n  awaitingUnqualifiedResponse: \"\"\n}) }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2160,
        -912
      ],
      "id": "e986d5fe-3046-4cb4-9ccd-9f3866f7541a",
      "name": "Update Redis Qualified Next Available",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "awaitingUnqualifiedResponse, unqualifiedSourceFlow"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2464,
        -912
      ],
      "id": "7ebf5859-a2ab-4678-b358-2ea295a06294",
      "name": "Clear Unqualified Flag 1",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1952,
        -736
      ],
      "id": "5be3cc7e-4ad6-445f-8577-b62e1a761ebf",
      "name": "Get Employee Info For Unqualified",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const techName = $('Unqualified Response Agent').first().json.output.techName || '';\nconst userflag = $('get_userflag_all').first().json.userflag || {};\nconst qualifiedIDs = (userflag.qualifiedEmployeeIDs || '').split(',').filter(Boolean);\nconst employeeData = $('Get Employee Info For Unqualified').all().map(item => item.json);\n\n// Find the employee by name (fuzzy match)\nconst techNameLower = techName.toLowerCase();\nlet matchedEmployee = null;\n\nfor (const emp of employeeData) {\n  const empName = (emp['Employee Name'] || '').toLowerCase();\n  const empID = emp['Employee ID'] || '';\n  \n  // Check if this employee is qualified\n  if (!qualifiedIDs.includes(empID)) continue;\n  \n  // Fuzzy match on name\n  if (empName.includes(techNameLower) || techNameLower.includes(empName.split(' ')[0].toLowerCase())) {\n    matchedEmployee = emp;\n    break;\n  }\n}\n\nif (matchedEmployee) {\n  return [{\n    json: {\n      matched: true,\n      employeeID: matchedEmployee['Employee ID'],\n      employeeName: matchedEmployee['Employee Name']\n    }\n  }];\n} else {\n  return [{\n    json: {\n      matched: false,\n      error: 'Tech not found or not qualified',\n      requestedName: techName\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        -736
      ],
      "id": "f3ccce64-0c82-4940-a9df-0271b854de73",
      "name": "Match Qualified Tech"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "c1c6f5d4-78c1-48fb-932d-1488e2910d1f",
              "leftValue": "={{ $json.matched }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2464,
        -736
      ],
      "id": "a9ac477b-a61e-453f-830b-492fc646a853",
      "name": "Tech Matched?"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={{ JSON.stringify({\n  employeeID: $json.employeeID,\n  employeeName: $json.employeeName,\n  awaitingUnqualifiedResponse: \"\"\n}) }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2720,
        -800
      ],
      "id": "bc0770ba-d188-41d7-a76f-d658a6b90efb",
      "name": "Update Redis Specific Tech",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I couldn't find \"{{ $('Unqualified Response Agent').first().json.output.techName }}\" in our certified technicians list. Would you like to book with any available certified technician instead?",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2720,
        -560
      ],
      "id": "55ae0fa1-772a-4669-8fcc-48fadc2c9adb",
      "name": "Tech Not Found Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        1968,
        -528
      ],
      "id": "9d5dcdb7-a29f-438e-9a37-4d694afb6382",
      "name": "Wipe Booking Data - Declined",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=No problem! Your booking request has been cancelled. Let me know if you'd like to book a different service or have any questions.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2208,
        -528
      ],
      "id": "fd311b76-d5e5-4c19-8742-14ba0fa8427a",
      "name": "Send Decline Confirmation",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "=I didn't quite catch that. Would you like me to book with one of our certified technicians for this service? Just reply \"yes\" to proceed, or \"no\" to cancel.",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1968,
        -336
      ],
      "id": "58492947-7b31-4aea-8c8c-7ded79552b7c",
      "name": "Clarify Unqualified Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const userflag = $('get_userflag_all').first().json.userflag || {};\n\n// ================================================================\n// EMPLOYEE RESOLUTION\n// SPECIFIC_TECH path: Match Qualified Tech ran upstream\n// ACCEPT_ANY path: Match Qualified Tech didn't run\n// ================================================================\nlet employeeID = 'NEXT_AVAILABLE';\nlet employeeName = 'Next Available';\nlet specificTechAllowed = null;\n\ntry {\n  const matched = $('Match Qualified Tech').first().json;\n  if (matched && matched.matched === true) {\n    employeeID = matched.employeeID;\n    employeeName = matched.employeeName;\n    specificTechAllowed = matched.employeeID;\n  }\n} catch (e) {\n  // ACCEPT_ANY path â€” Match Qualified Tech didn't execute\n}\n\n// Build allowedEmployees filter\nconst qualifiedIDs = (userflag.qualifiedEmployeeIDs || '').split(',').filter(Boolean);\nconst allowedEmployees = specificTechAllowed\n  ? specificTechAllowed\n  : (qualifiedIDs.length > 0 ? qualifiedIDs.join(',') :\n     (userflag.allowedEmployees || 'ALL'));\n\n// Build the merged object that Availability Agent expects\nconst merged = {\n  employeeID: employeeID,\n  employeeName: employeeName,\n  dateTime: userflag.dateTime,\n  serviceDuration: userflag.serviceDuration,\n  serviceID: userflag.serviceID,\n  serviceName: userflag.serviceName,\n  servicePrice: userflag.servicePrice,\n  allowedEmployees: allowedEmployees\n};\n\nreturn [{\n  json: {\n    merged\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        -912
      ],
      "id": "c23270d6-84ee-4b1a-8d0d-874012b70c8a",
      "name": "Prep Availability From Unqualified"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 591363548,
          "mode": "list",
          "cachedResultName": "Employee Info (admin doc)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=591363548"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        8336,
        1808
      ],
      "id": "2e8a0151-2d3b-457e-8d3d-9ecaf9198786",
      "name": "Get Update Employee Info",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// CHECK UPDATE SERVICE RESTRICTIONS\n// Detects mixed services and unqualified technician for Update flow\n// ================================================================\n\nconst mergeResult = $('Merge Extract Phase Results').first().json;\nconst mod = mergeResult.mod || {};\nconst redis = $('get_userflag_all').first().json.userflag || {};\n\n// Get merged data (proposed changes + original)\nconst proposedChanges = mod.proposedChanges || {};\nconst originalAppointment = mod.originalAppointment || {};\n\n// Build effective booking state (proposed overrides original)\nconst merged = {\n  serviceID: proposedChanges.serviceID || originalAppointment.serviceID || '',\n  serviceName: proposedChanges.serviceName || originalAppointment.service || '',\n  serviceDuration: proposedChanges.serviceDuration || originalAppointment.serviceDuration || '',\n  servicePrice: proposedChanges.servicePrice || originalAppointment.servicePrice || '',\n  allowedEmployees: (proposedChanges.allowedEmployees || originalAppointment.allowedEmployees || 'ALL').replace(/undefined,?/g, '').replace(/^,|,$/g, '') || 'ALL',\n  employeeID: proposedChanges.employeeID || originalAppointment.employeeID || '',\n  employeeName: proposedChanges.employeeName || originalAppointment.technician || ''\n};\n\n// ================================================================\n// EARLY EXIT: Skip if no service or no specific employee\n// ================================================================\nconst hasService = merged.serviceID && merged.serviceID !== '';\nconst hasSpecificEmployee = merged.employeeID && merged.employeeID !== '' && merged.employeeID !== 'NEXT_AVAILABLE';\n\nif (!hasService || !hasSpecificEmployee) {\n  return [{\n    json: {\n      route: 'CONTINUE',\n      message: null,\n      restrictionData: null,\n      hasMixedServices: false,\n      hasOnlyRestricted: false,\n      hasOnlyNormal: true,\n      qualifiedEmployeeIDs: null,\n      techIsQualified: true,\n      merged,\n      mergeResult,\n      skippedCheck: true,\n      isUpdateFlow: true\n    }\n  }];\n}\n\n// ================================================================\n// EMPLOYEE NAME LOOKUP\n// ================================================================\nconst employeeData = $('Get Update Employee Info').all().map(item => item.json);\n\nconst getEmployeeName = (empID) => {\n  const emp = employeeData.find(e => e['Employee ID'] === empID);\n  return emp ? emp['Employee Name'] : empID;\n};\n\n// ================================================================\n// GET SERVICE DATA\n// ================================================================\nconst serviceIDs = (merged.serviceID || '').split(',').map(s => s.trim()).filter(Boolean);\nconst serviceNames = (merged.serviceName || '').split(',').map(s => s.trim()).filter(Boolean);\nconst serviceDurations = (merged.serviceDuration || '').split(',').map(s => s.trim()).filter(Boolean);\nconst servicePrices = (merged.servicePrice || '').split(',').map(s => s.trim()).filter(Boolean);\n\n// Sanitize allowedEmployees - filter out 'undefined' and empty values\n// For single-service: pipes may be comma-equivalents (AI sometimes converts commas to pipes)\nconst allowedEmployeesInput = merged.allowedEmployees || 'ALL';\nconst serviceCount = (merged.serviceID || '').split(',').filter(Boolean).length;\nconst isSingleService = serviceCount <= 1;\n\nlet allowedEmployeesRaw;\nif (isSingleService) {\n  // Single service: treat all separators as comma (normalize pipes to commas)\n  allowedEmployeesRaw = allowedEmployeesInput.replace(/\\|/g, ',')\n    .split(',')\n    .map(s => s.trim())\n    .filter(s => s && s !== 'undefined' && s !== '')\n    .join(',') || 'ALL';\n} else {\n  // Multi-service: pipes separate per-service groups\n  allowedEmployeesRaw = allowedEmployeesInput\n    .split('|')\n    .map(group =>\n      group.split(',')\n        .map(s => s.trim())\n        .filter(s => s && s !== 'undefined' && s !== '')\n        .join(',') || 'ALL'\n    )\n    .join('|');\n}\n\nconst allowedPerService = allowedEmployeesRaw.includes('|')\n  ? allowedEmployeesRaw.split('|').map(s => s.trim())\n  : [allowedEmployeesRaw.trim()];\n\nconst requestedEmployeeID = merged.employeeID;\nconst requestedEmployeeName = merged.employeeName;\n\n// ================================================================\n// COLLECT PER-SERVICE EMPLOYEE SETS\n// ================================================================\n\nconst serviceEntries = [];\nconst allQualifiedSets = [];\n\nif (serviceIDs.length > 1) {\n  for (let i = 0; i < serviceIDs.length; i++) {\n    const svcID = serviceIDs[i];\n    const svcName = serviceNames[i] || svcID;\n    const svcDuration = serviceDurations[i] || '60';\n    const svcPrice = servicePrices[i] || '0';\n    const allowed = allowedPerService[i] || 'ALL';\n    \n    const empList = allowed.toUpperCase() === 'ALL' \n      ? null \n      : allowed.split(',').map(e => e.trim()).filter(e => e && e !== 'undefined');\n    \n    serviceEntries.push({ \n      serviceID: svcID, serviceName: svcName, \n      serviceDuration: svcDuration, servicePrice: svcPrice,\n      allowedEmployees: empList \n    });\n    if (empList) allQualifiedSets.push(new Set(empList));\n  }\n} else {\n  const svcID = serviceIDs[0] || '';\n  const svcName = serviceNames[0] || '';\n  const svcDuration = serviceDurations[0] || '60';\n  const svcPrice = servicePrices[0] || '0';\n  \n  const empList = allowedEmployeesRaw.toUpperCase() === 'ALL'\n    ? null\n    : allowedEmployeesRaw.split(',').map(e => e.trim()).filter(e => e && e !== 'undefined');\n  \n  serviceEntries.push({ \n    serviceID: svcID, serviceName: svcName, \n    serviceDuration: svcDuration, servicePrice: svcPrice,\n    allowedEmployees: empList \n  });\n  if (empList) allQualifiedSets.push(new Set(empList));\n}\n\n// ================================================================\n// DETERMINE QUALIFIED EMPLOYEES (intersection)\n// ================================================================\n\nlet qualifiedEmployeeIDs = null;\nif (allQualifiedSets.length > 0) {\n  qualifiedEmployeeIDs = allQualifiedSets[0];\n  for (let i = 1; i < allQualifiedSets.length; i++) {\n    qualifiedEmployeeIDs = new Set([...qualifiedEmployeeIDs].filter(x => allQualifiedSets[i].has(x)));\n  }\n  qualifiedEmployeeIDs = [...qualifiedEmployeeIDs];\n}\n\n// ================================================================\n// SCENARIO DETECTION\n// ================================================================\n\n// Mixed = multi-service where employee sets don't fully overlap (empty intersection)\nconst isMultiService = serviceEntries.length > 1;\nconst hasMixedServices = isMultiService && allQualifiedSets.length > 1 \n  && qualifiedEmployeeIDs !== null && qualifiedEmployeeIDs.length === 0;\nconst hasOnlyNormal = allQualifiedSets.length === 0; // all services are ALL\nconst hasOnlyRestricted = !hasMixedServices && allQualifiedSets.length > 0;\n\nlet techIsQualified = true;\nif (qualifiedEmployeeIDs !== null && qualifiedEmployeeIDs.length > 0) {\n  techIsQualified = qualifiedEmployeeIDs.includes(requestedEmployeeID);\n} else if (hasMixedServices) {\n  techIsQualified = false; // no single tech can do all services\n}\n\n// For mixed services, build restricted/normal lists for the message\nconst restrictedServices = [];\nconst normalServices = [];\nif (hasMixedServices) {\n  // Group by which sets the requested employee IS vs ISN'T in\n  for (const entry of serviceEntries) {\n    if (entry.allowedEmployees && !entry.allowedEmployees.includes(requestedEmployeeID)) {\n      restrictedServices.push(entry);\n    } else {\n      normalServices.push(entry);\n    }\n  }\n}\n\n// ================================================================\n// DETERMINE ROUTE & MESSAGE\n// ================================================================\n\nlet route;\nlet message = null;\n\nif (hasMixedServices) {\n  route = 'MIXED_SERVICES';\n  \n  const restrictedNames = restrictedServices.map(s => s.serviceName).join(', ');\n  const normalNames = normalServices.map(s => s.serviceName).join(', ');\n  \n  message = `I noticed your updated booking includes both regular services (${normalNames}) and specialty services (${restrictedNames}).\\n\\n` +\n    `Our specialty services can only be performed by certified technicians.\\n\\n` +\n    `Would you like to proceed with just the specialty service(s)? ` +\n    `You can book the regular service(s) as a separate appointment right after.\\n\\n` +\n    `Reply *yes* to continue with specialty services only, or *no* to continue with regular services only.`;\n\n} else if (hasOnlyRestricted && !techIsQualified) {\n  route = 'UNQUALIFIED_TECH';\n  \n  // Dynamic employee names from Sheets\n  const qualifiedList = qualifiedEmployeeIDs.map(id => {\n    const name = getEmployeeName(id);\n    return `â€¢ ${name}`;\n  }).join('\\n');\n  const restrictedNames = serviceEntries.map(s => s.serviceName).join(', ');\n  \n  message = `I'm sorry, but ${requestedEmployeeName} isn't certified to perform ${restrictedNames}.\\n\\n` +\n    `Our certified technicians for this service are:\\n${qualifiedList}\\n\\n` +\n    `Just reply with a name from the list above, or say *\"yes\"* and I'll book the next available.`;\n\n} else {\n  route = 'CONTINUE';\n}\n\n// ================================================================\n// STORE RESTRICTION DATA FOR YES/NO HANDLING\n// ================================================================\n\nconst restrictionData = hasMixedServices ? {\n  restricted: restrictedServices,\n  normal: normalServices,\n  originalAppointment: originalAppointment,\n  sourceFlow: 'UPDATE'\n} : null;\n\n// ================================================================\n// OUTPUT\n// ================================================================\n\nreturn [{\n  json: {\n    route,\n    message,\n    restrictionData,\n    hasMixedServices,\n    hasOnlyRestricted,\n    hasOnlyNormal,\n    qualifiedEmployeeIDs,\n    techIsQualified,\n    merged,\n    mergeResult,\n    skippedCheck: false,\n    isUpdateFlow: true\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8544,
        1808
      ],
      "id": "9dbaf232-1aeb-49b0-8cb5-f3852f7e2557",
      "name": "Check Update Service Restrictions"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Check Update Service Restrictions').first().json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        9088,
        1376
      ],
      "id": "cf7502a5-fb90-45e5-81a0-00af80b75b45",
      "name": "Update Mixed Services Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ JSON.stringify({ restrictionData: JSON.stringify($('Check Update Service Restrictions').first().json.restrictionData) }) }}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        9344,
        1376
      ],
      "id": "2a337c06-4257-40f9-b67c-79838c3fba5f",
      "name": "Store Update Restriction Data",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={ \"awaitingMixedResponse\": \"true\" }",
        "keyType": "hash"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        9568,
        1376
      ],
      "id": "8dd05a4a-0758-4335-9d95-821494322ed6",
      "name": "Set Update Awaiting Mixed Response",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Webhook').first().json.body.WaId }}",
        "toWhatsapp": true,
        "message": "={{ $('Check Update Service Restrictions').first().json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        9104,
        1552
      ],
      "id": "e80bc61a-f084-439e-866d-1ddc7d709933",
      "name": "Update Unqualified Tech Message",
      "credentials": {
        "twilioApi": {
          "id": "cnl6Zys0eztBWfnJ",
          "name": "Twilio account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "value": "={{ JSON.stringify({\n  awaitingUnqualifiedResponse: \"true\",\n  unqualifiedSourceFlow: \"UPDATE\",\n  qualifiedEmployeeIDs: $('Check Update Service Restrictions').first().json.qualifiedEmployeeIDs ? $('Check Update Service Restrictions').first().json.qualifiedEmployeeIDs.join(',') : ''\n}) }}",
        "keyType": "hash"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        9344,
        1552
      ],
      "id": "0010435d-a7a6-4e4c-88e2-7a480cbceee9",
      "name": "Store Update Unqualified State",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "MIXED_SERVICES",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "4399926a-8511-4615-b569-6c920901c5fe"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "MIXED_SERVICES"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f1f9a62c-a3b8-4768-8df7-647c00669bdd",
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "UNQUALIFIED_TECH",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "UNQUALIFIED_TECH"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "603ea3ed-8e18-4484-8d1e-042d4a955d6a",
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "CONTINUE",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONTINUE"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        8800,
        1792
      ],
      "id": "bc34b7b1-c4c2-4158-b75a-bb4b889ba17c",
      "name": "Update Service Restriction Switch"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "80241a1f-8b4a-4143-8fcf-4f6b2ba871be",
              "leftValue": "={{ $('Get Restriction Data').first().json.sourceFlow }}",
              "rightValue": "=UPDATE",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2240,
        -2128
      ],
      "id": "d9fa1a62-0e54-4554-9d8c-2bb619036a5c",
      "name": "Is Update Flow?"
    },
    {
      "parameters": {
        "jsCode": "// Update to Restricted Services - UPDATE FLOW VERSION\n// Updates bookingModification.proposedChanges instead of flat Redis keys\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\nconst redis = $('get_userflag_all').first().json.userflag || {};\n// Get stored restriction data\nlet restrictionData;\ntry {\n  const storedValue = $('Get Restriction Data').first().json;\n  if (typeof storedValue === 'string') {\n    restrictionData = JSON.parse(storedValue);\n  } else if (storedValue.data) {\n    restrictionData = JSON.parse(storedValue.data);\n  } else {\n    restrictionData = storedValue;\n  }\n} catch (e) {\n  return [{ json: { error: 'Failed to parse restriction data', details: e.message } }];\n}\nconst restricted = restrictionData.restricted || [];\nconst originalAppointment = restrictionData.originalAppointment || {};\nif (restricted.length === 0) {\n  return [{ json: { error: 'No restricted services found' } }];\n}\n// Build new service data from RESTRICTED services only\nconst newServiceID = restricted.map(s => s.serviceID).join(',');\nconst newServiceName = restricted.map(s => s.serviceName).join(',');\nconst newServiceDuration = restricted.map(s => s.serviceDuration || '60').join(',');\nconst newServicePrice = restricted.map(s => s.servicePrice || '0').join(',');\nconst newAllowedEmployees = restricted.map(s => {\n  if (Array.isArray(s.allowedEmployees) && s.allowedEmployees.length > 0) {\n    return s.allowedEmployees.join(',');\n  }\n  return 'ALL';\n}).join('|');\n// Build updated proposedChanges for bookingModification\nconst updatedProposedChanges = {\n  serviceID: newServiceID,\n  serviceName: newServiceName,\n  serviceDuration: newServiceDuration,\n  servicePrice: newServicePrice,\n  allowedEmployees: newAllowedEmployees,\n  employeeID: 'NEXT_AVAILABLE',\n  employeeName: 'Next Available'\n};\n// Get existing bookingModification and update it\nlet bookingMod;\ntry {\n  bookingMod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  bookingMod = {};\n}\nbookingMod.proposedChanges = {\n  ...(bookingMod.proposedChanges || {}),\n  ...updatedProposedChanges\n};\n// Reset availability since services changed\nbookingMod.availabilityConfirmed = false;\nreturn [{\n  json: {\n    phone,\n    bookingModification: bookingMod,\n    sourceFlow: 'UPDATE'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        -2336
      ],
      "id": "3d404727-ffa3-4bb4-9f99-d62d9aa4829c",
      "name": "Update to Restricted - Update Flow"
    },
    {
      "parameters": {
        "jsCode": "// Update to Normal Services - UPDATE FLOW VERSION\n// Updates bookingModification.proposedChanges instead of flat Redis keys\n\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\nconst redis = $('get_userflag_all').first().json.userflag || {};\n\n// Get stored restriction data\nlet restrictionData;\ntry {\n  const storedValue = $('Get Restriction Data').first().json;\n  if (typeof storedValue === 'string') {\n    restrictionData = JSON.parse(storedValue);\n  } else if (storedValue.data) {\n    restrictionData = JSON.parse(storedValue.data);\n  } else {\n    restrictionData = storedValue;\n  }\n} catch (e) {\n  return [{ json: { error: 'Failed to parse restriction data', details: e.message } }];\n}\n\nconst normal = restrictionData.normal || [];\nconst originalAppointment = restrictionData.originalAppointment || {};\n\nif (normal.length === 0) {\n  return [{ json: { error: 'No normal services found' } }];\n}\n\n// Build new service data from NORMAL services only\nconst newServiceID = normal.map(s => s.serviceID).join(',');\nconst newServiceName = normal.map(s => s.serviceName).join(',');\nconst newServiceDuration = normal.map(s => s.serviceDuration || '60').join(',');\nconst newServicePrice = normal.map(s => s.servicePrice || '0').join(',');\n\n// Get existing bookingModification and update it\nlet bookingMod;\ntry {\n  bookingMod = JSON.parse(redis.bookingModification || '{}');\n} catch (e) {\n  bookingMod = {};\n}\n\n// Build updated proposedChanges\nconst updatedProposedChanges = {\n  serviceID: newServiceID,\n  serviceName: newServiceName,\n  serviceDuration: newServiceDuration,\n  servicePrice: newServicePrice,\n  allowedEmployees: 'ALL',\n  // Keep existing employee preference for normal services\n  employeeID: bookingMod.proposedChanges?.employeeID || originalAppointment.employeeID || 'NEXT_AVAILABLE',\n  employeeName: bookingMod.proposedChanges?.employeeName || originalAppointment.technician || 'Next Available'\n};\n\nbookingMod.proposedChanges = {\n  ...(bookingMod.proposedChanges || {}),\n  ...updatedProposedChanges\n};\n\n// Reset availability since services changed\nbookingMod.availabilityConfirmed = false;\n\nreturn [{\n  json: {\n    phone,\n    bookingModification: bookingMod,\n    sourceFlow: 'UPDATE'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        -2144
      ],
      "id": "c143142b-f8d5-4aad-80cf-003993091e38",
      "name": "Update to Normal - Update Flow"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=userflag_{{ $('Set Initial Data').first().json.PhoneNumber }}",
        "value": "={\n  \"bookingModification\": {{ JSON.stringify($json.bookingModification) }}\n}",
        "keyType": "hash",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2800,
        -2240
      ],
      "id": "11d264b0-e634-4041-9325-495544e96071",
      "name": "Update Redis After Mixed - Update Flow",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "awaitingMixedResponse"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        2992,
        -2240
      ],
      "id": "99b1c96a-719d-43a1-841d-6d210b2ebc7c",
      "name": "Clear Update Mixed Flag",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "hdel",
        "key": "=userflag_{{ $('Webhook').first().json.body.WaId }}",
        "fields": "restrictionData"
      },
      "type": "@iaconnecto/n8n-nodes-redis-extended.redisExtended",
      "typeVersion": 1,
      "position": [
        3184,
        -2240
      ],
      "id": "be7d4457-111a-488f-8a17-fbf64aeb370c",
      "name": "Delete Update Restriction Data",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Try to get corrected service data from whichever handler ran\nlet serviceData = {};\ntry {\n  serviceData = $('Update to Restricted - Update Flow').first().json;\n} catch (e) {\n  try {\n    serviceData = $('Update to Normal - Update Flow').first().json;\n  } catch (e2) {}\n}\n\nreturn [{\n  json: {\n    redirect: true,\n    fromMixedChoice: true,\n    phone,\n    sourceFlow: 'UPDATE',\n    serviceID: serviceData.serviceID || '',\n    serviceName: serviceData.serviceName || '',\n    serviceDuration: serviceData.serviceDuration || '',\n    servicePrice: serviceData.servicePrice || '',\n    allowedEmployees: serviceData.allowedEmployees || 'ALL',\n    bookingModification: serviceData.bookingModification || ''\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        -2240
      ],
      "id": "e95dacea-a271-420b-813d-2a638bf18677",
      "name": "Redirect to Update Flow"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "80241a1f-8b4a-4143-8fcf-4f6b2ba871be",
              "leftValue": "={{ $('Get Restriction Data').first().json.sourceFlow }}",
              "rightValue": "=UPDATE",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2240,
        -1936
      ],
      "id": "5b8dbd59-7ccd-4653-ac3a-3150ee658e02",
      "name": "Is Update Flow?1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "7d202ef6-224d-4cb3-949d-c6a296e3eb08",
              "leftValue": "={{ $('get_userflag_all').first().json.userflag.unqualifiedSourceFlow }}",
              "rightValue": "UPDATE",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2896,
        -912
      ],
      "id": "e602dfc5-602d-4cb8-825f-1c13ae237ef8",
      "name": "Is Unqualified Update Flow?"
    },
    {
      "parameters": {
        "jsCode": "// ================================================================\n// PREP UPDATE AVAILABILITY FROM UNQUALIFIED TECH RESPONSE\n// Bridges unqualified tech handler â†’ Update Availability Agent\n// ================================================================\n\nconst userflag = $('get_userflag_all').first().json.userflag || {};\nconst phone = $('Set Initial Data').first().json.userPhoneNumber;\n\n// Parse bookingModification from Redis\nlet mod;\ntry {\n  mod = typeof userflag.bookingModification === 'string'\n    ? JSON.parse(userflag.bookingModification)\n    : userflag.bookingModification || {};\n} catch (e) {\n  mod = {};\n}\n\nconst orig = mod.originalAppointment || {};\nconst proposed = mod.proposedChanges || {};\n\n// ================================================================\n// EMPLOYEE RESOLUTION\n// SPECIFIC_TECH path: Match Qualified Tech ran upstream with a specific employee\n// ACCEPT_ANY path: Match Qualified Tech didn't run, default to NEXT_AVAILABLE\n// ================================================================\nlet employeeID = 'NEXT_AVAILABLE';\nlet employeeName = 'Next Available';\nlet specificTechAllowed = null;\n\ntry {\n  const matched = $('Match Qualified Tech').first().json;\n  if (matched && matched.matched === true) {\n    employeeID = matched.employeeID;\n    employeeName = matched.employeeName;\n    // Narrow filter to ONLY this tech\n    specificTechAllowed = matched.employeeID;\n  }\n} catch (e) {\n  // ACCEPT_ANY path â€” Match Qualified Tech didn't execute\n}\n\n// Build allowedEmployees filter\n// Build allowedEmployees filter\nconst qualifiedIDs = (userflag.qualifiedEmployeeIDs || '').split(',').filter(Boolean);\nconst allowedEmployees = specificTechAllowed \n  ? specificTechAllowed \n  : (qualifiedIDs.length > 0 ? qualifiedIDs.join(',') : 'ALL');\n\n// If NEXT_AVAILABLE with single qualified tech, lock to that tech\nif (employeeID === 'NEXT_AVAILABLE' && qualifiedIDs.length === 1) {\n  employeeID = qualifiedIDs[0];\n  // Name lookup from mod data or Redis\n  const allEmps = $('get_userflag_all').first().json.userflag || {};\n  // Try to get name dynamically\n  try {\n    const empRows = $('Get Employee Info For Unqualified').all().map(item => item.json);\n    const match = empRows.find(e => e['Employee ID'] === qualifiedIDs[0]);\n    if (match) employeeName = match['Employee Name'];\n  } catch (e) {\n    // Fallback - keep whatever we have\n  }\n}\n\n// Determine duration\nlet finalDuration;\nif (proposed.serviceDuration) {\n  finalDuration = proposed.serviceDuration;\n} else if (orig.serviceDuration) {\n  finalDuration = orig.serviceDuration;\n} else {\n  finalDuration = '45';\n}\n\n// Build finalBooking\nmod.finalBooking = {\n  rowNumber: orig.rowNumber,\n  serviceID: proposed.serviceID || orig.serviceID,\n  serviceName: proposed.serviceName || orig.service,\n  serviceDuration: finalDuration,\n  servicePrice: proposed.servicePrice || orig.servicePrice,\n  datetime: proposed.datetime || orig.datetime,\n  employeeID: employeeID,\n  employeeName: employeeName\n};\n\n// Update proposed changes with new tech\nmod.proposedChanges = proposed;\nmod.proposedChanges.employeeID = employeeID;\nmod.proposedChanges.employeeName = employeeName;\n\n// Ensure technician is in changed fields\nif (!mod.changedFields) {\n  mod.changedFields = [];\n}\nif (!mod.changedFields.includes('technician')) {\n  mod.changedFields.push('technician');\n}\n\n// Reset availability flags\nmod.availabilityConfirmed = false;\nmod.readyToSave = false;\n\nreturn [{\n  json: {\n    phone,\n    bookingModification: JSON.stringify(mod),\n    mod,\n    finalBooking: mod.finalBooking,\n    originalAppointment: mod.originalAppointment,\n    changedFields: mod.changedFields,\n    allowedEmployees\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        -720
      ],
      "id": "eb546b16-90c0-410e-a64e-1468e54ec70e",
      "name": "Prep Update Availability From Unqualified"
    },
    {
      "parameters": {
        "jsCode": "const userflag = $('get_userflag_all').first().json.userflag || {};\nconst raw = userflag.restrictionData;\n\nif (!raw) {\n  throw new Error('No restrictionData found in userflag. Fields present: ' + Object.keys(userflag).join(', '));\n}\n\nlet parsed;\ntry {\n  parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;\n} catch (e) {\n  throw new Error('Failed to parse restrictionData: ' + e.message);\n}\n\n// Parse Mixed Response Agent output (may be wrapped in code fences)\nlet decision = 'CLARIFY';\ntry {\n  const agentRaw = $('Mixed Response Agent').first().json.output;\n  if (typeof agentRaw === 'string') {\n    const cleaned = agentRaw.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n    const agentParsed = JSON.parse(cleaned);\n    decision = agentParsed.decision || 'CLARIFY';\n  } else if (agentRaw && agentRaw.decision) {\n    decision = agentRaw.decision;\n  }\n} catch (e) {\n  decision = 'CLARIFY';\n}\n\nreturn [{\n  json: {\n    restricted: parsed.restricted || [],\n    normal: parsed.normal || [],\n    sourceFlow: parsed.sourceFlow || 'CREATE',\n    originalAppointment: parsed.originalAppointment || null,\n    output: { decision }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1632,
        -2128
      ],
      "id": "54bee675-8d16-49fa-812c-e9ef976952e8",
      "name": "Get Restriction Data"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "792fb924ea7c7755c7ce627c71143fd669fff3fb4c11324a28bdb064d1766438@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Zen Nails"
        },
        "start": "={{ DateTime.fromISO($('UID Generation').first().json.userflag.dateTime).toISO() }}",
        "end": "={{ DateTime.fromISO($('UID Generation').first().json.userflag.dateTime).plus({ minutes: $('UID Generation').first().json.userflag.serviceDuration.split(',').map(d => parseFloat(d.trim())).reduce((sum, dur) => sum + dur, 0) }).toISO() }}",
        "useDefaultReminders": false,
        "additionalFields": {
          "color": "={{ $('UID Generation').first().json.calendarColor || '' }}",
          "description": "=Technician: {{ $('UID Generation').first().json.userflag.employeeName }} Service: {{ $('UID Generation').first().json.userflag.serviceName }}   \nPhone: {{ $('Set Initial Data').first().json.userPhoneNumber }}",
          "summary": "={{ $('Save Booking This Week').first().json['Booking Type'] }} - {{ $('Set Initial Data').first().json.name || 'Walk-in' }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        2768,
        -4032
      ],
      "id": "c3db522b-6b3a-4bc9-9ad7-b3b9a5558297",
      "name": "Create Calendar Event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "lTiifUkUkBg6fzLt",
          "name": "Google Calendar account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 569810801,
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=569810801"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Calendar Event ID": "={{ $('Create Calendar Event').first().json.id }}",
            "Booking ID": "={{ $('UID Generation').first().json.bookingId }}"
          },
          "matchingColumns": [
            "Booking ID"
          ],
          "schema": [
            {
              "id": "Booking Type",
              "displayName": "Booking Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Time",
              "displayName": "Booking Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Nail Technician",
              "displayName": "Nail Technician",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Contact ID",
              "displayName": "Contact ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Confirmed",
              "displayName": "Booking Confirmed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Amount",
              "displayName": "Amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Payment Method",
              "displayName": "Payment Method",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Tips",
              "displayName": "Tips",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Extra",
              "displayName": "Extra",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking  End Time",
              "displayName": "Booking  End Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Date",
              "displayName": "Booking Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking ID",
              "displayName": "Booking ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Calendar Event ID",
              "displayName": "Calendar Event ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3184,
        -4032
      ],
      "id": "18ab68bf-62ed-414a-9d8c-c3ac5c7aee8a",
      "name": "Save Calendar Event ID",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "792fb924ea7c7755c7ce627c71143fd669fff3fb4c11324a28bdb064d1766438@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Zen Nails"
        },
        "eventId": "={{ $('Calculate Blocked Time to Remove').first().json.calendarEventId }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        6320,
        3680
      ],
      "id": "f12e938e-91cb-42f0-baec-adf7d4d30e5d",
      "name": "Delete Calendar Event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "lTiifUkUkBg6fzLt",
          "name": "Google Calendar account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "792fb924ea7c7755c7ce627c71143fd669fff3fb4c11324a28bdb064d1766438@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Zen Nails"
        },
        "start": "={{ DateTime.fromFormat($('Execute Update').first().json.bookingTime, 'M/d/yyyy HH:mm:ss').toISO() }}",
        "end": "={{ DateTime.fromFormat($('Execute Update').first().json.bookingEndTime, 'M/d/yyyy HH:mm:ss').toISO() }}",
        "additionalFields": {
          "attendees": [],
          "color": "={{ $('Execute Update').first().json.calendarColor || '' }}",
          "description": "=Technician: {{ $('Execute Update').first().json.technicianName }}\\nService: {{ $('Execute Update').first().json.bookingType }}",
          "summary": "={{ $('Execute Update').first().json.bookingType }} - {{ $('Set Initial Data').first().json.name || 'Walk-in' }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        5104,
        -2784
      ],
      "id": "547d93c6-b399-4a1e-931e-05190b4abed8",
      "name": "Create New Calendar Event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "lTiifUkUkBg6fzLt",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "792fb924ea7c7755c7ce627c71143fd669fff3fb4c11324a28bdb064d1766438@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Zen Nails"
        },
        "eventId": "={{ $('Execute Update').first().json.calendarEventId }}",
        "options": {
          "sendUpdates": "all"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        4912,
        -2784
      ],
      "id": "c3a5de17-fa09-4159-9cba-1a45f35ab07f",
      "name": "Delete Old Calendar Event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "lTiifUkUkBg6fzLt",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk",
          "mode": "list",
          "cachedResultName": " n8n-amar-nails-dev",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 569810801,
          "mode": "list",
          "cachedResultName": "Bookings (Future)",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/15-Z9rQxRJvNKlU8ib7Xii6TyqfXGUBpMo2gbDkZmKUk/edit#gid=569810801"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Calendar Event ID": "={{ $('Create New Calendar Event').first().json.id }}",
            "Booking ID": "={{ $('Execute Update').first().json.bookingId }}"
          },
          "matchingColumns": [
            "Booking ID"
          ],
          "schema": [
            {
              "id": "Booking Type",
              "displayName": "Booking Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Time",
              "displayName": "Booking Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Nail Technician",
              "displayName": "Nail Technician",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Employee ID",
              "displayName": "Employee ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Contact ID",
              "displayName": "Contact ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Confirmed",
              "displayName": "Booking Confirmed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Amount",
              "displayName": "Amount",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Payment Method",
              "displayName": "Payment Method",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Tips",
              "displayName": "Tips",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Extra",
              "displayName": "Extra",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking  End Time",
              "displayName": "Booking  End Time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking Date",
              "displayName": "Booking Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Booking ID",
              "displayName": "Booking ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Calendar Event ID",
              "displayName": "Calendar Event ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5328,
        -2784
      ],
      "id": "50e396f3-2b9b-45f9-84d4-d88e6c8c5162",
      "name": "Save New Calendar Event ID",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "l0XnGJfEosKL4HxW",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "content": "# 2ï¸âƒ£ STATE ROUTER & CONFIRMATION CHECK\n\nChecks Redis for existing conversation state before routing.\nDetermines if user is mid-flow (confirming, birthday pending, mixed response, etc.)\n\nFLOW:\n- Check Confirm State â†’ if pending confirmation, route to Booking Confirmation Queue\n- Fetch business cache â†’ check registration status â†’ check booking limit\n- Merge results and load all user flags from Redis\n- Route through state checks: pendingBirthday â†’ awaitingMixed â†’ awaitingUnqualified â†’ confirm/save check",
        "height": 1296,
        "width": 3296
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -2304,
        128
      ],
      "typeVersion": 1,
      "id": "02a9151f-2511-41e4-b806-345386acb13f",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "# 3ï¸âƒ£ BIRTHDAY RESPONSE FLOW\n\nHandles responses when user has a pending birthday request.\nAI agent interprets birthday response â†’ routes to registration, re-ask, or skip.\n\nOUTPUTS:\n- Valid birthday â†’ Register contact â†’ set readyToBook\n- No birthday / skip â†’ delete pending flag â†’ set readyToBook\n- Unclear â†’ repeat birthday request\n- Modification context â†’ delete flag â†’ route to Modification Handler",
        "height": 640,
        "width": 2368,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1184,
        -1584
      ],
      "typeVersion": 1,
      "id": "dc73c1f7-ee6c-43e9-8bda-f9621d13518e",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "# 4ï¸âƒ£ MIXED SERVICE RESPONSE FLOW\n\nHandles user responses when services require different technician qualifications.\nUser was asked to choose: keep restricted services only, or switch to standard services.\n\nROUTES:\n- Clarify â†’ re-ask the question\n- Restricted services â†’ update Redis with restricted service list\n- Normal services â†’ update Redis with standard service list\n- Supports both CREATE and UPDATE booking flows (Is Update Flow? check)",
        "height": 784,
        "width": 2352,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1184,
        -2400
      ],
      "typeVersion": 1,
      "id": "bb00d582-706c-4a33-9eb5-34181842f291",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "# 5ï¸âƒ£ UNQUALIFIED TECH RESPONSE FLOW\n\nHandles responses when the selected technician can't perform the requested service.\nUser chooses: accept qualified tech, pick specific employee, decline, or clarify.\n\nROUTES:\n- Accept next available qualified tech â†’ set flag, route to extractor\n- Choose specific employee â†’ get employee info â†’ match tech\n- Decline â†’ wipe booking data, send decline confirmation\n- Clarify â†’ re-ask\n- Supports routing to both CREATE and UPDATE flows",
        "height": 784,
        "width": 2368,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1184,
        -944
      ],
      "typeVersion": 1,
      "id": "eb4ac9c3-cffb-448e-b05d-730526d21620",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "# 6ï¸âƒ£ INTENT ROUTER\n\nFirst-time or returning user greeting + AI intent classification.\nDetermines what the user wants: book, cancel, update, view, or general question.\n\nFLOW:\n- If3 checks if user needs greeting â†’ Greet User â†’ set greeting flag\n- Intent Router Agent classifies message into intent\n- Context Switch Identifier checks for mid-conversation intent changes\n- Intent Switch routes to: CREATE_BOOKING | CANCEL | VIEW | UPDATE | GENERAL_QUESTION",
        "height": 1328,
        "width": 1968,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1072,
        128
      ],
      "typeVersion": 1,
      "id": "5904c199-e05c-4326-9a5f-4e9e209679fc",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "# 7ï¸âƒ£ CONFIRMATION HANDLING\n\nRoutes \"confirm\"/\"save\" messages to the correct pending flow.\nSwitch3 checks which confirmation context is active.\n\nROUTES:\n- Pending update â†’ Execute Update flow\n- No pending modification â†’ notify user, no action needed",
        "height": 688,
        "width": 1504
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1200,
        -3184
      ],
      "typeVersion": 1,
      "id": "d53033bb-b8ce-4fcb-8add-cb8d24185c46",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "=agent_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "sessionTTL": 1800,
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryRedisChat",
      "typeVersion": 1.5,
      "position": [
        4528,
        3952
      ],
      "id": "2d1f5a03-7786-4a9f-9540-febf709ccd58",
      "name": "Redis Chat Memory1",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "=agent_{{ $('Set Initial Data').first().json.userPhoneNumber }}",
        "sessionTTL": 1800,
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryRedisChat",
      "typeVersion": 1.5,
      "position": [
        3920,
        6128
      ],
      "id": "fdba8728-5b14-4081-adb5-f8c99b141143",
      "name": "Redis Chat Memory2",
      "credentials": {
        "redis": {
          "id": "VgHjJLwct64e99fI",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "content": "# 8ï¸âƒ£ CREATE BOOKING â€” EXTRACTION & VALIDATION\n\nExtracts booking details (service, date/time, employee) from conversation.\nValidates against service restrictions before routing to availability check.\n\nFLOW:\n- If4: check booking limit â†’ Booking Limit Exceeded if over limit\n- pendingAlternatives? â†’ route to Alternative Selection if pending\n- readyToBook? â†’ Modification Handler if already has booking data, else Extractor\n- Extractor Agent pulls structured data â†’ State Merger routes next step\n- Check service restrictions â†’ route to Response Agent or Availability Agent\n\nRETRY: Extractor retries up to limit if extraction fails.",
        "height": 1824,
        "width": 6800,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3696,
        -736
      ],
      "typeVersion": 1,
      "id": "5f51dfe6-bb5e-4a48-ac01-c1c590379090",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "height": 624,
        "width": 944
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        10624,
        -720
      ],
      "typeVersion": 1,
      "id": "0ab7d82f-3ec3-4bae-9aab-1e7353a4b167",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "# 1ï¸âƒ£3ï¸âƒ£ UPDATE BOOKING\n\nHandles appointment modifications (reschedule, change service/tech).\n\nFLOW:\n- If User Has Bookings Update â†’ pendingUpdateAlternatives? â†’ route\n- Update Selector Agent: user picks which booking and what to change\n- Update Extractor Agent: extracts new values\n- Service restriction checks (mirrors CREATE flow)\n- Update Availability Agent: checks new slot availability\n- Execute update: modify Sheets row, swap calendar events, update blocked times",
        "height": 1952,
        "width": 8544,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3696,
        1104
      ],
      "id": "0fec1d21-9758-49c9-8109-fb7db3db6c0e",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "content": "# 1ï¸âƒ£2ï¸âƒ£ CANCEL BOOKING\n\nHandles appointment cancellation.\n\nFLOW:\n- If User Has Bookings Cancel â†’ cancel_agent if bookings exist\n- Cancel agent identifies which booking â†’ Switch2 routes\n- Calculate blocked time to remove â†’ update employee availability\n- Delete booking row from Google Sheets â†’ Delete calendar event\n- Send cancellation confirmation â†’ update Redis flags",
        "height": 960,
        "width": 3392
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3680,
        3248
      ],
      "typeVersion": 1,
      "id": "c7ef8f3f-cd6e-4552-a2c4-bbf5468c5c18",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "content": "# 1ï¸âƒ£5ï¸âƒ£ GENERAL QUESTION\n\nHandles non-booking questions (business hours, services, pricing, etc.).\nAI agent answers using business info, service list, and employee data from Google Sheets.\n\nFLOW:\n- General Question Agent â†’ GQ Response\n- GQ_readyToBook? â†’ if user had booking in progress, show summary",
        "height": 1184,
        "width": 3024,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3552,
        5344
      ],
      "typeVersion": 1,
      "id": "7b6dd52d-0b78-41dd-93cc-3c6c46d358ac",
      "name": "Sticky Note17"
    }
  ],
  "pinData": {},
  "connections": {
    "Set Processing Lock": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Get Current Processing Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Current Processing Lock": {
      "main": [
        [
          {
            "node": "Am I the Processor?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Am I the Processor?": {
      "main": [
        [
          {
            "node": "Pop All Batched Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pop All Batched Messages": {
      "main": [
        [
          {
            "node": "Delete Message List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Message List": {
      "main": [
        [
          {
            "node": "Delete Processing Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Processing Lock": {
      "main": [
        [
          {
            "node": "Combine Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Push": {
      "main": [
        [
          {
            "node": "Set Processing Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Messages": {
      "main": [
        [
          {
            "node": "Check Confirm State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "Response Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "gemini-2.5-flash": {
      "ai_languageModel": [
        [
          {
            "node": "Alternative Selection Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Save Booking This Week": {
      "main": [
        [
          {
            "node": "Create Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_userflag_can_book": {
      "main": [
        [
          {
            "node": "If User Can Book cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set UserFlag can_book": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "list_services": {
      "ai_tool": [
        [
          {
            "node": "Extractor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Registered Contact": {
      "main": [
        [
          {
            "node": "If User is Registered check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set registered_contact": {
      "main": [
        [
          {
            "node": "get_userflag_can_book",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get userflag_registered_contact": {
      "main": [
        [
          {
            "node": "If User is Registered cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User is Registered cache": {
      "main": [
        [
          {
            "node": "get_userflag_can_book",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Registered Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User is Registered check": {
      "main": [
        [
          {
            "node": "set registered_contact",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "get_userflag_can_book",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User Can Book cache": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch User Bookings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User Can Book Check": {
      "main": [
        [
          {
            "node": "Set UserFlag can_book",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set UserFlag cannot_book1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch User Bookings": {
      "main": [
        [
          {
            "node": "Count Bookings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count Bookings": {
      "main": [
        [
          {
            "node": "If User Can Book Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "get_userflag_all",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set UserFlag cannot_book1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "get_userflag_all": {
      "main": [
        [
          {
            "node": "pendingBirthday?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Text Message?": {
      "main": [
        [
          {
            "node": "Message Medium Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Increment Counter Hourly": {
      "main": [
        [
          {
            "node": "Check Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis Hourly": {
      "main": [
        [
          {
            "node": "Increment Counter Hourly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limited": {
      "main": [
        [
          {
            "node": "Send User Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Push",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit": {
      "main": [
        [
          {
            "node": "Check Rate Limited",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limiter": {
      "main": [
        [
          {
            "node": "Redis Hourly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Initial Data": {
      "main": [
        [
          {
            "node": "Rate Limiter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Set Initial Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "UID Generation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify user they dont have any pending appointments.  Ask them to start the conversation again.",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Blocked Time Range": {
      "main": [
        [
          {
            "node": "Read Employee Availability Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Employee Availability Row": {
      "main": [
        [
          {
            "node": "Find and Update Blocked Times",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find and Update Blocked Times": {
      "main": [
        [
          {
            "node": "Append or update row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Intent Router Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Greet User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gpt-5": {
      "ai_languageModel": [
        [
          {
            "node": "Extractor Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "process_availability_check": {
      "ai_tool": [
        [
          {
            "node": "Availability Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_employee_availability": {
      "ai_tool": [
        [
          {
            "node": "Availability Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_active_intent": {
      "main": [
        [
          {
            "node": "Intent Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intent Switch": {
      "main": [
        [
          {
            "node": "If4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If User Has Bookings Cancel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If User Has Bookings View",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If User Has Bookings Update",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "General Question Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "General Question Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cancel_agent": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cancel Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If4": {
      "main": [
        [
          {
            "node": "pendingAlternatives?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Booking Limit Exceeded",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_greeting": {
      "main": [
        [
          {
            "node": "Intent Router Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wipe Booking Data - Context Switch": {
      "main": [
        [
          {
            "node": "needsActiveIntentUpdate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Intent Router Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Context Switch Identifier": {
      "main": [
        [
          {
            "node": "Cleanup Needed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gemini-intent-router": {
      "ai_languageModel": [
        [
          {
            "node": "Intent Router Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Intent Router Agent": {
      "main": [
        [
          {
            "node": "Context Switch Identifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Intent Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "employee_list": {
      "ai_tool": [
        [
          {
            "node": "Extractor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "pendingAlternatives?": {
      "main": [
        [
          {
            "node": "Alternative Selection Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "readyToBook?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Alternative Selection Agent": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Alternative Selection Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Alternative Selection Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Extract Selection Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete pendingAlternatives2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repetition Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete pendingAlternatives3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_alternative": {
      "main": [
        [
          {
            "node": "delete pendingAlternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete pendingAlternatives": {
      "main": [
        [
          {
            "node": "Is User Registered?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete pendingAlternatives2": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Selection Data": {
      "main": [
        [
          {
            "node": "set_alternative",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repetition Message": {
      "main": [
        [
          {
            "node": "Repeat Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Availability Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Append or update row in sheet": {
      "main": [
        [
          {
            "node": "Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Birthday Summary": {
      "main": [
        [
          {
            "node": "Birthday Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser3": {
      "ai_outputParser": [
        [
          {
            "node": "Birthday Response Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "pendingBirthday?": {
      "main": [
        [
          {
            "node": "Birthday Response Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "awaitingMixedResponse?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Birthday Response Agent": {
      "main": [
        [
          {
            "node": "Birthday Response Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Birthday Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Birthday Response Switch": {
      "main": [
        [
          {
            "node": "Call Registration Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete_pendingBirthday",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Repeat Birthday Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "modification_delete_pendingBirthday",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Registration Agent": {
      "main": [
        [
          {
            "node": "add_contact_direct1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "add_contact_direct1": {
      "main": [
        [
          {
            "node": "set_registeredContact_direct",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete_pendingBirthday": {
      "main": [
        [
          {
            "node": "set_userflag_readyToBook_birthday",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_registeredContact_direct": {
      "main": [
        [
          {
            "node": "delete_pendingBirthday",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_readyToBook_birthday": {
      "main": [
        [
          {
            "node": "Build Birthday Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is User Registered?": {
      "main": [
        [
          {
            "node": "set_readyToBook_alt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "set_pendingBirthday_alternative",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_pendingBirthday_alternative": {
      "main": [
        [
          {
            "node": "Birthday Request Alternative",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gemini-intent-router1": {
      "ai_languageModel": [
        [
          {
            "node": "Birthday Response Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "set_readyToBook_alt": {
      "main": [
        [
          {
            "node": "confirmation message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extractor Agent": {
      "main": [
        [
          {
            "node": "State Merger & Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Should Retry Extractor?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Extractor Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "State Merger & Router": {
      "main": [
        [
          {
            "node": "Redis State Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis State Update": {
      "main": [
        [
          {
            "node": "Get Employee Info For Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Switch": {
      "main": [
        [
          {
            "node": "Response Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Availability Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Available?": {
      "main": [
        [
          {
            "node": "Is Next Available?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Employee Availability Range",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Agent": {
      "main": [
        [
          {
            "node": "Response Agent Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability Agent": {
      "main": [
        [
          {
            "node": "Available?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Availability Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Availability Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "readyToBook?": {
      "main": [
        [
          {
            "node": "Modification Handler Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_pendingAlternatives": {
      "main": [
        [
          {
            "node": "If7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Modification Handler Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Modification Handler Agent": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Modification Handler Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "delete_for_service_change",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete_for_datetime_change",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete_for_technician_change",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "delete_for_full_reset",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "GQ_or_Repeat?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Registered?": {
      "main": [
        [
          {
            "node": "set_userflag_readyToBook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "set_userflag_pendingBirthday",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Summary": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_readyToBook": {
      "main": [
        [
          {
            "node": "Build Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Response Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser5": {
      "ai_outputParser": [
        [
          {
            "node": "Modification Handler Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "delete_for_service_change": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete_for_datetime_change": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete_for_full_reset": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete_for_technician_change": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "General Question Agent": {
      "main": [
        [
          {
            "node": "GQ Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "GQ Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gq_list_biz_info": {
      "ai_tool": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "gq_list_services": {
      "ai_tool": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "gq_employee_availability": {
      "ai_tool": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "employee_list1": {
      "ai_tool": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get Employee Availability Range": {
      "main": [
        [
          {
            "node": "Availability Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If7": {
      "main": [
        [
          {
            "node": "Build Specific Employee Messag",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build No Employees Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Specific Employee Messag": {
      "main": [
        [
          {
            "node": "Present Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build No Employees Message": {
      "main": [
        [
          {
            "node": "Present Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Needed?": {
      "main": [
        [
          {
            "node": "Wipe Booking Data - Context Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "needsActiveIntentUpdate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "needsActiveIntentUpdate": {
      "main": [
        [
          {
            "node": "set_userflag_active_intent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Intent Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Assigned Employee Data": {
      "main": [
        [
          {
            "node": "Registered?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability Code": {
      "main": [
        [
          {
            "node": "Alternative Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Greet User": {
      "main": [
        [
          {
            "node": "set_userflag_greeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Alternative Found?": {
      "main": [
        [
          {
            "node": "set_userflag_pendingAlternatives",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No availability (bug)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send User Message": {
      "main": [
        [
          {
            "node": "Send Owner Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Owner Message": {
      "main": [
        [
          {
            "node": "Send Rate Limit Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Is Text Message?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Booking confirmed message": {
      "main": [
        [
          {
            "node": "Calculate Blocked Time Range",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delete pendingAlternatives3": {
      "main": [
        [
          {
            "node": "Set NEXT_AVAILABLE Tech",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set NEXT_AVAILABLE Tech": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_pendingBirthday": {
      "main": [
        [
          {
            "node": "Birthday Request Main",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "modification_delete_pendingBirthday": {
      "main": [
        [
          {
            "node": "Modification Handler Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GQ Response": {
      "main": [
        [
          {
            "node": "GQ_readyToBook?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build GQ Summary": {
      "main": [
        [
          {
            "node": "GQ Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GQ_readyToBook?": {
      "main": [
        [
          {
            "node": "Build GQ Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GQ_or_Repeat?": {
      "main": [
        [
          {
            "node": "General Question Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build GQ Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User Has Bookings Cancel": {
      "main": [
        [
          {
            "node": "cancel_agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Bookings Cancel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User Has Bookings Update": {
      "main": [
        [
          {
            "node": "pendingUpdateAlternatives?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Bookings Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If User Has Bookings View": {
      "main": [
        [],
        [
          {
            "node": "No Bookings View",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model5": {
      "ai_languageModel": [
        [
          {
            "node": "cancel_agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser6": {
      "ai_outputParser": [
        [
          {
            "node": "cancel_agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Calculate Blocked Time to Remove",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cancel Clarification Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Blocked Time to Remove": {
      "main": [
        [
          {
            "node": "Read Employee Availability Row1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Employee Availability Row1": {
      "main": [
        [
          {
            "node": "Remove Blocked Time",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Blocked Time": {
      "main": [
        [
          {
            "node": "Update Employee Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Employee Availability": {
      "main": [
        [
          {
            "node": "Delete Booking Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Booking Row": {
      "main": [
        [
          {
            "node": "Delete Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Cancel Confirmation": {
      "main": [
        [
          {
            "node": "Post Cancellation Flag Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser7": {
      "ai_outputParser": [
        [
          {
            "node": "Update Selector Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model6": {
      "ai_languageModel": [
        [
          {
            "node": "Update Selector Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Update Selector Agent": {
      "main": [
        [
          {
            "node": "Process Selection Result",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Alternative Selection Error2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Update Extractor Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "employee_list2": {
      "ai_tool": [
        [
          {
            "node": "Update Extractor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "list_services1": {
      "ai_tool": [
        [
          {
            "node": "Update Extractor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser8": {
      "ai_outputParser": [
        [
          {
            "node": "Update Extractor Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Update Extractor Agent": {
      "main": [
        [
          {
            "node": "Update State Merger",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Should Retry Update Extractor?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update State Merger": {
      "main": [
        [
          {
            "node": "Store Update Extraction State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Update Extraction State": {
      "main": [
        [
          {
            "node": "Route to Cancel Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Extract Phase Results": {
      "main": [
        [
          {
            "node": "Store Merged State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Merged State": {
      "main": [
        [
          {
            "node": "Get Update Employee Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Update Response Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Update Route Switch": {
      "main": [
        [
          {
            "node": "Update Response Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Update Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Response Agent": {
      "main": [
        [
          {
            "node": "Update Response Agent Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Response Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser9": {
      "ai_outputParser": [
        [
          {
            "node": "Update Availability Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Update Availability Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "update_get_employee_availability": {
      "ai_tool": [
        [
          {
            "node": "Update Availability Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "update_process_availability_check": {
      "ai_tool": [
        [
          {
            "node": "Update Availability Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Update Availability": {
      "main": [
        [
          {
            "node": "Update Availability Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Availability Agent": {
      "main": [
        [
          {
            "node": "Update Available?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Availability Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Agent Message": {
      "main": [
        []
      ]
    },
    "Update Available?": {
      "main": [
        [
          {
            "node": "set_userflag_Update_readyToSave",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Get Employee Availability Range",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_Update_readyToSave": {
      "main": [
        [
          {
            "node": "Build Update Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Update Summary": {
      "main": [
        [
          {
            "node": "set_userflag_Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Get Employee Availability Range": {
      "main": [
        [
          {
            "node": "Update Availability Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Availability Code": {
      "main": [
        [
          {
            "node": "Update Alternative Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Alternative Found?": {
      "main": [
        [
          {
            "node": "set_userflag_pendingUpdateAlternatives",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No update availability (bug)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_pendingUpdateAlternatives": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Build Update Specific Employee Msg",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Update No Employees Msg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Update Specific Employee Msg": {
      "main": [
        [
          {
            "node": "Present Update Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Update No Employees Msg": {
      "main": [
        [
          {
            "node": "Present Update Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message contains \"confirm\" or \"save\"?": {
      "main": [
        [
          {
            "node": "Switch3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch3": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If6": {
      "main": [
        [
          {
            "node": "Execute Update",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify user they dont have any pending modificaitons",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Update": {
      "main": [
        [
          {
            "node": "Needs Update Blocked Time?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Update Blocked Time?": {
      "main": [
        [
          {
            "node": "Calculate Old Blocked Time Info",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Booking Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Old Blocked Time Info": {
      "main": [
        [
          {
            "node": "Read Old Employee Availability Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Old Employee Availability Row": {
      "main": [
        [
          {
            "node": "Remove Old Blocked Time (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Old Blocked Time (Code)": {
      "main": [
        [
          {
            "node": "Update Old Employee Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Old Employee Availability": {
      "main": [
        [
          {
            "node": "Read New Employee Availability Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read New Employee Availability Row": {
      "main": [
        [
          {
            "node": "Find and Update Blocked Times1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find and Update Blocked Times1": {
      "main": [
        [
          {
            "node": "Append or update row in sheet1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append or update row in sheet1": {
      "main": [
        [
          {
            "node": "Update Booking Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Booking Row": {
      "main": [
        [
          {
            "node": "Delete Old Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Update State": {
      "main": [
        [
          {
            "node": "Send Update Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "pendingUpdateAlternatives?": {
      "main": [
        [
          {
            "node": "Update Alternative Selection Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Awaiting Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser10": {
      "ai_outputParser": [
        [
          {
            "node": "Update Alternative Selection Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model9": {
      "ai_languageModel": [
        [
          {
            "node": "Update Alternative Selection Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Update Alternative Selection Agent": {
      "main": [
        [
          {
            "node": "Switch4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Alternative Selection Error1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch4": {
      "main": [
        [
          {
            "node": "Accept Update Alternative",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set Update NEXT_AVAILABLE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Clear Update Alternatives",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Clear All Update State",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Repeat Update Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Accept Update Alternative": {
      "main": [
        [
          {
            "node": "Set Accept Update State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Accept Update State": {
      "main": [
        [
          {
            "node": "Send Update Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Update NEXT_AVAILABLE": {
      "main": [
        [
          {
            "node": "Clear Update Alternatives & Set NEXT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Update Alternatives & Set NEXT": {
      "main": [
        [
          {
            "node": "Prepare Update Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Update Alternatives": {
      "main": [
        [
          {
            "node": "Prep Update Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear All Update State": {
      "main": [
        [
          {
            "node": "Send Update Cancelled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repeat Update Alternatives": {
      "main": [
        [
          {
            "node": "Send Repeat Update Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser11": {
      "ai_outputParser": [
        [
          {
            "node": "Context Switch Identifier Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model10": {
      "ai_languageModel": [
        [
          {
            "node": "Context Switch Identifier Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Context Switch Identifier Agent": {
      "main": [
        [
          {
            "node": "Switch5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Alternative Selection Error3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch5": {
      "main": [
        [
          {
            "node": "Prep Update Extractor",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Selector Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Selection Result": {
      "main": [
        [
          {
            "node": "Selection Status Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Selection Status Switch": {
      "main": [
        [
          {
            "node": "Save Selection & Await Change",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ask Which Appointment Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Selection & Await Change": {
      "main": [
        [
          {
            "node": "Ask What To Change",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Awaiting Flag": {
      "main": [
        [
          {
            "node": "Awaiting Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Awaiting Route Switch": {
      "main": [
        [
          {
            "node": "Context Switch Identifier Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Selector Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ask Which Appointment Code": {
      "main": [
        [
          {
            "node": "Ask Which Appointment Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_userflag_Ready": {
      "main": [
        [
          {
            "node": "Send Update Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Extractor": {
      "main": [
        [
          {
            "node": "Extractor Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Retry Update Extractor?": {
      "main": [
        [
          {
            "node": "Increment Update Extractor Retry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extractor Error1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Increment Update Extractor Retry": {
      "main": [
        [
          {
            "node": "Prep Update Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Increment Extractor Retry": {
      "main": [
        [
          {
            "node": "Prep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Retry Extractor?": {
      "main": [
        [
          {
            "node": "Increment Extractor Retry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extractor Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Update Extractor": {
      "main": [
        [
          {
            "node": "Update Extractor Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route to Cancel Check": {
      "main": [
        [
          {
            "node": "Prepare Cancel Redirect",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Extract Phase Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cancel Redirect": {
      "main": [
        [
          {
            "node": "Clear Update State for Cancel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Update State for Cancel": {
      "main": [
        [
          {
            "node": "Single Service Removal Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Confirm State": {
      "main": [
        [
          {
            "node": "Has Confirm State?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Confirm State?": {
      "main": [
        [
          {
            "node": "Call 'Booking Confirmation System Queue'",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Business Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Business Cache": {
      "main": [
        [
          {
            "node": "get userflag_registered_contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UID Generation": {
      "main": [
        [
          {
            "node": "Save Booking This Week",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gemini-2.5-flash1": {
      "ai_languageModel": [
        [
          {
            "node": "Extractor Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Availability Error": {
      "main": [
        []
      ]
    },
    "Check Service Restrictions": {
      "main": [
        [
          {
            "node": "Service Restriction Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Service Restriction Switch": {
      "main": [
        [
          {
            "node": "Mixed Services Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unqualified Tech Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed Services Message": {
      "main": [
        [
          {
            "node": "Store Restriction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Restriction Data": {
      "main": [
        [
          {
            "node": "Set Awaiting Mixed Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unqualified Tech Message": {
      "main": [
        [
          {
            "node": "Store Unqualified Tech State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "awaitingMixedResponse?": {
      "main": [
        [
          {
            "node": "Mixed Response Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "awaitingUnqualifiedResponse?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed Responses Switch": {
      "main": [
        [
          {
            "node": "Clarify Mixed Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Update Flow?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Update Flow?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Birthday Summary": {
      "main": [
        []
      ]
    },
    "Get Employee Info For Names": {
      "main": [
        [
          {
            "node": "Check Service Restrictions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gemini-intent-router2": {
      "ai_languageModel": [
        [
          {
            "node": "Mixed Response Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Mixed Response Agent": {
      "main": [
        [
          {
            "node": "Get Restriction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update to Restricted Services": {
      "main": [
        [
          {
            "node": "Update Redis After Mixed Choice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update to Normal Services": {
      "main": [
        [
          {
            "node": "Update Redis After Mixed Choice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Redis After Mixed Choice": {
      "main": [
        [
          {
            "node": "Delete Restriction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Restriction Data": {
      "main": [
        [
          {
            "node": "Redirect After Mixed Choice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redirect After Mixed Choice": {
      "main": [
        [
          {
            "node": "State Merger & Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Next Available?": {
      "main": [
        [
          {
            "node": "Set Assigned Employee Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Registered?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Unqualified Tech State": {
      "main": [
        [
          {
            "node": "Wipe Unqualified Tech",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "awaitingUnqualifiedResponse?": {
      "main": [
        [
          {
            "node": "Unqualified Response Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message contains \"confirm\" or \"save\"?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser12": {
      "ai_outputParser": [
        [
          {
            "node": "Unqualified Response Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "gemini-intent-router3": {
      "ai_languageModel": [
        [
          {
            "node": "Unqualified Response Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Unqualified Response Agent": {
      "main": [
        [
          {
            "node": "Unqualified Responses Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unqualified Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unqualified Responses Switch": {
      "main": [
        [
          {
            "node": "Set Qualified Next Available",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Employee Info For Unqualified",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wipe Booking Data - Declined",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Clarify Unqualified Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Qualified Next Available": {
      "main": [
        [
          {
            "node": "Update Redis Qualified Next Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Redis Qualified Next Available": {
      "main": [
        [
          {
            "node": "Clear Unqualified Flag 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Unqualified Flag 1": {
      "main": [
        [
          {
            "node": "Is Unqualified Update Flow?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Employee Info For Unqualified": {
      "main": [
        [
          {
            "node": "Match Qualified Tech",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Qualified Tech": {
      "main": [
        [
          {
            "node": "Tech Matched?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tech Matched?": {
      "main": [
        [
          {
            "node": "Update Redis Specific Tech",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Tech Not Found Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Redis Specific Tech": {
      "main": [
        [
          {
            "node": "Is Unqualified Update Flow?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wipe Booking Data - Declined": {
      "main": [
        [
          {
            "node": "Send Decline Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Availability From Unqualified": {
      "main": [
        [
          {
            "node": "Availability Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Update Employee Info": {
      "main": [
        [
          {
            "node": "Check Update Service Restrictions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Update Service Restrictions": {
      "main": [
        [
          {
            "node": "Update Service Restriction Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Service Restriction Switch": {
      "main": [
        [
          {
            "node": "Update Mixed Services Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Unqualified Tech Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Mixed Services Message": {
      "main": [
        [
          {
            "node": "Store Update Restriction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Update Restriction Data": {
      "main": [
        [
          {
            "node": "Set Update Awaiting Mixed Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Unqualified Tech Message": {
      "main": [
        [
          {
            "node": "Store Update Unqualified State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Update Flow?": {
      "main": [
        [
          {
            "node": "Update to Restricted - Update Flow",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update to Restricted Services",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update to Restricted - Update Flow": {
      "main": [
        [
          {
            "node": "Update Redis After Mixed - Update Flow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Update Restriction Data": {
      "main": [
        [
          {
            "node": "Redirect to Update Flow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Update Flow?1": {
      "main": [
        [
          {
            "node": "Update to Normal - Update Flow",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update to Normal Services",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update to Normal - Update Flow": {
      "main": [
        [
          {
            "node": "Update Redis After Mixed - Update Flow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Redis After Mixed - Update Flow": {
      "main": [
        [
          {
            "node": "Clear Update Mixed Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Update Mixed Flag": {
      "main": [
        [
          {
            "node": "Delete Update Restriction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redirect to Update Flow": {
      "main": [
        [
          {
            "node": "Update State Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Unqualified Update Flow?": {
      "main": [
        [
          {
            "node": "Prep Update Availability From Unqualified",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prep Availability From Unqualified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Update Availability From Unqualified": {
      "main": [
        [
          {
            "node": "Prepare Update Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Restriction Data": {
      "main": [
        [
          {
            "node": "Mixed Responses Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Calendar Event": {
      "main": [
        [
          {
            "node": "Save Calendar Event ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Calendar Event ID": {
      "main": [
        [
          {
            "node": "Booking confirmed message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Calendar Event": {
      "main": [
        [
          {
            "node": "Send Cancel Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Calendar Event": {
      "main": [
        [
          {
            "node": "Save New Calendar Event ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Calendar Event": {
      "main": [
        [
          {
            "node": "Create New Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save New Calendar Event ID": {
      "main": [
        [
          {
            "node": "Clear Update State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis Chat Memory1": {
      "ai_memory": [
        [
          {
            "node": "cancel_agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Redis Chat Memory2": {
      "ai_memory": [
        [
          {
            "node": "General Question Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "pTZRdN1jYR55Q2IA"
  },
  "versionId": "433a5302-e6ec-4aa7-8b2d-321df59402f4",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "168c7d7211133de6d8ec393ae7a3e3a882a0d6cfc6397ea1db2fe66f28042b4e"
  },
  "id": "SSwwOevhsoBHBjwC",
  "tags": []
}